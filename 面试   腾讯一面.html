<html>
<head>
  <title>面试  : 腾讯一面</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <meta name="application-data:corenote-hostUUID" content="C8940BC2-A53C-4B55-B59C-4779464BC778"/>
  <meta name="application-data:corenote-localUUID" content="41CC208C-A13C-4303-8646-B879CB5A8558"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1051"/>
<h1>面试  : 腾讯一面</h1>

<div><span><div><span style="font-size: 18px; font-weight: bold;">前言：先自己尝试去回答，回答不了再看参考答案，你才能学的更多！</span></div><div><span style="font-size: 18px; font-weight: bold;"><br/></span></div><div><span style="font-size: 14px; font-weight: bold;">1.使用了第三方库, 有看它们是怎么实现的吗？</span></div><div><span style="font-size: 14px; color: rgb(0, 0, 0); font-weight: bold;">2.强连通量算法了解嘛？</span></div><div><span style="font-size: 14px; color: rgb(0, 0, 0); font-weight: bold;">3.遇到tableView卡顿嘛？会造成卡顿的原因大致有哪些？</span></div><div><span style="font-size: 14px; color: rgb(0, 0, 0); font-weight: bold;">4.M、V、C相互通讯规则你知道的有哪些？</span></div><div><span style="font-size: 14px; color: rgb(0, 0, 0); font-weight: bold;">5.NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?</span></div><div><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 24px; font-weight: bold;">1.使用了第三方库, 有看他们是怎么实现的吗？</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">例：SD、YY、AFN、MJ等！</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">&lt;1&gt;.SD为例：</span></div><div>1.入口 setImageWithURL:placeholderImage:options:</div><div>会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。</div><div><br/></div><div>2.进入 SDWebImageManagerdownloadWithURL:delegate:options:userInfo:，</div><div>交给 SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:.</div><div><br/></div><div>3.先从内存图片缓存查找是否有图片，</div><div>如果内存中已经有图片缓存，SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。</div><div><br/></div><div>4.SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage:</div><div> 到 UIImageView+WebCache 等前端展示图片。</div><div><br/></div><div>5.如果内存缓存中没有，生成 NSInvocationOperation</div><div>添加到队列开始从硬盘查找图片是否已经缓存。</div><div><br/></div><div>6.根据 URLKey 在硬盘缓存目录下尝试读取图片文件。</div><div>这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。</div><div><br/></div><div>7.如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中    </div><div>（如果空闲内存过小，会先清空内存缓存）。    </div><div>SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。</div><div>进而回调展示图片。</div><div><br/></div><div>8.如果从硬盘缓存目录读取不到图片，</div><div>说明所有缓存都不存在该图片，需要下载图片，</div><div>回调 imageCache:didNotFindImageForKey:userInfo:。</div><div><br/></div><div>9.共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。</div><div><br/></div><div>10.图片下载由 NSURLConnection 来做，</div><div>实现相关 delegate 来判断图片下载中、下载完成和下载失败。</div><div><br/></div><div>11.connection:didReceiveData: 中</div><div>利用 ImageIO 做了按图片下载进度加载效果。</div><div><br/></div><div>12.connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。</div><div><br/></div><div>13.图片解码处理在一个 NSOperationQueue 完成，</div><div>不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，</div><div>最好也在这里完成，效率会好很多。</div><div><br/></div><div>14.在主线程 notifyDelegateOnMainThreadWithInfo:</div><div>宣告解码完成，</div><div>imageDecoder:didFinishDecodingImage:userInfo:</div><div> 回调给 SDWebImageDownloader。</div><div><br/></div><div>15.imageDownloader:didFinishWithImage:</div><div> 回调给 SDWebImageManager 告知图片下载完成。</div><div><br/></div><div>16.通知所有的 downloadDelegates 下载完成，</div><div>回调给需要的地方展示图片。</div><div><br/></div><div>17.将图片保存到 SDImageCache 中，</div><div>内存缓存和硬盘缓存同时保存。</div><div>写文件到硬盘也在以单独 NSInvocationOperation 完成，</div><div>避免拖慢主线程。</div><div><br/></div><div>18.SDImageCache 在初始化的时候会注册一些消息通知，</div><div>在内存警告或退到后台的时候清理内存图片缓存，</div><div>应用结束的时候清理过期图片。</div><div><br/></div><div>19.SDWI 也提供了 UIButton+WebCache 和</div><div>MKAnnotationView+WebCache，方便使用。</div><div><br/></div><div>20.SDWebImagePrefetcher 可以预先下载图片，</div><div>方便后续使用。</div><div><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 24px; font-weight: bold;">2.强连通分量了解嘛？</span></div><div><span style="font-weight: bold;">概念：</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">有向图强连通分量：在有向图G中，如果两个顶点vi,vj间（vi&gt;vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><h2><span style="font-weight: bold;">定义：</span></h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">有向图强连通分量：</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点强连通（strongly connected）。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">如果有向图G的每两个顶点都强连通，则称G是一个强连通图。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">非强连通图有向图的极大强连通子图，成为强连通分量（strongly connected components）。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">下图中，子图{1,2,3,4}为一个强连通分量，因为顶点1,2,3,4两两可达，{5}，{6}也分别是两个强连通分量。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><div><img src="面试   腾讯一面_files/Image.jpg" type="image/jpeg" data-filename="Image.jpg"/><br/></div></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">直接根据定义，用双向遍历取交际的方法求强连通分量，时间复杂度为O（N^2+M）。更好的方法是Kosaraju算法或者Tarjan算法。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">两者的时间复杂度都是O（N+M）。本文介绍的是Tarjan算法。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><h2><span style="font-weight: bold;">算法原理：（Tarjan）</span></h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">Tarjan算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一颗子树。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以盘对栈顶到栈中的节点是否为一个强连通分量。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">定义DFN（u）为节点u搜索的次序编号（时间戳）。Low（u）为u或者u的子树能够追溯到的最早的栈中的节点的次序号。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">由定义可以得出：</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">Low（u）= Min { DFN（u）， Low（v）} （（u，v）为树枝边，u为v的父节点DFN（v），（u，v）为指向栈中节点的后向边（非横叉边））</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">当DFN（u）=Low（u）时，以u为根的搜索子树上所有节点是一个强连通分量。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><h2><span style="font-weight: bold;">代码实现：</span></h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="color: rgb(0, 112, 192); font-weight: bold;">[cpp]</span><span style="color: rgb(0, 112, 192);">：</span></div><ol start="1"><li><span style="color: rgb(0, 112, 192);">#include &lt;stdio.h&gt;  </span></li><li><span style="color: rgb(0, 112, 192);">#include &lt;string.h&gt;  </span></li><li><span style="color: rgb(0, 112, 192);">#include &lt;vector&gt;  </span></li><li><span style="color: rgb(0, 112, 192);">#include &lt;stack&gt;  </span></li><li><span style="color: rgb(0, 112, 192);">using namespace std;  </span></li><li><span style="color: rgb(0, 112, 192);">#define MIN(a,b) ((a)&lt;(b)?(a):(b))  </span></li><li><span style="color: rgb(0, 112, 192);">#define N 10005             // 题目中可能的最大点数   </span></li><li><span style="color: rgb(0, 112, 192);">stack&lt;int&gt;sta;                // 存储已遍历的结点   </span></li><li><span style="color: rgb(0, 112, 192);">vector&lt;int&gt;gra[N];            // 邻接表表示图   </span></li><li><span style="color: rgb(0, 112, 192);">int dfn[N];                 // 深度优先搜索访问次序   </span></li><li><span style="color: rgb(0, 112, 192);">int low[N];                 // 能追溯到的最早的次序   </span></li><li><span style="color: rgb(0, 112, 192);">int InStack[N];             // 检查是否在栈中(2为在栈中，1为已访问，且不在栈中，0为不在)   </span></li><li><span style="color: rgb(0, 112, 192);">vector&lt;int&gt; Component[N];     // 获得强连通分量结果  </span></li><li><span style="color: rgb(0, 112, 192);">int InComponent[N];         // 记录每个点在第几号强连通分量里  </span></li><li><span style="color: rgb(0, 112, 192);">int index,ComponentNumber;  // 索引号，强连通分量个数   </span></li><li><span style="color: rgb(0, 112, 192);">int n, m;                   // 点数，边数   </span></li><li><span style="color: rgb(0, 112, 192);">  </span></li><li><span style="color: rgb(0, 112, 192);">void init(void)  </span></li><li><span style="color: rgb(0, 112, 192);">{  </span></li><li><span style="color: rgb(0, 112, 192);">    memset(dfn, 0, sizeof(dfn));  </span></li><li><span style="color: rgb(0, 112, 192);">    memset(low, 0, sizeof(low));  </span></li><li><span style="color: rgb(0, 112, 192);">    memset(InStack, 0, sizeof(InStack));  </span></li><li><span style="color: rgb(0, 112, 192);">    index = ComponentNumber = 0;  </span></li><li><span style="color: rgb(0, 112, 192);">    for (int i = 1; i &lt;= n; ++ i)  </span></li><li><span style="color: rgb(0, 112, 192);">    {  </span></li><li><span style="color: rgb(0, 112, 192);">        gra[i].clear();  </span></li><li><span style="color: rgb(0, 112, 192);">        Component[i].clear();  </span></li><li><span style="color: rgb(0, 112, 192);">    }  </span></li><li><span style="color: rgb(0, 112, 192);">      </span></li><li><span style="color: rgb(0, 112, 192);">    while(!sta.empty())  </span></li><li><span style="color: rgb(0, 112, 192);">        sta.pop();  </span></li><li><span style="color: rgb(0, 112, 192);">}  </span></li><li><span style="color: rgb(0, 112, 192);">  </span></li><li><span style="color: rgb(0, 112, 192);">void tarjan(int u)  </span></li><li><span style="color: rgb(0, 112, 192);">{  </span></li><li><span style="color: rgb(0, 112, 192);">    Instack[u] = 2;  </span></li><li><span style="color: rgb(0, 112, 192);">    low[u] = dfn[u] = ++ index;  </span></li><li><span style="color: rgb(0, 112, 192);">    sta.push(u);  </span></li><li><span style="color: rgb(0, 112, 192);">  </span></li><li><span style="color: rgb(0, 112, 192);">    for (int i = 0; i &lt; gra[u].size(); ++ i)  </span></li><li><span style="color: rgb(0, 112, 192);">    {  </span></li><li><span style="color: rgb(0, 112, 192);">        int t = gra[u][i];  </span></li><li><span style="color: rgb(0, 112, 192);">        if (dfn[t] == 0)  </span></li><li><span style="color: rgb(0, 112, 192);">        {  </span></li><li><span style="color: rgb(0, 112, 192);">            tarjan(t);  </span></li><li><span style="color: rgb(0, 112, 192);">            low[u] = MIN(low[u], low[t]);  </span></li><li><span style="color: rgb(0, 112, 192);">        }   </span></li><li><span style="color: rgb(0, 112, 192);">        else if (InStack[t] == 2)  </span></li><li><span style="color: rgb(0, 112, 192);">        {  </span></li><li><span style="color: rgb(0, 112, 192);">            low[u] = MIN(low[u], dfn[t]);  </span></li><li><span style="color: rgb(0, 112, 192);">        }  </span></li><li><span style="color: rgb(0, 112, 192);">    }  </span></li><li><span style="color: rgb(0, 112, 192);">  </span></li><li><span style="color: rgb(0, 112, 192);">    if (low[u] == dfn[u])  </span></li><li><span style="color: rgb(0, 112, 192);">    {  </span></li><li><span style="color: rgb(0, 112, 192);">        ++ ComponentNumber;  </span></li><li><span style="color: rgb(0, 112, 192);">        while (!sta.empty())  </span></li><li><span style="color: rgb(0, 112, 192);">        {  </span></li><li><span style="color: rgb(0, 112, 192);">            int j = sta.top();  </span></li><li><span style="color: rgb(0, 112, 192);">            sta.pop();  </span></li><li><span style="color: rgb(0, 112, 192);">            InStack[j] = 1;  </span></li><li><span style="color: rgb(0, 112, 192);">            Component[ComponentNumber].push_back(j);  </span></li><li><span style="color: rgb(0, 112, 192);">            InComponent[j]=ComponentNumber;  </span></li><li><span style="color: rgb(0, 112, 192);">            if (j == u)  </span></li><li><span style="color: rgb(0, 112, 192);">                binputak;  </span></li><li><span style="color: rgb(0, 112, 192);">        }  </span></li><li><span style="color: rgb(0, 112, 192);">    }  </span></li><li><span style="color: rgb(0, 112, 192);">}  </span></li><li><span style="color: rgb(0, 112, 192);">   </span></li><li><span style="color: rgb(0, 112, 192);">void input(void)  </span></li><li><span style="color: rgb(0, 112, 192);">{  </span></li><li><span style="color: rgb(0, 112, 192);">    for(int i=1;i&lt;=m;i++)  </span></li><li><span style="color: rgb(0, 112, 192);">    {  </span></li><li><span style="color: rgb(0, 112, 192);">        int a,b;  </span></li><li><span style="color: rgb(0, 112, 192);">        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);  </span></li><li><span style="color: rgb(0, 112, 192);">        gra[a].push_back(b);  </span></li><li><span style="color: rgb(0, 112, 192);">    }  </span></li><li><span style="color: rgb(0, 112, 192);">}  </span></li><li><span style="color: rgb(0, 112, 192);">   </span></li><li><span style="color: rgb(0, 112, 192);">void solve(void)  </span></li><li><span style="color: rgb(0, 112, 192);">{  </span></li><li><span style="color: rgb(0, 112, 192);">    for(int i=1;i&lt;=n;i++)  </span></li><li><span style="color: rgb(0, 112, 192);">        if(!dfn[i])  </span></li><li><span style="color: rgb(0, 112, 192);">            tarjan(i);  </span></li><li><span style="color: rgb(0, 112, 192);">    if(ComponentNumber&gt;1)  </span></li><li><span style="color: rgb(0, 112, 192);">        puts(&quot;No&quot;);  </span></li><li><span style="color: rgb(0, 112, 192);">    else  </span></li><li><span style="color: rgb(0, 112, 192);">        puts(&quot;Yes&quot;);  </span></li><li><span style="color: rgb(0, 112, 192);">}  </span></li><li><span style="color: rgb(0, 112, 192);">   </span></li><li><span style="color: rgb(0, 112, 192);">int main()  </span></li><li><span style="color: rgb(0, 112, 192);">{  </span></li><li><span style="color: rgb(0, 112, 192);">    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m),n+m)  </span></li><li><span style="color: rgb(0, 112, 192);">    {  </span></li><li><span style="color: rgb(0, 112, 192);">        init();  </span></li><li><span style="color: rgb(0, 112, 192);">        input();  </span></li><li><span style="color: rgb(0, 112, 192);">        solve();  </span></li><li><span style="color: rgb(0, 112, 192);">    }  </span></li><li><span style="color: rgb(0, 112, 192);">} </span></li></ol><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 24px; font-weight: bold;">3.遇到tableView卡顿嘛？会造成卡顿的原因大致有哪些？</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div><span style="font-size: 14px; font-weight: bold;">可能造成tableView卡顿的原因有：</span></div><div><span style="font-size: 14px; font-weight: bold;">1.最常用的就是cell的重用， 注册重用标识符</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; font-size: 14px;">如果不重用cell时，每当一个cell显示到屏幕上时，就会重新创建一个新的cell；</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; font-size: 14px;">如果有很多数据的时候，就会堆积很多cell。</span></div><div><span style="font-size: 14px;">如果重用cell，为cell创建一个ID，每当需要显示cell 的时候，都会先去缓冲池中寻找可循环利用的cell，如果没有再重新创建cell</span></div><div><br/></div><div><span style="font-size: 14px; font-weight: bold;">2.避免cell的重新布局</span></div><div><br/></div><div><span style="font-size: 14px;">    cell的布局填充等操作 比较耗时，一般创建时就布局好</span></div><div><span style="font-size: 14px;">    如可以将cell单独放到一个自定义类，初始化时就布局好</span></div><div><br/></div><div><span style="font-size: 14px; font-weight: bold;">3.提前计算并缓存cell的属性及内容</span></div><div><br/></div><div><span style="font-size: 14px;">    当我们创建cell的数据源方法时，编译器并不是先创建cell 再定cell的高度</span></div><div><span style="font-size: 14px;">    而是先根据内容一次确定每一个cell的高度，高度确定后，再创建要显示的cell，滚动时，每当cell进入凭虚都会计算高度，提前估算高度告诉编译器，编译器知道高度后，紧接着就会创建cell，这时再调用高度的具体计算方法，这样可以方式浪费时间去计算显示以外的cell</span></div><div><br/></div><div><span style="font-size: 14px; font-weight: bold;">4.减少cell中控件的数量</span></div><div><br/></div><div><span style="font-size: 14px;">    尽量使cell得布局大致相同，不同风格的cell可以使用不用的重用标识符，初始化时添加控件，</span></div><div><span style="font-size: 14px;">    不适用的可以先隐藏</span></div><div><br/></div><div><span style="font-size: 14px; font-weight: bold;">5.不要使用ClearColor，无背景色，透明度也不要设置为0</span></div><div><br/></div><div><span style="font-size: 14px;">    渲染耗时比较长</span></div><div><br/></div><div><span style="font-size: 14px; font-weight: bold;">6.使用局部更新</span></div><div><br/></div><div><span style="font-size: 14px;">    如果只是更新某组的话，使用reloadSection进行局部更新</span></div><div><br/></div><div><span style="font-size: 14px; font-weight: bold;">7.加载网络数据，下载图片，使用异步加载，并缓存</span></div><div><br/></div><div><span style="font-size: 14px; font-weight: bold;">8.少使用addView 给cell动态添加view</span></div><div><br/></div><div><span style="font-size: 14px; font-weight: bold;">9.按需加载cell，cell滚动很快时，只加载范围内的cell</span></div><div><br/></div><div><span style="font-size: 14px; font-weight: bold;">10.不要实现无用的代理方法，tableView只遵守两个协议</span></div><div><br/></div><div><span style="font-size: 14px; font-weight: bold;">11.缓存行高：estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可</span></div><div><br/></div><div style="font-size: 14px; margin-top: 1em; margin-bottom: 1em;"><div><span style="font-size: 14px; font-family: Arial; font-weight: bold;">12.</span><span style="font-size: 14px; font-family: Arial; font-weight: bold;">不要做多余的绘制工作。</span></div><div><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">在实现</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">drawRect:</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">的时候，它的</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">rect</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">参数就是需要绘制的区域，这个区域之外的不需要进行绘制。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">例如上例中，就可以用</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">CGRectIntersectsRect</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">、</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">CGRectIntersection</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">或</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">CGRectContainsRect</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">判断是否需要绘制</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">image</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">和</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">text</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">，然后再调用绘制方法。</span></div></div><div style="font-size: 14px; margin-top: 1em; margin-bottom: 1em;"><div><span style="font-size: 14px; font-family: Arial; font-weight: bold;">13.</span><span style="font-size: 14px; font-family: Arial; font-weight: bold;">预渲染图像。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">bitmap context</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">里先将其画一遍，导出成</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">UIImage</span><span style="font-size: 14px; color: rgb(70, 70, 70); font-family: Arial;">对象，然后再绘制到屏幕；</span></div></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="color: rgb(70, 70, 70); font-weight: bold;">14.使用正确的数据结构来存储数据。</span></div><div><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px; font-weight: bold;">4.M、V、C相互通讯规则你知道的有哪些？</span></div><div><span style="font-weight: bold;">MVC 是一种设计思想，一种框架模式，是一种把应用中所有类组织起来的策略，它把你的程序分为三块，分别是：</span></div><div><br/></div><div><span style="font-weight: bold;">M（Model）</span>：实际上考虑的是“什么”问题，你的程序本质上是什么，独立于 UI 工作。是程序中用于处理应用程序逻辑的部分，通常负责存取数据。</div><div><br/></div><div><span style="font-weight: bold;">C（Controller</span>）：控制你 Model 如何呈现在屏幕上，当它需要数据的时候就告诉 Model，你帮我获取某某数据；当它需要 UI 展示和更新的时候就告诉 View，你帮我生成一个 UI 显示某某数据，是 Model 和 View 沟通的桥梁。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">V（View）</span>：Controller 的手下，是 Controller 要使用的类，用于构建视图，通常是根据 Model 来创建视图的。</div><div><span style="font-weight: bold;">要了解 MVC 如何工作，首先需要了解这三个模块间如何通信。</span></div><div><span style="font-weight: bold;">MVC通信规则</span></div><div><img src="面试   腾讯一面_files/Image [1].jpg" type="image/jpeg" data-filename="Image.jpg"/><br/></div><div><span style="font-weight: bold;">Controller to Model</span></div><div><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">可以直接单向通信。Controller 需要将 Model 呈现给用户，因此需要知道模型的一切，还需要有同 Model 完全通信的能力，并且能任意使用 Model 的公共 API。</div><div><span style="font-weight: bold;">Controller to View</span></div><div>可以直接单向通信。Controller 通过 View 来布局用户界面。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">Model to View</span></div><div>永远不要直接通信。Model 是独立于 UI 的，并不需要和 View 直接通信，View 通过 Controller 获取 Model 数据。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">View to Controller</span></div><div>View 不能对 Controller 知道的太多，因此要通过间接的方式通信。</div><div><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">Target action。首先 Controller 会给自己留一个 target，再把配套的 action 交给 View 作为联系方式。那么 View 接收到某些变化时，View 就会发送 action 给 target 从而达到通知的目的。这里 View 只需要发送 action，并不需要知道 Controller 如何去执行方法。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">代理。有时候 View 没有足够的逻辑去判断用户操作是否符合规范，他会把判断这些问题的权力委托给其他对象，他只需获得答案就行了，并不会管是谁给的答案。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">DataSoure。View 没有拥有他们所显示数据的权力，View 只能向 Controller 请求数据进行显示，Controller 则获取 Model 的数据整理排版后提供给 View。</div><div>Model 访问 Controller</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">同样的 Model 是独立于 UI 存在的，因此无法直接与 Controller 通信，但是当 Model 本身信息发生了改变的时候，会通过下面的方式进行间接通信。</div><div><span style="font-weight: bold;">Notification &amp; KVO一种类似电台的方法，Model 信息改变时会广播消息给感兴趣的人 ，只要 Controller 接收到了这个广播的时候就会主动联系 Model，获取新的数据并提供给 View。</span></div><div><span style="font-weight: bold;">从上面的简单介绍中我们来简单概括一下 MVC 模式的优点。</span></div><div><span style="font-weight: bold;">1.低耦合性</span></div><div><span style="font-weight: bold;">2.有利于开发分工</span></div><div><span style="font-weight: bold;">3.有利于组件重用</span><span style="font-weight: bold;">4.可维护性</span></div><div><br/></div><div><span style="font-size: 24px; font-weight: bold;">5.NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div><span style="font-weight: bold;">1.不准</span></div><div><span style="font-weight: bold;">2.不准的原因如下：</span></div><div><br/></div><div>1、NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。</div><div><br/></div><div>2、模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。</div><div><br/></div><div>当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个ScrollView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到NSTimer不准的情况。</div><div><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">PS:DefaultMode 是 App 平时所处的状态，rackingRunLoopMode 是追踪 ScrollView 滑动时的状态。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div><span style="font-weight: bold;">方法一：</span></div><div><br/></div><div>1、在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中。避免被复杂运算操作或者UI界面刷新所干扰。</div><div><br/></div><div>self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(showTime) userInfo:nil repeats:YES];</div><div><br/></div><div>[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];</div><div><br/></div><div>2、在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果；</div><div><br/></div><div>- (void)timerMethod2 {</div><div><br/></div><div>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];</div><div><br/></div><div>[thread start];</div><div><br/></div><div>}</div><div><br/></div><div>- (void)newThread</div><div><br/></div><div>{</div><div><br/></div><div>@autoreleasepool</div><div><br/></div><div>{</div><div><br/></div><div>[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES];</div><div><br/></div><div>[[NSRunLoop currentRunLoop] run];</div><div><br/></div><div>}</div><div><br/></div><div>}</div><div><br/></div><div>总结：</div><div><br/></div><div>一开始的时候系统就为我们将主线程的main runloop隐式的启动了。</div><div><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">方法二：</span></div><div><span style="font-weight: bold;">使用示例</span></div><div><br/></div><div>使用mach内核级的函数可以使用mach_absolute_time()获取到CPU的tickcount的计数值，可以通过”mach_timebase_info”函数获取到纳秒级的精确度 。然后使用mach_wait_until(uint64_t deadline)函数，直到指定的时间之后，就可以执行指定任务了。</div><div><br/></div><div>关于数据结构mach_timebase_info的定义如下：</div><div><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">struct mach_timebase_info {uint32_t numer;uint32_t denom;};</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div>#include &lt;mach/mach.h&gt;</div><div>#include &lt;mach/mach_time.h&gt;</div><div><br/></div><div>static const uint64_t NANOS_PER_USEC = 1000ULL;</div><div>static const uint64_t NANOS_PER_MILLISEC = 1000ULL * NANOS_PER_USEC;</div><div>static const uint64_t NANOS_PER_SEC = 1000ULL * NANOS_PER_MILLISEC;</div><div><br/></div><div>static mach_timebase_info_data_t timebase_info;</div><div><br/></div><div>static uint64_t nanos_to_abs(uint64_t nanos) {</div><div>    return nanos * timebase_info.denom / timebase_info.numer;</div><div>}</div><div><br/></div><div>void example_mach_wait_until(int seconds)</div><div>{</div><div>    mach_timebase_info(&amp;timebase_info);</div><div>    uint64_t time_to_wait = nanos_to_abs(seconds * NANOS_PER_SEC);</div><div>    uint64_t now = mach_absolute_time();</div><div>    mach_wait_until(now + time_to_wait);</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">}</div><div><span style="font-weight: bold;">方法三：直接使用GCD替代！</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div><img src="面试   腾讯一面_files/Image.gif" type="image/gif" data-filename="Image.gif"/><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div><br/></div></span>
</div></body></html> 