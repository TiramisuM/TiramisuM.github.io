<html>
<head>
  <title>稀土掘金  (九) : JSPatch实现原理</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <meta name="application-data:corenote-hostUUID" content="C8940BC2-A53C-4B55-B59C-4779464BC778"/>
  <meta name="application-data:corenote-localUUID" content="327F6DCB-30F1-42B4-9788-6901ABA5FDCD"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1551"/>
<h1>稀土掘金  (九) : JSPatch实现原理</h1>

<div>
<span><div>在IOS开发领域，由于Apple严格的审核标准和低效率，IOS应用的发版速度极慢，稍微大型的app发版基本上都在一个月以上，所以代码热更新（HotfixPatch）对于IOS应用来说就显得尤其重要。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">现在业内基本上都在使用WaxPatch方案，由于Wax框架已经停止维护四五年了，所以waxPatch在使用过程中还是存在不少坑(比如参数转化过程中的问题，如果继承类没有实例化修改继承类的方法无效, wax_gc中对oc中instance的持有延迟释放...)。另外苹果对于Wax使用的态度也处于模糊状态，这也是一个潜在的使用风险。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">随着FaceBook开源React Native框架，利用JavaScriptCore.framework直接建立JavaScript（JS）和Objective-C(OC)之间的bridge成为可能，JSPatch也在这个时候应运而生。最开始是从唐巧的微信公众号推送上了解到，开始还以为是在React Native的基础上进行的封装，不过最近仔细研究了源代码，跟React Native半毛钱关系都没有，这里先对JSPatch的作者（不是唐巧，是Bang，</span><a href="http://blog.cnbang.net/" style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">博客地址</a><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">）赞一个。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">深入了解JSPatch之后，第一感觉是这个方案小巧，易懂，维护成本低，直接通过OC代码去调用runtime的API，作为一个IOS开发者，很快就能看明白，不用花大精力去了解学习lua。另外在建立JS和OC的Bridge时，作者很巧妙的利用JS和OC两种语言的消息转发机制做了很优雅的实现，稍显不足的是JSPatch只能支持ios7及以上。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">由于现在公司的部分应用还在支持ios6，完全取代Wax也不现实，但是一些新上应用已经直接开始支持ios7。个人觉得ios6和ios7的界面风格差别较大，相信应用最低支持版本会很快升级到ios7. 还考虑到JSPatch的成熟度不够，所以决定把JSPatch和WaxPatch结合在一起，相互补充进行使用。下面给大家说一些学习使用体会。</span></div><h2>JSPatch和WaxPatch对比</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">关于JSPatch对比WaxPatch的优势，下面摘抄一下JSPatch作者的话：</span></div><ul><li><a href="http://blog.cnbang.net/works/2767/">来源: JSPatch – 动态更新iOS APP</a></li></ul><h4>方案对比</h4><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">目前已经有一些方案可以实现动态打补丁，例如WaxPatch，可以用Lua调用OC方法，相对于WaxPatch，JSPatch的优势：</span></div><ul><li>1.<span style="font-weight: bold;">JS语言:</span> JS比Lua在应用开发领域有更广泛的应用，目前前端开发和终端开发有融合的趋势，作为扩展的脚本语言，JS是不二之选。</li><li>2.<span style="font-weight: bold;">符合Apple规则:</span> JSPatch更符合Apple的规则。<a href="https://developer.apple.com/programs/terms/ios/standard/ios_program_standard_agreement_20140909.pdf">iOS Developer Program License Agreement</a>里3.3.2提到不可动态下发可执行代码，但通过苹果JavaScriptCore.framework或WebKit执行的代码除外，JS正是通过JavaScriptCore.framework执行的。</li><li>3.<span style="font-weight: bold;">小巧:</span> 使用系统内置的JavaScriptCore.framework，无需内嵌脚本引擎，体积小巧。</li><li>4.<span style="font-weight: bold;">支持block:</span> wax在几年前就停止了开发和维护，不支持Objective-C里block跟Lua程序的互传，虽然一些第三方已经实现block，但使用时参数上也有比较多的限制。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">JSPatch的劣势：</span></div><ul><li>相对于WaxPatch，JSPatch劣势在于不支持iOS6，因为需要引入JavaScriptCore.framework。另外目前内存的使用上会高于wax，持续改进中。</li></ul><h2>JSPatch的实现原理理解</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">JSPatch的实现原理作者的博文已经很详细的介绍了，我这里就不多说了，贴一下学习之处：</span></div><ul><li>JSPatch实现原理详解 <a href="http://blog.cnbang.net/tech/2808/">http://blog.cnbang.net/tech/2808/</a></li><li>JSPatch Git源码和使用说明 <a href="https://github.com/bang590/JSPatch">https://github.com/bang590/JSPatch</a></li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">看实现原理详解的时候对照着源码看，比较好理解，我在这里说一下我对JSPatch的学习和理解：</span></div><h4>（1）OC的动态语言特性</h4><div>不管是WaxPatch框架还是JSPatch的方案，其根本原理都是利用OC的动态语言特性去动态修改类的方法实现。</div><div>OC的动态语言特性是在runtime system(全部用C实现，Apple维护了一份开源代码)上实现的，面向对象的Class和instance机制都是基于消息机制。我们平时认为的[object method]，正确的理解应该是[receiver sendMsg], 所有的消息发送会在编译阶段编译为runtime c函数的调用：_obj_sendMsg(id, SEL).</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">详细介绍参考博文：</span></div><ul><li><a href="http://justsee.iteye.com/blog/2163777">Objective-C Runtime详细介绍</a></li><li><a href="http://www.opensource.apple.com/source/objc4/">Objective-C Runtime源码_Apple</a></li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">runtime提供了一些运行时的API</span></div><ul><li>反射类和选择器</li></ul><pre><code>    Class class = <span>NSClassFromString(<span>&quot;UIViewController&quot;);<br/>    SEL selector = <span>NSSelectorFromString(&quot;viewDidLoad&quot;);</span></span></span></code></pre><ul><li>为某个类新增或者替换方法选择器（SEL）的实现（IMP）</li></ul><pre><code>    <span>BOOL <span>class_addMethod(<span>Class cls, SEL name, IMP imp, <span>const <span>char *types);<br/>    <span>IMP <span>class_replaceMethod(<span>Class cls, SEL name, IMP imp, <span>const char *types);</span></span></span></span></span></span></span></span></span></code></pre><ul><li>在runtime中动态注册类</li></ul><pre><code>    Class superCls = NSClassFromString<span>(<span>superClassName)<span>;<br/>    cls = objc_allocateClassPair<span>(<span>superCls, className.UTF8String, <span>0)<span>;<br/>    objc_registerClassPair<span>(<span>cls);</span></span></span></span></span></span></span></span></span></code></pre><h4>（2）JS如何调用OC</h4><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">在JS运行环境中，需要解决两个问题，一个是OC类对象（objc_class）的获取，另一个就是使用对象提供的接口方法。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">对于第一个问题，JSPatch在实现中是通过Require调用在JS环境下创建一个class同名对象（js形式），当向OC发送alloc接收消息之后，会将OC环境中创建的对象地址保存到这个这个js同名对象中，js本身并不完成任何对象的初始化。关于JS持有OC对象的引用，其回收的解释在JSPatch作者的博文中有介绍，没有具体测试。详见JSPatch.js代码：</span></div><pre><code>    <span>请求OC类对象<br/>    <span>UIView = require(<span>&quot;UIView&quot;);<br/><br/>    <span>缓存JS class同名对象<br/>    <span>var _require = function(clsName) {<br/>        <span>if (!global[clsName]) {<br/>          global[clsName] = {<br/>            __isCls: <span>1,<br/>            __clsName: clsName<br/>          }<br/>        } <br/>        <span>return global[clsName]<br/>      }<br/><br/>    <span>调用class方法，返回OC实例化对象进行封装<br/>    <span>var ret = instance ? _OC_callI(instance, selectorName, args, isSuper):<br/>                         _OC_callC(clsName, selectorName, args)<br/><br/>    <span>OC创建后返回对象<br/>    <span>return@{@<span>&quot;__clsName&quot;: <span>NSStringFromClass([obj <span>class]), <span>@&quot;<span>__obj&quot;: obj};<br/><br/><br/>    <span>JS中解析OC对象<br/>    <span>return _formatOCToJS(ret)<br/><br/>    <span>_formatOCToJS<br/>    <span>if (obj instanceof <span>Object) {<br/>        <span>var ret = {}<br/>        <span>for (<span>var key in obj) {<br/>          ret[key] = _formatOCToJS(obj[key])<br/>        }<br/>        return ret<br/>     }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre><div>对于第二个问题，JSPatch在JS环境中通过中心转发方式，所有OC方法的调用均是通过新增Object（js）原型方法_c(methodName)完成调用，在通过JavaScriptCore执行JS脚本之前，先将所有的方法调用字符替换</div><div>_c('method')的方式； 在_c函数中通过JSContex建立的桥接函数传入参数和返回参数即完成了调用；</div><pre><code>    <span>字符替换<br/>    <span>static <span>NSString *_regexStr = <span>@&quot;\\.\\s*(\\w+)\\s*\\(&quot;;<br/>    <span>static <span>NSString *_replaceStr = <span>@&quot;.__c(\&quot;$1\&quot;)(&quot;;<br/><br/>    <span>NSString *formatedScript = [<span>NSString stringWithFormat:<span>@&quot;try{@}catch(e){_OC_catch(e.message, e.stack)}&quot;, [_regex stringByReplacingMatchesInString:script options:<span>0 range:<span>NSMakeRange(<span>0, script<span>.length) withTemplate:_replaceStr]];<br/><br/><br/>    <span>__c()向OC转发调用参数<br/>    Object<span>.prototype<span>.__c = function(methodName) {<br/><br/>        ...<br/><br/>        <span>return function(){<br/>          var args = Array<span>.prototype<span>.slice<span>.call(arguments)<br/>          <span>return _methodFunc(<span>self<span>.__obj, <span>self<span>.__clsName, methodName, args, <span>self<span>.__isSuper)<br/>        }<br/>     }<br/><br/>    <span>_methodFunc调用桥接函数<br/>    var _methodFunc = function(instance, clsName, methodName, args, isSuper) {<br/><br/>        ...<br/><br/>        var ret = instance ? _OC_callI(instance, selectorName, args, isSuper):<br/>                             _OC_callC(clsName, selectorName, args)<br/><br/>        <span>return _formatOCToJS(ret)<br/>     }<br/><br/><br/>    <span>OC中的桥接函数，JS和OC的桥接函数都是通过这样定义<br/>    context[<span>@&quot;_OC_callI&quot;] = ^<span>id(JSValue *obj, <span>NSString *selectorName, JSValue *arguments, <span>BOOL isSuper) {<br/>        <span>return callSelector(<span>nil, selectorName, arguments, obj, isSuper);<br/>    };<br/><br/>    context[<span>@&quot;_OC_callC&quot;] = ^<span>id(<span>NSString *className, <span>NSString *selectorName, JSValue *arguments) {<br/>        <span>return callSelector(className, selectorName, arguments, <span>nil, NO);<br/>    };</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre><h4>（3）JS如何替换OC方法</h4><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">JSPatch的主要作用还是通过脚本修复一些线上bug，希望能够达到替换OC方法的目标。JSPatch的实现巧妙之处在于：利用了OC的</span><a href="http://bugly.qq.com/blog/?p=64" style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">消息转发机制</a><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">。</span></div><ul><li>1:替换原有selector的IMP实现为一个空的IMP实现，这样当objc_class接受到消息之后，就会进行消息转发, 另外需要将selector的初始实现进行保存；</li></ul><pre><code>    <span>selector指向空实现<br/>    IMP msgForwardIMP = getEmptyMsgForwardIMP(typeDescription, methodSignature);<br/>    class_replaceMethod(cls, selector, msgForwardIMP, typeDescription);<br/><br/><br/>    <span>保存原有实现，这里进行了修改，增加了恢复现场的支持<br/>    <span>NSString *originalSelectorName = [<span>NSString stringWithFormat:<span>@&quot;ORIG@&quot;, selectorName];<br/>    SEL originalSelector = <span>NSSelectorFromString(originalSelectorName);<br/>    <span>if(class_respondsToSelector(cls, selector)) {<br/>        <span>if(!class_respondsToSelector(cls, originalSelector)){<br/>            class_addMethod(cls, originalSelector, originalImp, typeDescription);<br/>        } else {<br/>            class_replaceMethod(cls, originalSelector, originalImp, typeDescription);<br/>        }<br/>    }</span></span></span></span></span></span></span></span></code></pre><ul><li>2:将替换的JS方法构造一个JPSelector及其IMP实现（根据返回参数构造），添加到当前class中，并通过cls＋selecotr全局缓存JS方法（全局缓存并没有多大用途，但是对于后面恢复现场比较有用）;</li></ul><pre><code>    <span>if (!_JSOverideMethods[clsName][JPSelectorName]) {<br/>        _initJPOverideMethods(clsName);<br/>        _JSOverideMethods[clsName][JPSelectorName] = <span>function;<br/>        <span>const char *returnType = [methodSignature methodReturnType];<br/>        IMP JPImplementation = <span>NULL;<br/><br/>        <span>根据返回类型构造<br/>        <span>switch (returnType[<span>0]){<br/>         ...<br/>        }<br/><br/>        <span>if(!class_respondsToSelector(cls, JPSelector)){<br/>            class_addMethod(cls, JPSelector, JPImplementation, typeDescription);<br/>        } else {<br/>            class_replaceMethod(cls, JPSelector, JPImplementation,typeDescription);<br/>        }<br/>    }</span></span></span></span></span></span></span></span></code></pre><ul><li>3:然后改写每个替换方法类的forwadInvocation的实现进行拦截，如果拦截到的Invocation的selctor转化成JPSelector能够响应，说明是一个替换方法，则从Invocation中取参数后调用JPSelector的IMP；</li></ul><pre><code>    <span>static <span>void JPForwardInvocation(<span>id slf, SEL selector, <span>NSInvocation *invocation)<br/>    {<br/>        <span>NSMethodSignature *methodSignature = [invocation methodSignature];<br/>        <span>NSInteger numberOfArguments = [methodSignature numberOfArguments];<br/><br/>        <span>NSString *selectorName = <span>NSStringFromSelector(invocation<span>.selector);<br/>        <span>NSString *JPSelectorName = [<span>NSString stringWithFormat:<span>@&quot;_JP@&quot;, selectorName];<br/>        SEL JPSelector = <span>NSSelectorFromString(JPSelectorName);<br/><br/>        <span>if (!class_respondsToSelector(object_getClass(slf), JPSelector)) {<br/>            ...<br/>        }<br/><br/>        <span>NSMutableArray *argList = [[<span>NSMutableArray alloc] init];<br/>        [argList addObject:slf];<br/><br/>        <span>for (<span>NSUInteger i = <span>2; i &lt; numberOfArguments; i++) {<br/>            ...<br/>        }<br/><br/>        <span>获取参数之后invoke JPSector调用JSFunction的实现<br/>        <span>@synchronized(_context) {<br/>            _T<span>MPInvocationArguments = formatOCToJSList(argList);<br/><br/>            [invocation setSelector:JPSelector];<br/>            [invocation invoke];<br/><br/>            _T<span>MPInvocationArguments = nil;<br/>        }<br/>    }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre><h2>Patch现场复原的补充</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">Patch现场恢复的功能主要用于连续更新脚本的应用场景。由于IOS的App应用按Home键或者被电话中断的时候，应用实际上是首先进入到后台运行阶段（applicationWillResignActive），当我们下次再次使用App的时候，如果后台应用没有被终止（applicationWillTerminate），那么App不会走appliation:didFinishLaunchingWithOptions方法，而是会走（applicationWillEnterForeground）。 对于这种场景如果我们连续更新线上脚本，那么第二次脚本更新则无法保留最开始的方法实现，另外恢复现场功能也有助于我们撤销线上脚本能够恢复应用的本身代码功能。</span></div><h4>JSPatch的现场恢复</h4><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">本文在JSPatch基础上添加了现场恢复功能；源码地址参考：</span></div><ul><li>增加现场恢复的JSPatchDemo:<br/><a href="https://github.com/philonpang/JSPatch.git">https://github.com/philonpang/JSPatch.git</a></li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">说明如下：</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">（1）在JPEngine.h 中添加了两个启动和结束的调用函数如下：</span></div><pre><code>    <span>void <span>js_start(<span>NSString* initScript);<br/>    <span>void <span>js_end();</span></span></span></span></span></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">(2) JPEngine.m 中调用函数的实现以及恢复现场对部分代码的修改：主要是利用了替换方法和新增方法的cache（_JSOverideMethods, 主要是这个）</span></div><pre><code>    <span>处理替换方法,selector指回最初的IMP，JPSelector和ORIGSelector都指向未实现IMP<br/>     <span>if([JPSelectorName hasPrefix:<span>@&quot;_JP&quot;]){<br/>         <span>if (class_getMethodImplementation(cls, <span>@selector(forwardInvocation:)) == (IMP)JPForwardInvocation) {<br/>             SEL ORIGforwardSelector = <span>@selector(ORIGforwardInvocation:);<br/>             IMP ORIGforwardImp = class_getMethodImplementation(cls, ORIGforwardSelector);<br/>             class_replaceMethod(cls, <span>@selector(forwardInvocation:), ORIGforwardImp, <span>&quot;v@:@&quot;);<br/>             class_replaceMethod(cls, ORIGforwardSelector, _objc_msgForward, <span>&quot;v@:@&quot;);<br/>         }<br/><br/><br/>         <span>NSString *selectorName = [JPSelectorName stringByReplacingOccurrencesOfString:<span>@&quot;_JP&quot; withString:<span>@&quot;&quot;];<br/>         <span>NSString *ORIGSelectorName = [JPSelectorName stringByReplacingOccurrencesOfString:<span>@&quot;_JP&quot; withString:<span>@&quot;ORIG&quot;];<br/><br/>         SEL JPSelector = <span>NSSelectorFromString(JPSelectorName);<br/>         SEL selector = <span>NSSelectorFromString(selectorName);<br/>         SEL ORIGSelector = <span>NSSelectorFromString(ORIGSelectorName);<br/><br/>         <span>if(class_respondsToSelector(cls, ORIGSelector) &amp;&amp;<br/>            class_respondsToSelector(cls, selector) &amp;&amp;<br/>            class_respondsToSelector(cls, JPSelector)){<br/>             <span>NSMethodSignature *methodSignature = [cls instanceMethodSignatureForSelector:ORIGSelector];<br/>             Method method = class_getInstanceMethod(cls, ORIGSelector);<br/>             <span>char *typeDescription = (<span>char *)method_getTypeEncoding(method);<br/>             IMP forwardEmptyIMP = getEmptyMsgForwardIMP(typeDescription, methodSignature);<br/>             IMP ORIGSelectorImp = class_getMethodImplementation(cls, ORIGSelector);<br/><br/>             class_replaceMethod(cls, selector, ORIGSelectorImp, typeDescription);<br/>             class_replaceMethod(cls, JPSelector, forwardEmptyIMP, typeDescription);<br/>             class_replaceMethod(cls, ORIGSelector, forwardEmptyIMP, typeDescription);<br/>         }<br/>     }<br/><br/>     <span>处理添加的新方法<br/>     <span>else {<br/>         isClsNew = <span>YES;<br/>         SEL JPSelector = <span>NSSelectorFromString(JPSelectorName);<br/>         <span>if(class_respondsToSelector(cls, JPSelector)){<br/>             <span>NSMethodSignature *methodSignature = [cls instanceMethodSignatureForSelector:JPSelector];<br/>             Method method = class_getInstanceMethod(cls, JPSelector);<br/>             <span>char *typeDescription = (char *)method_getTypeEncoding(method);<br/>             IMP forwardEmptyIMP = getEmptyMsgForwardIMP(typeDescription, methodSignature);<br/><br/>             class_replaceMethod(cls, JPSelector, forwardEmptyIMP, typeDescription);<br/>         }<br/>     }</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre><h2>HotfixPatch的那些坑</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">WaxPatch之前被一些同事抱怨有不少坑，JSPatch在使用过程中也会遇到不少坑，所以虽然这两个框架现在虽然都能够做到新增可执行代码，但是将其应用到开发功能组件还不太可取。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">比如说我在第一次使用JSPatch遇到了一个坑：（后面想单写一个博客收集一下我们团队使用Patch遇到的坑～～）</span></div><ul><li>在JS脚本改写派生类中未实现的继承类的 optional protocol方法时，tableView reload的时候不会调用JS的补丁方法，但是在tableView中显式调用可以调用替换的selector方法；另外如果在派生类中重写这个protocol方法，则可以调起；</li><li>...</li></ul><div><br/></div><div><br/></div><div><br/></div><div style="font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%; font-weight: bold;">笔记整理：Edison</span></div><div style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em; border-width: 100%; font-weight: bold; color: rgb(79, 129, 189); unicode-bidi: embed;">联系方式：QQ：277593 （笔记意见建议可加此Q，专人更新此笔记）；</span></div><div style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em; border-width: 100%; color: rgb(79, 129, 189); unicode-bidi: embed;"> </span></div><div style="font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%; font-weight: bold;">注：小道途径获取到的笔记，无法自动更新，请谅解！(笔记平均每月更新一次，祝各位都能拿到心仪的offer)</span><span style="direction: ltr; font-family: Menlo; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%;"> </span></div><div><br/></div></span>
</div></body></html> 