<html>
<head>
  <title>面试  : 腾讯二面</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <meta name="application-data:corenote-hostUUID" content="C8940BC2-A53C-4B55-B59C-4779464BC778"/>
  <meta name="application-data:corenote-localUUID" content="9C22A8B0-6E7A-4259-A6F2-AB944BCAEBFB"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="962"/>
<h1>面试  : 腾讯二面</h1>

<div><span><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><div><span style="font-size: 18px; font-weight: bold;">前言：先自己尝试去回答，回答不了再看参考答案，你才能学的更多！</span></div></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">1.编译过程做了哪些事情；</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">2.字典大致实现原理；</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">3.block和函数指针的理解；</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">4.一般开始做一个项目，你的架构是如何思考的？</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">5.你了解的UIKit结构？</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><div><hr/><hr/><br/></div></div></blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">1.编译过程做了哪些事情？</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">1.C++,Objective C都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在CPU上执行，所以执行效率较高。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">iOS开发目前的常用语言是：Objective和Swift。二者都是编译语言，换句话说都是需要编译才能执行的。二者的编译都是依赖于Clang + LLVM. OC和Swift因为原理上大同小异，知道一个即可！</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">iOS编译</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">不管是OC还是Swift，都是采用Clang作为编译器前端，LLVM(Low level vritual machine)作为编译器后端。所以简单的编译过程如图</div><div style="max-width: 700px; max-height: 500px;"><div><img src="面试   腾讯二面_files/Image.jpg" type="image/jpeg" data-filename="Image.jpg"/><br/></div></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">编译器前端</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">编译器前端的任务是进行：语法分析，语义分析，生成中间代码(intermediate representation )。在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。</div><div style="max-width: 700px; max-height: 590px;"><div><img src="面试   腾讯二面_files/Image [1].jpg" type="image/jpeg" data-filename="Image.jpg"/><br/></div></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">编译器后端</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化。iOS的编译过程，后端的处理如下</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">LVVM优化器会进行BitCode的生成，链接期优化等等</span></div><div style="max-width: 700px; max-height: 414px;"><div><img src="面试   腾讯二面_files/Image [2].jpg" type="image/jpeg" data-filename="Image.jpg"/><br/></div></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">LLVM机器码生成器会针对不同的架构，比如arm64等生成不同的机器码</span>。</div><div style="max-width: 700px; max-height: 544px;"><div><img src="面试   腾讯二面_files/Image [3].jpg" type="image/jpeg" data-filename="Image.jpg"/><br/></div></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">执行一次XCode build的流程</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">当你在XCode中，选择build的时候（快捷键command+B），会执行如下过程</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">编译信息写入辅助文件，创建编译后的文件架构(name.app)</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">处理文件打包信息，例如在debug环境下</div><div style="max-width: 700px; max-height: 242px;"><div><img src="面试   腾讯二面_files/Image [4].jpg" type="image/jpeg" data-filename="Image.jpg"/><br/></div></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">执行CocoaPod编译前脚本</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">例如对于使用CocoaPod的工程会执行CheckPods Manifest.lock</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">编译各个.m文件，使用CompileC和clang命令。</div><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">编译各个.m文件，使用CompileC和clang命令。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">1.CompileC ClassName.o ClassName.m normal x86_64 objective-c <a href="http://com.apple.compilers.llvm.clang.1_0.compiler">com.apple.compilers.llvm.clang.1_0.compiler</a></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">2.export LANG=en_US.US-ASCII</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">3.export PATH=&quot;...&quot;</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">4.clang-x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc...</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">-Wno-missing-field-initializers ... -DDEBUG=1 ... -isysroot</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">iPhoneSimulator10.1.sdk -fasm-blocks ... -I 上文提到的文件 -F 所需要的Framework-iquote 所需要的Framework ... -c ClassName.c -o ClassName.o</div></blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">通过这个编译的命令，我们可以看到</span></div><div style="max-width: 700px; max-height: 530px;"><div><img src="面试   腾讯二面_files/Image [5].jpg" type="image/jpeg" data-filename="Image.jpg"/><br/></div></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">2.字典大致实现原理；</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">一：字典原理</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">NSDictionary（字典）是使用hash表来实现key和value之间的映射和存储的</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">方法：- (void)setObject:(id)anObject forKey:(id)aKey;</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">Objective-C中的字典NSDictionary底层其实是一个哈希表</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">二：哈希原理</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">哈希概念</span>:哈希表的本质是一个数组，数组中每一个元素称为一个箱子(bin)，箱子中存放的是键值对。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">三：哈希存储过程</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">1.根据 key 计算出它的哈希值 h。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">2.假设箱子的个数为 n，那么这个键值对应该放在第 (h % n) 个箱子中。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">3.如果该箱子中已经有了键值对，就使用开放寻址法或者拉链法解决冲突。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">在使用拉链法解决哈希冲突时，每个箱子其实是一个链表，属于同一个箱子的所有键值对都会排列在链表中。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">哈希表还有一个重要的属性</span>: 负载因子(load factor)，它用来衡量哈希表的<span style="font-weight: bold;">空/满</span>程度，一定程度上也可以体现查询的效率，计算公式为:</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">负载因子 = 总键值对数 / 箱子个数</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">负载因子越大，意味着哈希表越满，越容易导致冲突，性能也就越低。因此，一般来说，当负载因子大于某个常数(可能是 1，或者 0.75 等)时，哈希表将自动扩容。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">哈希表在自动扩容时，一般会创建两倍于原来个数的箱子，因此即使 key 的哈希值不变，对箱子个数取余的结果也会发生改变，因此所有键值对的存放位置都有可能发生改变，这个过程也称为重哈希(rehash)。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">哈希表的扩容并不总是能够有效解决负载因子过大的问题。假设所有 key 的哈希值都一样，那么即使扩容以后他们的位置也不会变化。虽然负载因子会降低，但实际存储在每个箱子中的链表长度并不发生改变，因此也就不能提高哈希表的查询性能。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">基于以上总结，细心的朋友可能会发现哈希表的两个问题:</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">1.如果哈希表中本来箱子就比较多，扩容时需要重新哈希并移动数据，性能影响较大。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">2.如果哈希函数设计不合理，哈希表在极端情况下会变成线性表，性能极低。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">3.block和函数指针的理解；</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">相似点：</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">函数指针和Block都可以实现回调的操作，声明上也很相似，实现上都可以看成是一个代码片段。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">函数指针类型和Block类型都可以作为变量和函数参数的类型。（typedef定义别名之后，这个别名就是一个类型）</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">不同点：</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">函数指针只能指向预先定义好的函数代码块（可以是其他文件里面定义，通过函数参数动态传入的），函数地址是在编译链接时就已经确定好的。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">Block本质是Objective-C对象，是NSObject的子类，可以接收消息。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">函数里面只能访问全局变量，而Block代码块不光能访问全局变量，还拥有当前栈内存和堆内存变量的可读性（当然通过__block访问指示符修饰的局部变量还可以在block代码块里面进行修改）。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">从内存的角度看，函数指针只不过是指向代码区的一段可执行代码，而block实际上是程序运行过程中在栈内存动态创建的对象，可以向其发送copy消息将block对象拷贝到堆内存，以延长其生命周期。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">4.一般开始做一个项目，你的架构是如何思考的？</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">参考文章一：<a href="https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html" style="font-weight: bold;">https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html</a></span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">参考文章二：<a href="https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html" style="font-weight: bold;">https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html</a></span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这种题大多是看个人项目经验，以上有两篇不错的参考！</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;">5.你了解的UIKit结构？</span></div><div style="max-width: 700px; max-height: 901px;"><div><img src="面试   腾讯二面_files/Image [6].jpg" type="image/jpeg" data-filename="Image.jpg"/><br/></div></div><div><span style="font-weight: bold;">这题应该是在你回答的基础之上，进行二次提问，主要还是看你的基础！</span></div></span>
</div></body></html> 