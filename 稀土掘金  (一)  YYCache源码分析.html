<html>
<head>
  <title>稀土掘金  (一) : YYCache源码分析</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <meta name="application-data:corenote-hostUUID" content="C8940BC2-A53C-4B55-B59C-4779464BC778"/>
  <meta name="application-data:corenote-localUUID" content="BCFBC22F-4C84-422F-BB39-7C58397500D2"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1220"/>
<h1>稀土掘金  (一) : YYCache源码分析</h1>

<div>
<span><div>YYCache是用于Objective-C中用于缓存的第三方框架。此文主要用来讲解该框架的实现细节，性能分析、设计思路等。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="margin-top: 1em; margin-bottom: 1em; color: rgb(0, 176, 80); font-weight: bold;">文件结构</span></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><div><img src="稀土掘金  (一)  YYCache源码分析_files/Image.png" type="image/png" data-filename="Image.png"/><br/></div></div><ul style="list-style-type: disc;"><li>YYCache：同时实现内存缓存和磁盘缓存且是线程安全的</li><li>YYMemoryCache：实现内存缓存，所有的API都是线程安全的，与其他缓存方式比较不同的是内部利用LRU淘汰算法（后面会介绍）来提高性能</li><li>YYDiskCache：实现磁盘缓存，所有的API都是线程安全的，内部也采用了LRU淘汰算法，主要SQLite和文件存储两种方式</li><li>YYKVStorage：实现磁盘存储，不推荐直接使用该类，该类不是线程安全的</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="margin-top: 1em; margin-bottom: 1em; color: rgb(0, 176, 80); font-weight: bold;">LRU</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">LRU(Least recently used，最近最少使用)算法，根据访问的历史记录来对数据进行淘汰</span></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><div><img src="稀土掘金  (一)  YYCache源码分析_files/Image [1].png" type="image/png" data-filename="Image.png"/><br/></div></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">简单的来说3点：</span></div><ul style="list-style-type: disc;"><li>有新数据加入时添加到链表的头部</li><li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li><li>当链表满的时候，将链表尾部的数据丢弃</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="margin-top: 1em; margin-bottom: 1em; font-weight: bold;">在YYMemoryCache中使用来双向链表和NSDictionary实现了LRU淘汰算法，后面会介绍</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="margin-top: 1em; margin-bottom: 1em; color: rgb(0, 176, 80); font-weight: bold;">关于锁</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">YYCache 使用到两种锁</span></div><ul style="list-style-type: disc;"><li>OSSpinLock ：自旋锁，上一篇博客也提及到<a href="http://iipanda.com/2016/06/21/YYKit-pthread/">pthread_mutex</a></li><li>dispatch_semaphore：信号量，当信号量为1的时候充当锁来用</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">内存缓存用的pthread_mutex：由于pthread_mutex相当于do while忙等，等待时会消耗大量的CPU资源</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">磁盘缓存使用的dispatch_semaphore：优势在于等待时不会消耗CPU资源</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">简单的科普就到这，现在来开始源码的探索</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="margin-top: 1em; margin-bottom: 1em; color: rgb(0, 176, 80); font-weight: bold;">_YYLinkedMap</span></div><div><span style="color: rgb(4, 51, 255);">@interface _YYLinkedMapNode : NSObject {</span></div><div><span style="color: rgb(4, 51, 255);">    @package</span></div><div><span style="color: rgb(4, 51, 255);">    __unsafe_unretained _YYLinkedMapNode *_prev; retained by dic</span></div><div><span style="color: rgb(4, 51, 255);">    __unsafe_unretained _YYLinkedMapNode *_next; retained by dic</span></div><div><span style="color: rgb(4, 51, 255);">    id _key;</span></div><div><span style="color: rgb(4, 51, 255);">    id _value;</span></div><div><span style="color: rgb(4, 51, 255);">    NSUInteger _cost;</span></div><div><span style="color: rgb(4, 51, 255);">    NSTimeInterval _time;</span></div><div><span style="color: rgb(4, 51, 255);">}</span></div><div><span style="color: rgb(4, 51, 255);">@end</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="margin-top: 1em; margin-bottom: 1em; font-weight: bold;">_YYLinkedMapNode：链表的节点</span></div><ul style="list-style-type: disc;"><li>_prev、_next：分别表示指向上一个节点、下一个节点</li><li>_key：缓存的key</li><li>_value：缓存对象</li><li>_cost：内存消耗</li><li>_time：缓存时间</li></ul><div><span style="color: rgb(4, 51, 255);">@interface _YYLinkedMap : NSObject {</span></div><div><span style="color: rgb(4, 51, 255);">    @package</span></div><div><span style="color: rgb(4, 51, 255);">    CFMutableDictionaryRef _dic; do not set object directly</span></div><div><span style="color: rgb(4, 51, 255);">    NSUInteger _totalCost;</span></div><div><span style="color: rgb(4, 51, 255);">    NSUInteger _totalCount;</span></div><div><span style="color: rgb(4, 51, 255);">    _YYLinkedMapNode *_head;  MRU（最近最常使用算法）, do not change it directly</span></div><div><span style="color: rgb(4, 51, 255);">    _YYLinkedMapNode *_tail;  LRU（最近最少使用算法-清除较不常使用数据）, do not change it directly</span></div><div><span style="color: rgb(4, 51, 255);">    BOOL _releaseOnMainThread;</span></div><div><span style="color: rgb(4, 51, 255);">    BOOL _releaseAsynchronously;</span></div><div><span style="color: rgb(4, 51, 255);">}</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="margin-top: 1em; margin-bottom: 1em; font-weight: bold;">_YYLinkedMap：链表</span></div><ul style="list-style-type: disc;"><li>_dic：用来保存节点</li><li>_totalCost：总缓存开销</li><li>_head、_tail：头节点、尾节点</li><li>_releaseOnMainThread：是否在主线程释放_YYLinkedMapNode</li><li>_releaseAsynchronously：是否异步释放_YYLinkedMapNode</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="margin-top: 1em; margin-bottom: 1em; font-weight: bold;">双向链表</span></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><div><img src="稀土掘金  (一)  YYCache源码分析_files/Image [2].png" type="image/png" data-filename="Image.png"/><br/></div></div><ul style="list-style-type: disc;"><li>插入节点到头部</li><li>将除两边的节点移到头部</li><li>移除除两边的节点</li><li>移除尾部节点</li><li>移除所有节点</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">看下移除所有节点的代码：</span></div><div><span style="color: rgb(4, 51, 255);">- (void)removeAll {</span></div><div><span style="color: rgb(4, 51, 255);">    _totalCost = 0;</span></div><div><span style="color: rgb(4, 51, 255);">    _totalCount = 0;</span></div><div><span style="color: rgb(4, 51, 255);">    _head = nil;</span></div><div><span style="color: rgb(4, 51, 255);">    _tail = nil;</span></div><div><span style="color: rgb(4, 51, 255);">    if (CFDictionaryGetCount(_dic) &gt; 0) {</span></div><div><span style="color: rgb(4, 51, 255);">        CFMutableDictionaryRef holder = _dic;</span></div><div><span style="color: rgb(4, 51, 255);">        _dic = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span></div><div><span style="color: rgb(4, 51, 255);">        if (_releaseAsynchronously) {</span></div><div><span style="color: rgb(4, 51, 255);">            dispatch_queue_t queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span></div><div><span style="color: rgb(4, 51, 255);">            dispatch_async(queue, ^{</span></div><div><span style="color: rgb(4, 51, 255);">                CFRelease(holder);  hold and release in specified queue</span></div><div><span style="color: rgb(4, 51, 255);">            });</span></div><div><span style="color: rgb(4, 51, 255);">        } else if (_releaseOnMainThread &amp;&amp; !pthread_main_np()) {</span></div><div><span style="color: rgb(4, 51, 255);">            dispatch_async(dispatch_get_main_queue(), ^{</span></div><div><span style="color: rgb(4, 51, 255);">                CFRelease(holder);  hold and release in specified queue</span></div><div><span style="color: rgb(4, 51, 255);">            });</span></div><div><span style="color: rgb(4, 51, 255);">        } else {</span></div><div><span style="color: rgb(4, 51, 255);">            CFRelease(holder);</span></div><div><span style="color: rgb(4, 51, 255);">        }</span></div><div><span style="color: rgb(4, 51, 255);">    }</span></div><div><span style="color: rgb(4, 51, 255);">}</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这边通过双向链表来对数据进行操作，和NSDictionary实现了LRU淘汰算法。时间复杂度0（1），5种操作基本上都是对头尾节点和链表节点的上一个节点和下一个节点进行操作，耐心看还是能简单的，这边就不分析了</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="margin-top: 1em; margin-bottom: 1em; color: rgb(0, 176, 80); font-weight: bold;">YYMemoryCache</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这边介绍两个主要的操作：添加缓存，查找缓存</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="margin-top: 1em; margin-bottom: 1em; font-weight: bold;">添加缓存</span></div><div><span style="color: rgb(4, 51, 255);">- (void)setObject:(id)object forKey:(id)key withCost:(NSUInteger)cost {</span></div><div><span style="color: rgb(4, 51, 255);">    if (!key) return;</span></div><div><span style="color: rgb(4, 51, 255);">    if (!object) {</span></div><div><span style="color: rgb(4, 51, 255);">        缓存对象为nil，直接移除</span></div><div><span style="color: rgb(4, 51, 255);">        [self removeObjectForKey:key];</span></div><div><span style="color: rgb(4, 51, 255);">        return;</span></div><div><span style="color: rgb(4, 51, 255);">    }</span></div><div><span style="color: rgb(4, 51, 255);">    为了保证线程安全，数据操作前进行加锁</span></div><div><span style="color: rgb(4, 51, 255);">    pthread_mutex_lock(&amp;_lock);</span></div><div><span style="color: rgb(4, 51, 255);">    查找缓存</span></div><div><span style="color: rgb(4, 51, 255);">    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key));</span></div><div><span style="color: rgb(4, 51, 255);">    当前时间</span></div><div><span style="color: rgb(4, 51, 255);">    NSTimeInterval now = CACurrentMediaTime();</span></div><div><span style="color: rgb(4, 51, 255);">    if (node) {</span></div><div><span style="color: rgb(4, 51, 255);">        缓存对象已存在，更新数据，并移到栈顶</span></div><div><span style="color: rgb(4, 51, 255);">        _lru-&gt;_totalCost -= node-&gt;_cost;</span></div><div><span style="color: rgb(4, 51, 255);">        _lru-&gt;_totalCost += cost;</span></div><div><span style="color: rgb(4, 51, 255);">        node-&gt;_cost = cost;</span></div><div><span style="color: rgb(4, 51, 255);">        node-&gt;_time = now;</span></div><div><span style="color: rgb(4, 51, 255);">        node-&gt;_value = object;</span></div><div><span style="color: rgb(4, 51, 255);">        [_lru bringNodeToHead:node];</span></div><div><span style="color: rgb(4, 51, 255);">    } else {</span></div><div><span style="color: rgb(4, 51, 255);">        缓存对象不存在，添加数据，并移到栈顶</span></div><div><span style="color: rgb(4, 51, 255);">        node = [_YYLinkedMapNode new];</span></div><div><span style="color: rgb(4, 51, 255);">        node-&gt;_cost = cost;</span></div><div><span style="color: rgb(4, 51, 255);">        node-&gt;_time = now;</span></div><div><span style="color: rgb(4, 51, 255);">        node-&gt;_key = key;</span></div><div><span style="color: rgb(4, 51, 255);">        node-&gt;_value = object;</span></div><div><span style="color: rgb(4, 51, 255);">        [_lru insertNodeAtHead:node];</span></div><div><span style="color: rgb(4, 51, 255);">    }</span></div><div><span style="color: rgb(4, 51, 255);">    判断当前的缓存进行是否超出了设定值，若超出则进行整理</span></div><div><span style="color: rgb(4, 51, 255);">    if (_lru-&gt;_totalCost &gt; _costLimit) {</span></div><div><span style="color: rgb(4, 51, 255);">        dispatch_async(_queue, ^{</span></div><div><span style="color: rgb(4, 51, 255);">            [self trimToCost:_costLimit];</span></div><div><span style="color: rgb(4, 51, 255);">        });</span></div><div><span style="color: rgb(4, 51, 255);">    }</span></div><div>    每次添加数据仅有一个，数量上超出时，直接移除尾部那个object即可</div><div>    <span style="color: rgb(4, 51, 255);">if (_lru-&gt;_totalCount &gt; _countLimit) {</span></div><div><span style="color: rgb(4, 51, 255);">        _YYLinkedMapNode *node = [_lru removeTailNode];</span></div><div><span style="color: rgb(4, 51, 255);">        if (_lru-&gt;_releaseAsynchronously) {</span></div><div><span style="color: rgb(4, 51, 255);">            dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span></div><div><span style="color: rgb(4, 51, 255);">            dispatch_async(queue, ^{</span></div><div><span style="color: rgb(4, 51, 255);">                [node class]; </span></div><div><span style="color: rgb(4, 51, 255);">            });</span></div><div><span style="color: rgb(4, 51, 255);">        } else if (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) {</span></div><div><span style="color: rgb(4, 51, 255);">            dispatch_async(dispatch_get_main_queue(), ^{</span></div><div><span style="color: rgb(4, 51, 255);">                [node class]; </span></div><div><span style="color: rgb(4, 51, 255);">            });</span></div><div><span style="color: rgb(4, 51, 255);">        }</span></div><div><span style="color: rgb(4, 51, 255);">    }</span></div><div><span style="color: rgb(4, 51, 255);">    操作结束，解锁</span></div><div><span style="color: rgb(4, 51, 255);">    pthread_mutex_unlock(&amp;_lock);</span></div><div><span style="color: rgb(4, 51, 255);">}</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="margin-top: 1em; margin-bottom: 1em; font-weight: bold;">异步线程释放</span></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><div><img src="稀土掘金  (一)  YYCache源码分析_files/Image [3].png" type="image/png" data-filename="Image.png"/><br/></div></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">里面很多都用到类似的方法，将一个对象在异步线程中释放，来分析下：</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">- p</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">1. 首先通过node来对其进行持有，以至于不会在方法调用结束的时候被销毁</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">2. 我要要在其他线程中进行销毁，所以将销毁操作放在block中，block就会对其进行持有</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">3. 这边在block中随便调用了个方法，保证编译器不会优化掉这个操作</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">4. 当block结束后，node没有被持有的时候，就会在当前线程被release掉了</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="margin-top: 1em; margin-bottom: 1em; font-weight: bold;">添加缓存</span></div><div><span style="color: rgb(4, 51, 255);">这边从memory中取数据时，根据LRU原则，将最新取出的object放到栈头</span></div><div><span style="color: rgb(4, 51, 255);">- (id)objectForKey:(id)key {</span></div><div><span style="color: rgb(4, 51, 255);">    if (!key) return nil;</span></div><div><span style="color: rgb(4, 51, 255);">    pthread_mutex_lock(&amp;_lock);</span></div><div><span style="color: rgb(4, 51, 255);">    _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key));</span></div><div><span style="color: rgb(4, 51, 255);">    if (node) {</span></div><div><span style="color: rgb(4, 51, 255);">        node-&gt;_time = CACurrentMediaTime();</span></div><div><span style="color: rgb(4, 51, 255);">        [_lru bringNodeToHead:node];</span></div><div><span style="color: rgb(4, 51, 255);">    }</span></div><div><span style="color: rgb(4, 51, 255);">    pthread_mutex_unlock(&amp;_lock);</span></div><div><span style="color: rgb(4, 51, 255);">    return node ? node-&gt;_value : nil;</span></div><div><span style="color: rgb(4, 51, 255);">}</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="margin-top: 1em; margin-bottom: 1em; color: rgb(0, 176, 80); font-weight: bold;">YYKVStorage</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">该文件主要以两种方式来实现磁盘存储：SQLite、File，使用两种方式混合进行存储主要为了提高读写效率。写入数据时，SQLite要比文件的方式更快；读取数据的速度主要取决于文件的大小。据测试，在iPhone6中，当文件大小超过20kb时，File要比SQLite快的多。所以当大文件存储时建议用File的方式，小文件更适合用SQLite。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">下边分别对Save、Remove、Get分别进行分析</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="margin-top: 1em; margin-bottom: 1em; font-weight: bold;">Save</span></div><div><span style="color: rgb(4, 51, 255);">- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(NSString *)filename extendedData:(NSData *)extendedData {</span></div><div><span style="color: rgb(4, 51, 255);">    条件不符合</span></div><div><span style="color: rgb(4, 51, 255);">    if (key.length == 0 || value.length == 0) return NO;</span></div><div><span style="color: rgb(4, 51, 255);">    if (_type == YYKVStorageTypeFile &amp;&amp; filename.length == 0) {</span></div><div><span style="color: rgb(4, 51, 255);">        return NO;</span></div><div><span style="color: rgb(4, 51, 255);">    }</span></div><div><span style="color: rgb(4, 51, 255);">    if (filename.length) {    filename存在 SQLite File两种方式并行</span></div><div><span style="color: rgb(4, 51, 255);">        用文件进行存储</span></div><div><span style="color: rgb(4, 51, 255);">        if (![self _fileWriteWithName:filename data:value]) {</span></div><div><span style="color: rgb(4, 51, 255);">            return NO;</span></div><div><span style="color: rgb(4, 51, 255);">        }</span></div><div><span style="color: rgb(4, 51, 255);">        用SQLite进行存储</span></div><div><span style="color: rgb(4, 51, 255);">        if (![self _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) {</span></div><div><span style="color: rgb(4, 51, 255);">            当使用SQLite方式存储失败时，删除本地文件存储</span></div><div><span style="color: rgb(4, 51, 255);">            [self _fileDeleteWithName:filename];</span></div><div><span style="color: rgb(4, 51, 255);">            return NO;</span></div><div><span style="color: rgb(4, 51, 255);">        }</span></div><div><span style="color: rgb(4, 51, 255);">        return YES;</span></div><div><span style="color: rgb(4, 51, 255);">    } else {               filename不存在 SQLite</span></div><div><span style="color: rgb(4, 51, 255);">        if (_type != YYKVStorageTypeSQLite) {</span></div><div><span style="color: rgb(4, 51, 255);">            这边去到filename后，删除filename对应的file文件</span></div><div><span style="color: rgb(4, 51, 255);">            NSString *filename = [self _dbGetFilenameWithKey:key];</span></div><div><span style="color: rgb(4, 51, 255);">            if (filename) {</span></div><div><span style="color: rgb(4, 51, 255);">                [self _fileDeleteWithName:filename];</span></div><div><span style="color: rgb(4, 51, 255);">            }</span></div><div><span style="color: rgb(4, 51, 255);">        }</span></div><div><span style="color: rgb(4, 51, 255);">        SQLite 进行存储</span></div><div><span style="color: rgb(4, 51, 255);">        return [self _dbSaveWithKey:key value:value fileName:nil extendedData:extendedData];</span></div><div><span style="color: rgb(4, 51, 255);">    }</span></div><div><span style="color: rgb(4, 51, 255);">}</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="margin-top: 1em; margin-bottom: 1em; font-weight: bold;">Remove</span></div><div><span style="color: rgb(4, 51, 255);">- (BOOL)removeItemForKey:(NSString *)key {</span></div><div><span style="color: rgb(4, 51, 255);">    if (key.length == 0) return NO;</span></div><div><span style="color: rgb(4, 51, 255);">    switch (_type) {</span></div><div><span style="color: rgb(4, 51, 255);">        case YYKVStorageTypeSQLite: {</span></div><div><span style="color: rgb(4, 51, 255);">            删除SQLite文件</span></div><div><span style="color: rgb(4, 51, 255);">            return [self _dbDeleteItemWithKey:key];</span></div><div><span style="color: rgb(4, 51, 255);">        } break;</span></div><div><span style="color: rgb(4, 51, 255);">        case YYKVStorageTypeFile:</span></div><div><span style="color: rgb(4, 51, 255);">        case YYKVStorageTypeMixed: {</span></div><div><span style="color: rgb(4, 51, 255);">            获取filename</span></div><div><span style="color: rgb(4, 51, 255);">            NSString *filename = [self _dbGetFilenameWithKey:key];</span></div><div><span style="color: rgb(4, 51, 255);">            if (filename) {</span></div><div><span style="color: rgb(4, 51, 255);">                删除filename对的file</span></div><div><span style="color: rgb(4, 51, 255);">                [self _fileDeleteWithName:filename];</span></div><div><span style="color: rgb(4, 51, 255);">            }</span></div><div><span style="color: rgb(4, 51, 255);">            删除SQLite文件</span></div><div><span style="color: rgb(4, 51, 255);">            return [self _dbDeleteItemWithKey:key];</span></div><div><span style="color: rgb(4, 51, 255);">        } break;</span></div><div><span style="color: rgb(4, 51, 255);">        default: return NO;</span></div><div><span style="color: rgb(4, 51, 255);">    }</span></div><div><span style="color: rgb(4, 51, 255);">}</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="margin-top: 1em; margin-bottom: 1em; font-weight: bold;">Get</span></div><div><span style="color: rgb(4, 51, 255);">- (NSData *)getItemValueForKey:(NSString *)key {</span></div><div><span style="color: rgb(4, 51, 255);">    if (key.length == 0) return nil;</span></div><div><span style="color: rgb(4, 51, 255);">    NSData *value = nil;</span></div><div><span style="color: rgb(4, 51, 255);">    switch (_type) {</span></div><div><span style="color: rgb(4, 51, 255);">        case YYKVStorageTypeFile: {  File</span></div><div><span style="color: rgb(4, 51, 255);">            NSString *filename = [self _dbGetFilenameWithKey:key];</span></div><div><span style="color: rgb(4, 51, 255);">            if (filename) {</span></div><div><span style="color: rgb(4, 51, 255);">                根据filename获取File</span></div><div><span style="color: rgb(4, 51, 255);">                value = [self _fileReadWithName:filename];</span></div><div><span style="color: rgb(4, 51, 255);">                if (!value) {</span></div><div><span style="color: rgb(4, 51, 255);">                    当value不存在，用对应的key删除SQLite文件</span></div><div><span style="color: rgb(4, 51, 255);">                    [self _dbDeleteItemWithKey:key];</span></div><div><span style="color: rgb(4, 51, 255);">                    value = nil;</span></div><div><span style="color: rgb(4, 51, 255);">                }</span></div><div><span style="color: rgb(4, 51, 255);">            }</span></div><div><span style="color: rgb(4, 51, 255);">        } break;</span></div><div><span style="color: rgb(4, 51, 255);">        case YYKVStorageTypeSQLite: {</span></div><div><span style="color: rgb(4, 51, 255);">            SQLite 方式获取</span></div><div><span style="color: rgb(4, 51, 255);">            value = [self _dbGetValueWithKey:key];</span></div><div><span style="color: rgb(4, 51, 255);">        } break;</span></div><div><span style="color: rgb(4, 51, 255);">        case YYKVStorageTypeMixed: {</span></div><div><span style="color: rgb(4, 51, 255);">            NSString *filename = [self _dbGetFilenameWithKey:key];</span></div><div><span style="color: rgb(4, 51, 255);">            filename 存在文件获取，不存在SQLite方式获取</span></div><div><span style="color: rgb(4, 51, 255);">            if (filename) {</span></div><div><span style="color: rgb(4, 51, 255);">                value = [self _fileReadWithName:filename];</span></div><div><span style="color: rgb(4, 51, 255);">                if (!value) {</span></div><div><span style="color: rgb(4, 51, 255);">                    [self _dbDeleteItemWithKey:key];</span></div><div><span style="color: rgb(4, 51, 255);">                    value = nil;</span></div><div><span style="color: rgb(4, 51, 255);">                }</span></div><div><span style="color: rgb(4, 51, 255);">            } else {</span></div><div><span style="color: rgb(4, 51, 255);">                value = [self _dbGetValueWithKey:key];</span></div><div><span style="color: rgb(4, 51, 255);">            }</span></div><div><span style="color: rgb(4, 51, 255);">        } break;</span></div><div><span style="color: rgb(4, 51, 255);">    }</span></div><div><span style="color: rgb(4, 51, 255);">    if (value) {</span></div><div><span style="color: rgb(4, 51, 255);">        更新文件操作时间</span></div><div><span style="color: rgb(4, 51, 255);">        [self _dbUpdateAccessTimeWithKey:key];</span></div><div><span style="color: rgb(4, 51, 255);">    }</span></div><div><span style="color: rgb(4, 51, 255);">    return value;</span></div><div><span style="color: rgb(4, 51, 255);">}</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">File方式主要使用的writeToFile进行存储，SQLte直接使用的sqlite3来对文件进行操作，具体数据库相关的操作这边就不在进行分析了，感兴趣的自己可以阅读下</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="margin-top: 1em; margin-bottom: 1em; color: rgb(0, 176, 80); font-weight: bold;">YYDiskCache</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">YYDiskCache是对YYKVStorage进行的一次封装，是线程安全的，这边使用的是dispatch_semaphore_signal来确保线程的安全。另外他结合LRU算法，根据文件的大小自动选择存储方式来达到更好的性能。</span></div><div><span style="color: rgb(4, 51, 255);">- (instancetype)initWithPath:(NSString *)path</span></div><div><span style="color: rgb(4, 51, 255);">             inlineThreshold:(NSUInteger)threshold {</span></div><div><span style="color: rgb(4, 51, 255);">    self = [super init];</span></div><div><span style="color: rgb(4, 51, 255);">    if (!self) return nil;</span></div><div><span style="color: rgb(4, 51, 255);">    获取缓存的 YYDiskCache</span></div><div><span style="color: rgb(4, 51, 255);">    YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);</span></div><div><span style="color: rgb(4, 51, 255);">    if (globalCache) return globalCache;</span></div><div><span style="color: rgb(4, 51, 255);">    确定存储的方式</span></div><div><span style="color: rgb(4, 51, 255);">    YYKVStorageType type;</span></div><div><span style="color: rgb(4, 51, 255);">    if (threshold == 0) {</span></div><div><span style="color: rgb(4, 51, 255);">        type = YYKVStorageTypeFile;</span></div><div><span style="color: rgb(4, 51, 255);">    } else if (threshold == NSUIntegerMax) {</span></div><div><span style="color: rgb(4, 51, 255);">        type = YYKVStorageTypeSQLite;</span></div><div><span style="color: rgb(4, 51, 255);">    } else {</span></div><div><span style="color: rgb(4, 51, 255);">        type = YYKVStorageTypeMixed;</span></div><div><span style="color: rgb(4, 51, 255);">    }</span></div><div><span style="color: rgb(4, 51, 255);">    初始化 YYKVStorage</span></div><div><span style="color: rgb(4, 51, 255);">    YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type];</span></div><div><span style="color: rgb(4, 51, 255);">    if (!kv) return nil;</span></div><div><span style="color: rgb(4, 51, 255);">    初始化数据</span></div><div><span style="color: rgb(4, 51, 255);">    _kv = kv;</span></div><div><span style="color: rgb(4, 51, 255);">    _path = path;</span></div><div><span style="color: rgb(4, 51, 255);">    _lock = dispatch_semaphore_create(1);</span></div><div><span style="color: rgb(4, 51, 255);">    _queue = dispatch_queue_create(&quot;com.ibireme.cache.disk&quot;, DISPATCH_QUEUE_CONCURRENT);</span></div><div><span style="color: rgb(4, 51, 255);">    _inlineThreshold = threshold;</span></div><div><span style="color: rgb(4, 51, 255);">    _countLimit = NSUIntegerMax;</span></div><div><span style="color: rgb(4, 51, 255);">    _costLimit = NSUIntegerMax;</span></div><div><span style="color: rgb(4, 51, 255);">    _ageLimit = DBL_MAX;</span></div><div><span style="color: rgb(4, 51, 255);">    _freeDiskSpaceLimit = 0;</span></div><div><span style="color: rgb(4, 51, 255);">    _autoTrimInterval = 60;</span></div><div><span style="color: rgb(4, 51, 255);">    递归的去整理文件</span></div><div><span style="color: rgb(4, 51, 255);">    [self _trimRecursively];</span></div><div><span style="color: rgb(4, 51, 255);">    对当前对象进行缓存</span></div><div><span style="color: rgb(4, 51, 255);">    _YYDiskCacheSetGlobal(self);</span></div><div><span style="color: rgb(4, 51, 255);">    通知 APP即将被杀死时</span></div><div><span style="color: rgb(4, 51, 255);">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_appWillBeTerminated) name:UIApplicationWillTerminateNotification object:nil];</span></div><div><span style="color: rgb(4, 51, 255);">    return self;</span></div><div><span style="color: rgb(4, 51, 255);">}</span></div><div>其他的一些操作基本上都是对YYKVStorage的一些封装，这边就不一一分析了。</div><div><br/></div><div><br/></div><div><span style="direction: ltr; margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; color: rgb(79, 129, 189); font-family: SimSun; font-weight: bold;">笔记整理：Edison</span></div><div style="direction: ltr; font-size: 10.5pt; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-size: 10.5pt; margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-family: SimSun; color: rgb(79, 129, 189); font-weight: bold;">联系方式：QQ：277593 （笔记意见建议可加此Q，专人更新此笔记）；</span></div><div><span style="direction: ltr; margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; color: rgb(79, 129, 189); font-family: SimSun; font-weight: bold;">注：小道途径获取到的笔记，无法自动更新，请谅解！(笔记平均每月更新一次，祝各位都能拿到心仪的offer)</span><span style="direction: ltr; margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; color: rgb(79, 129, 189); font-family: SimSun;"> </span></div><div><br/></div><div><br/></div></span>
</div></body></html> 