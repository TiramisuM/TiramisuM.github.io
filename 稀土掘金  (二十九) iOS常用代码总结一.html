<html>
<head>
  <title>稀土掘金  (二十九) :iOS常用代码总结&lt;一&gt;</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <meta name="application-data:corenote-hostUUID" content="C8940BC2-A53C-4B55-B59C-4779464BC778"/>
  <meta name="application-data:corenote-localUUID" content="267368C6-E1BB-45FE-9BB0-053D274A5AC3"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="882"/>
<h1>稀土掘金  (二十九) :iOS常用代码总结&lt;一&gt;</h1>

<div>
<span><h3>1、禁止手机睡眠</h3><pre><code>[UIApplication sharedApplication].idleTimerDisabled = YES;</code></pre><h3>2、隐藏某行cell</h3><pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath<br/>{<br/>// 如果是你需要隐藏的那一行，返回高度为0<br/>    if(indexPath.row == YouWantToHideRow)<br/>        return 0; <br/>    return 44;<br/>}<br/><br/>// 然后再你需要隐藏cell的时候调用<br/>[self.tableView beginUpdates];<br/>[self.tableView endUpdates];</code></pre><h3>3、禁用button高亮</h3><pre><code>button.adjustsImageWhenHighlighted = NO;<br/>或者在创建的时候<br/> UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];</code></pre><h3>4、tableview遇到这种报错failed to obtain a cell from its dataSource</h3><blockquote><div>是因为你的cell被调用的早了。先循环使用了cell，后又创建cell。顺序错了</div><div>可能原因：1、xib的cell没有注册 2、内存中已经有这个cell的缓存了(也就是说通过你的cellId找到的cell并不是你想要的类型)，这时候需要改下cell的标识</div></blockquote><h3>5、cocoa pods报这个错误：unable to access '<a href="https://github.com/facebook/pop.git/">https://github.com/facebook/pop.git/</a>': Operation timed out after 0 milliseconds with 0 out of 0 bytes received</h3><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">解决办法：原因可能是网络问题，网络请求超时了，只需要重试就行了</span></div></blockquote><h3>6、cocoa pods 出现ERROR: While executing gem ... (Errno::EPERM)</h3><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><a href="https://segmentfault.com/q/1010000002926243" style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">解决办法：</a></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><a href="https://segmentfault.com/q/1010000002926243" style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">https://segmentfault.com/q/1010000002926243</a></div></blockquote><h3>7、动画切换window的根控制器</h3><pre><code>// options是动画选项<br/>[UIView transitionWithView:[UIApplication sharedApplication].keyWindow duration:0.5f options:UIViewAnimationOptionTransitionCrossDissolve animations:^{<br/>        BOOL oldState = [UIView areAnimationsEnabled];<br/>        [UIView setAnimationsEnabled:NO];<br/>        [UIApplication sharedApplication].keyWindow.rootViewController = [RootViewController new];<br/>        [UIView setAnimationsEnabled:oldState];<br/>    } completion:^(BOOL finished) {<br/><br/>    }];</code></pre><h3>8、去除数组中重复的对象</h3><pre><code>NSArray *newArr = [oldArr valueForKeyPath:@“@distinctUnionOfObjects.self&quot;];</code></pre><h3>9、编译的时候遇到 <span style="font-weight: bold;">no such file or directory: ／users／apple／XXX</span></h3><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">是因为编译的时候，在此路径下找不到这个文件，解决这个问题，首先是是要检查缺少的文件是不是在工程中，如果不在工程中，需要从本地拖进去，如果发现已经存在工程中了，或者拖进去还是报错，这时候需要去build phases中搜索这个文件，这时候很可能会搜出现两个相同的文件，这时候，有一个路径是正确的，删除另外一个即可。如果删除了还是不行，需要把两个都删掉，然后重新往工程里拖进这个文件即可</span></div></blockquote><div><br/></div><div><img src="稀土掘金  (二十九) iOS常用代码总结一_files/111.png" type="image/png" data-filename="111.png"/><br/></div><h3>10、iOS8系统中，tableView最好实现下-tableView: heightForRowAtIndexPath:这个代理方法，要不然在iOS8中可能就会出现显示不全或者无法响应事件的问题</h3><h3>11、iOS8中实现侧滑功能的时候这个方法必须实现，要不然在iOS8中无法侧滑</h3><pre><code>// 必须写的方法，和editActionsForRowAtIndexPath配对使用，里面什么不写也行<br/>- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {<br/><br/>}</code></pre><h3>12、三个通知</h3><blockquote><div>NSSystemTimeZoneDidChangeNotification监听修改时间界面的两个按钮状态变化</div><div>UIApplicationSignificantTimeChangeNotification 监听用户改变时间 （只要点击自动设置按钮就会调用） NSSystemClockDidChangeNotification 监听用户修改时间（时间不同才会调用）</div></blockquote><h3>13、SDWebImage本地缓存有时候会害人。如果之前缓存过一张图片，即使下次服务器换了这张图片，但是图片url没换，用sdwebimage下载下来的还是以前那张,所以遇到这种问题，不要先去怼服务器，清空下缓存再试就好了。</h3><h3>14、上线前注意：</h3><blockquote><div>1）、删掉代码中所有的测试代码</div><div>2）、如果后台有审核模式，提醒后台开启此模式</div><div>3）、主流程再跑一跑</div><div>4）、全局搜索waring，检查所有标记waring的地方</div></blockquote><h3>15、跳进app权限设置</h3><pre><code>// 跳进app设置<br/>            if (UIApplicationOpenSettingsURLString != NULL) {<br/>                UIApplication *application = [UIApplication sharedApplication];<br/>                NSURL *URL = [NSURL URLWithString:UIApplicationOpenSettingsURLString];<br/>                if ([application respondsToSelector:@selector(openURL:options:completionHandler:)]) {<br/>                    [application openURL:URL options:@{}<br/>                       completionHandler:nil];<br/>                } else {<br/>                    [application openURL:URL];<br/>                }<br/>            }</code></pre><h3>16、给一个view截图</h3><pre><code>UIGraphicsBeginImageContextWithOptions(view.bounds.size, YES, 0.0);<br/>    [view.layer renderInContext:UIGraphicsGetCurrentContext()];<br/>    UIImage *img = UIGraphicsGetImageFromCurrentImageContext();<br/>    UIGraphicsEndImageContext();</code></pre><h3>17、开发中如果要动态修改tableView的tableHeaderView或者tableFooterView的高度，需要给tableView重新设置，而不是直接更改高度。正确的做法是重新设置一下tableView.tableFooterView = 更改过高度的view。为什么？其实在iOS8以上直接改高度是没有问题的，在iOS8中出现了contentSize不准确的问题，这是解决办法。</h3><h3>18、注意对象为nil的时候，调用此对象分类的方法不会执行</h3><h3>19、collectionView的内容小于其宽高的时候是不能滚动的，设置可以滚动：</h3><pre><code>collectionView.alwaysBounceHorizontal = YES;<br/>collectionView.alwaysBounceVertical = YES;</code></pre><h3>20、设置navigationBar上的title颜色和大小</h3><pre><code>    [self.navigationController.navigationBar setTitleTextAttributes:@{NSForegroundColorAttributeName : [UIColor youColor], NSFontAttributeName : [UIFont systemFontOfSize:15]}]</code></pre><h3>21、颜色转图片</h3><pre><code>+ (UIImage *)cl_imageWithColor:(UIColor *)color {<br/>  CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);<br/>  UIGraphicsBeginImageContext(rect.size);<br/>  CGContextRef context = UIGraphicsGetCurrentContext();<br/><br/>  CGContextSetFillColorWithColor(context, [color CGColor]);<br/>  CGContextFillRect(context, rect);<br/><br/>  UIImage *image = UIGraphicsGetImageFromCurrentImageContext();<br/>  UIGraphicsEndImageContext();<br/><br/>  return image;<br/>}</code></pre><h3>22、view设置圆角</h3><pre><code>#define ViewBorderRadius(View, Radius, Width, Color)\<br/>\<br/>[View.layer setCornerRadius:(Radius)];\<br/>[View.layer setMasksToBounds:YES];\<br/>[View.layer setBorderWidth:(Width)];\<br/>[View.layer setBorderColor:[Color CGColor]] // view圆角</code></pre><h3>23、强／弱引用</h3><pre><code>#define WeakSelf(type)  __weak typeof(type) weak##type = type; // weak<br/>#define StrongSelf(type)  __strong typeof(type) type = weak##type; // strong</code></pre><h3>24、由角度转换弧度</h3><pre><code>#define DegreesToRadian(x) (M_PI * (x) / 180.0)</code></pre><h3>25、由弧度转换角度</h3><pre><code>#define RadianToDegrees(radian) (radian*180.0)/(M_PI)</code></pre><h3>26、获取图片资源</h3><pre><code>#define GetImage(imageName) [UIImage imageNamed:[NSString stringWithFormat:@&quot;%@&quot;,imageName]]</code></pre><h3>27、获取temp</h3><pre><code>#define PathTemp NSTemporaryDirectory()</code></pre><h3>28、获取沙盒 Document</h3><pre><code>#define PathDocument [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]</code></pre><h3>29、获取沙盒 Cache</h3><pre><code>#define PathCache [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]</code></pre><h3>30、GCD代码只执行一次</h3><pre><code>#define kDISPATCH_ONCE_BLOCK(onceBlock) static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, onceBlock);</code></pre><h3>31、自定义NSLog</h3><pre><code>#ifdef DEBUG<br/>#define NSLog(fmt, ...) NSLog((@&quot;%s [Line %d] &quot; fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)<br/>#else<br/>#define NSLog(...)<br/>#endif</code></pre><h3>32、Font</h3><pre><code>#define FontL(s)             [UIFont systemFontOfSize:s weight:UIFontWeightLight]<br/>#define FontR(s)             [UIFont systemFontOfSize:s weight:UIFontWeightRegular]<br/>#define FontB(s)             [UIFont systemFontOfSize:s weight:UIFontWeightBold]<br/>#define FontT(s)             [UIFont systemFontOfSize:s weight:UIFontWeightThin]<br/>#define Font(s)              FontL(s)</code></pre><h3>33、FORMAT</h3><pre><code>#define FORMAT(f, ...)      [NSString stringWithFormat:f, ## __VA_ARGS__]</code></pre><h3>34、在主线程上运行</h3><pre><code>#define kDISPATCH_MAIN_THREAD(mainQueueBlock) dispatch_async(dispatch_get_main_queue(), mainQueueBlock);</code></pre><h3>35、开启异步线程</h3><pre><code>#define kDISPATCH_GLOBAL_QUEUE_DEFAULT(globalQueueBlock) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), globalQueueBlocl);</code></pre><h3>36、通知</h3><pre><code>#define NOTIF_ADD(n, f)     [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(f) name:n object:nil]<br/>#define NOTIF_POST(n, o)    [[NSNotificationCenter defaultCenter] postNotificationName:n object:o]<br/>#define NOTIF_REMV()        [[NSNotificationCenter defaultCenter] removeObserver:self]</code></pre><h3>37、随机颜色</h3><pre><code>+ (UIColor *)RandomColor {<br/>    NSInteger aRedValue = arc4random() % 255;<br/>    NSInteger aGreenValue = arc4random() % 255;<br/>    NSInteger aBlueValue = arc4random() % 255;<br/>    UIColor *randColor = [UIColor colorWithRed:aRedValue / 255.0f green:aGreenValue / 255.0f blue:aBlueValue / 255.0f alpha:1.0f];<br/>    return randColor;<br/>}</code></pre><h3>38、获取window</h3><pre><code>+(UIWindow*)getWindow {<br/>    UIWindow* win = nil; //[UIApplication sharedApplication].keyWindow;<br/>    for (id item in [UIApplication sharedApplication].windows) {<br/>        if ([item class] == [UIWindow class]) {<br/>            if (!((UIWindow*)item).hidden) {<br/>                win = item;<br/>                break;<br/>            }<br/>        }<br/>    }<br/>    return win;<br/>}</code></pre><h3>39、修改textField的placeholder的字体颜色、大小</h3><pre><code>[textField setValue:[UIColor redColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];<br/>[textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@&quot;_placeholderLabel.font&quot;];</code></pre><h3>40、统一收起键盘</h3><pre><code>[[[UIApplication sharedApplication] keyWindow] endEditing:YES];</code></pre><h3>41、控制屏幕旋转，在控制器中写</h3><pre><code>/** 是否支持自动转屏 */<br/>- (BOOL)shouldAutorotate {<br/>    return YES;<br/>}<br/><br/>/** 支持哪些屏幕方向 */<br/>- (UIInterfaceOrientationMask)supportedInterfaceOrientations {<br/>    return UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight;<br/>}<br/><br/>/** 默认的屏幕方向（当前ViewController必须是通过模态出来的UIViewController（模态带导航的无效）方式展现出来的，才会调用这个方法） */<br/>- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation {<br/>    return UIInterfaceOrientationLandscapeLeft | UIInterfaceOrientationLandscapeRight;<br/>}</code></pre><h3>42、获取app缓存大小</h3><pre><code>- (CGFloat)getCachSize {<br/><br/>    NSUInteger imageCacheSize = [[SDImageCache sharedImageCache] getSize];<br/>    //获取自定义缓存大小<br/>    //用枚举器遍历 一个文件夹的内容<br/>    //1.获取 文件夹枚举器<br/>    NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Library/Caches&quot;];<br/>    NSDirectoryEnumerator *enumerator = [[NSFileManager defaultManager] enumeratorAtPath:myCachePath];<br/>    __block NSUInteger count = 0;<br/>    //2.遍历<br/>    for (NSString *fileName in enumerator) {<br/>        NSString *path = [myCachePath stringByAppendingPathComponent:fileName];<br/>        NSDictionary *fileDict = [[NSFileManager defaultManager] attributesOfItemAtPath:path error:nil];<br/>        count += fileDict.fileSize;//自定义所有缓存大小<br/>    }<br/>    // 得到是字节  转化为M<br/>    CGFloat totalSize = ((CGFloat)imageCacheSize+count)/1024/1024;<br/>    return totalSize;<br/>}</code></pre><h3>43、清理app缓存</h3><pre><code>- (void)handleClearView {<br/>    //删除两部分<br/>    //1.删除 sd 图片缓存<br/>    //先清除内存中的图片缓存<br/>    [[SDImageCache sharedImageCache] clearMemory];<br/>    //清除磁盘的缓存<br/>    [[SDImageCache sharedImageCache] clearDisk];<br/>    //2.删除自己缓存<br/>    NSString *myCachePath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Library/Caches&quot;];<br/>    [[NSFileManager defaultManager] removeItemAtPath:myCachePath error:nil];<br/>}</code></pre><h3>44、模型转字典</h3><pre><code>static NSSet *classes;<br/><br/>- (NSMutableDictionary *)getParameterDictionary {<br/><br/>    NSMutableDictionary *dict = [NSMutableDictionary dictionary];<br/><br/>    Class c = self.class;<br/><br/>    while (c) {<br/>        unsigned count;<br/>        objc_property_t *properties = class_copyPropertyList([c class], &amp;count);<br/><br/>        for (int i = 0; i &lt; count; i++) {<br/>            NSString *key = [NSString stringWithUTF8String:property_getName(properties[i])];<br/>            dict[key] = [self valueForKey:key];<br/>        }<br/>        free(properties);<br/><br/>        // 获得父类<br/>        c = class_getSuperclass(c);<br/><br/>        if ([self isClassFromFoundation:c]) break;<br/>    }<br/>    return dict;<br/>}<br/><br/>- (BOOL)isClassFromFoundation:(Class)c<br/>{<br/>    if (c == [NSObject class] || c == [NSManagedObject class]) return YES;<br/><br/>    __block BOOL result = NO;<br/>    [[self foundationClasses] enumerateObjectsUsingBlock:^(Class foundationClass, BOOL *stop) {<br/>        if ([c isSubclassOfClass:foundationClass]) {<br/>            result = YES;<br/>            *stop = YES;<br/>        }<br/>    }];<br/>    return result;<br/>}<br/><br/>- (NSSet *)foundationClasses<br/>{<br/>    if (classes == nil) {<br/>        // 集合中没有NSObject，因为几乎所有的类都是继承自NSObject，具体是不是NSObject需要特殊判断<br/>        classes = [NSSet setWithObjects:<br/>                              [NSURL class],<br/>                              [NSDate class],<br/>                              [NSValue class],<br/>                              [NSData class],<br/>                              [NSError class],<br/>                              [NSArray class],<br/>                              [NSDictionary class],<br/>                              [NSString class],<br/>                              [NSAttributedString class], nil];<br/>    }<br/>    return classes;<br/>}</code></pre><h3>45、交换两个方法实现</h3><pre><code>Class aClass = [self class]; <br/><br/>        SEL originalSelector = @selector(viewWillAppear:); <br/>        SEL swizzledSelector = @selector(xxx_viewWillAppear:); <br/><br/>        Method originalMethod = class_getInstanceMethod(aClass, originalSelector); <br/>        Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); <br/><br/>        BOOL didAddMethod = <br/>            class_addMethod(aClass, <br/>                originalSelector, <br/>                method_getImplementation(swizzledMethod), <br/>                method_getTypeEncoding(swizzledMethod)); <br/><br/>        if (didAddMethod) { <br/>            class_replaceMethod(aClass, <br/>                swizzledSelector, <br/>                method_getImplementation(originalMethod), <br/>                method_getTypeEncoding(originalMethod)); <br/>        } else { <br/>            method_exchangeImplementations(originalMethod, swizzledMethod); <br/>        }</code></pre><h3>46、打印百分号和引号</h3><pre><code>    NSLog(@&quot;%%&quot;);<br/>    NSLog(@&quot;\&quot;&quot;);</code></pre><h3>47、几个常用权限判断</h3><pre><code>    if ([CLLocationManager authorizationStatus] ==kCLAuthorizationStatusDenied) {<br/>        NSLog(@&quot;没有定位权限&quot;);<br/>    }<br/>    AVAuthorizationStatus statusVideo = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];<br/>    if (statusVideo == AVAuthorizationStatusDenied) {<br/>        NSLog(@&quot;没有摄像头权限&quot;);<br/>    }<br/>    //是否有麦克风权限<br/>    AVAuthorizationStatus statusAudio = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio];<br/>    if (statusAudio == AVAuthorizationStatusDenied) {<br/>        NSLog(@&quot;没有录音权限&quot;);<br/>    }<br/>    [PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) {<br/>        if (status == PHAuthorizationStatusDenied) {<br/>            NSLog(@&quot;没有相册权限&quot;);<br/>        }<br/>    }];</code></pre><h3>48、获取手机型号</h3><pre><code>    + (NSString *)getDeviceInfo {<br/>    struct utsname systemInfo;<br/>    uname(&amp;systemInfo);<br/>    NSString *platform = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding];<br/>    if ([platform isEqualToString:@&quot;iPhone1,1&quot;]) return @&quot;iPhone 2G&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone1,2&quot;]) return @&quot;iPhone 3G&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone2,1&quot;]) return @&quot;iPhone 3GS&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone3,1&quot;]) return @&quot;iPhone 4&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone3,2&quot;]) return @&quot;iPhone 4&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone5,1&quot;]) return @&quot;iPhone 5&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone5,3&quot;]) return @&quot;iPhone 5c&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone6,1&quot;]) return @&quot;iPhone 5s&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6s&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6s Plus&quot;;<br/>    // 日行两款手机型号均为日本独占，可能使用索尼FeliCa支付方案而不是苹果支付<br/>    if ([platform isEqualToString:@&quot;iPhone9,1&quot;])    return @&quot;国行、日版、港行iPhone 7&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone9,2&quot;])    return @&quot;港行、国行iPhone 7 Plus&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone9,3&quot;])    return @&quot;美版、台版iPhone 7&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone9,4&quot;])    return @&quot;美版、台版iPhone 7 Plus&quot;;<br/>    if ([platform isEqualToString:@&quot;iPhone8,4&quot;]) return @&quot;iPhone SE&quot;;<br/>    if ([platform isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iPod Touch 1G&quot;;<br/>    if ([platform isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iPod Touch 2G&quot;;<br/>    if ([platform isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iPod Touch 3G&quot;;<br/>    if ([platform isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iPod Touch 4G&quot;;<br/>    if ([platform isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iPod Touch 5G&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad 1G&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad2,1&quot;]) return @&quot;iPad 2&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad2,2&quot;]) return @&quot;iPad 2&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad2,3&quot;]) return @&quot;iPad 2&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad2,5&quot;]) return @&quot;iPad Mini 1G&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad2,6&quot;]) return @&quot;iPad Mini 1G&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad Mini 1G&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad3,1&quot;]) return @&quot;iPad 3&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad3,2&quot;]) return @&quot;iPad 3&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad3,4&quot;]) return @&quot;iPad 4&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad3,5&quot;]) return @&quot;iPad 4&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad4,1&quot;]) return @&quot;iPad Air&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad4,2&quot;]) return @&quot;iPad Air&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad4,3&quot;]) return @&quot;iPad Air&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad4,4&quot;]) return @&quot;iPad Mini 2G&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad4,5&quot;]) return @&quot;iPad Mini 2G&quot;;<br/>    if ([platform isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad Mini 2G&quot;;<br/>    if ([platform isEqualToString:@&quot;i386&quot;]) return @&quot;iPhone Simulator&quot;;<br/>    if ([platform isEqualToString:@&quot;x86_64&quot;]) return @&quot;iPhone Simulator&quot;;<br/>    return platform;<br/>}</code></pre><h3>49、长按复制功能</h3><pre><code>- (void)viewDidLoad<br/>{<br/>    [self.view addGestureRecognizer:[[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(pasteBoard:)]];<br/>}<br/>- (void)pasteBoard:(UILongPressGestureRecognizer *)longPress {<br/>    if (longPress.state == UIGestureRecognizerStateBegan) {<br/>        UIPasteboard *pasteboard = [UIPasteboard generalPasteboard];<br/>        pasteboard.string = @&quot;需要复制的文本&quot;;<br/>    }<br/>}</code></pre><h3>50、cocoapods升级</h3><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">在终端执行 sudo gem install -n / usr / local / bin cocoapods --pre</span></div></blockquote><h3>51、设置启动页后，依然显示之前的</h3><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">删除app，手机重启，重新安装</span></div></blockquote><h3>52、判断图片类型</h3><pre><code>//通过图片Data数据第一个字节 来获取图片扩展名<br/>- (NSString *)contentTypeForImageData:(NSData *)data<br/>{<br/>    uint8_t c;<br/>    [data getBytes:&amp;c length:1];<br/>    switch (c)<br/>    {<br/>        case 0xFF:<br/>            return @&quot;jpeg&quot;;<br/><br/>        case 0x89:<br/>            return @&quot;png&quot;;<br/><br/>        case 0x47:<br/>            return @&quot;gif&quot;;<br/><br/>        case 0x49:<br/>        case 0x4D:<br/>            return @&quot;tiff&quot;;<br/><br/>        case 0x52:<br/>        if ([data length] &lt; 12) {<br/>            return nil;<br/>        }<br/><br/>        NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];<br/>        if ([testString hasPrefix:@&quot;RIFF&quot;]<br/>            &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;])<br/>        {<br/>            return @&quot;webp&quot;;<br/>        }<br/><br/>        return nil;<br/>    }<br/><br/>    return nil;<br/>}</code></pre><h3>53、获取手机和app信息</h3><pre><code>NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];  <br/> CFShow(infoDictionary);  <br/>// app名称  <br/> NSString *app_Name = [infoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;];  <br/> // app版本  <br/> NSString *app_Version = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;];  <br/> // app build版本  <br/> NSString *app_build = [infoDictionary objectForKey:@&quot;CFBundleVersion&quot;];  <br/><br/><br/><br/>    //手机序列号  <br/>    NSString* identifierNumber = [[UIDevice currentDevice] uniqueIdentifier];  <br/>    NSLog(@&quot;手机序列号: %@&quot;,identifierNumber);  <br/>    //手机别名： 用户定义的名称  <br/>    NSString* userPhoneName = [[UIDevice currentDevice] name];  <br/>    NSLog(@&quot;手机别名: %@&quot;, userPhoneName);  <br/>    //设备名称  <br/>    NSString* deviceName = [[UIDevice currentDevice] systemName];  <br/>    NSLog(@&quot;设备名称: %@&quot;,deviceName );  <br/>    //手机系统版本  <br/>    NSString* phoneVersion = [[UIDevice currentDevice] systemVersion];  <br/>    NSLog(@&quot;手机系统版本: %@&quot;, phoneVersion);  <br/>    //手机型号  <br/>    NSString* phoneModel = [[UIDevice currentDevice] model];  <br/>    NSLog(@&quot;手机型号: %@&quot;,phoneModel );  <br/>    //地方型号  （国际化区域名称）  <br/>    NSString* localPhoneModel = [[UIDevice currentDevice] localizedModel];  <br/>    NSLog(@&quot;国际化区域名称: %@&quot;,localPhoneModel );  <br/><br/>    NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];  <br/>    // 当前应用名称  <br/>    NSString *appCurName = [infoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;];  <br/>    NSLog(@&quot;当前应用名称：%@&quot;,appCurName);  <br/>    // 当前应用软件版本  比如：1.0.1  <br/>    NSString *appCurVersion = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;];  <br/>    NSLog(@&quot;当前应用软件版本:%@&quot;,appCurVersion);  <br/>    // 当前应用版本号码   int类型  <br/>    NSString *appCurVersionNum = [infoDictionary objectForKey:@&quot;CFBundleVersion&quot;];  <br/>    NSLog(@&quot;当前应用版本号码：%@&quot;,appCurVersionNum);</code></pre><h3>54、获取一个类的所有属性</h3><pre><code>id LenderClass = objc_getClass(&quot;Lender&quot;);<br/>unsigned int outCount, i;<br/>objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);<br/>for (i = 0; i &lt; outCount; i++) {<br/>    objc_property_t property = properties[i];<br/>    fprintf(stdout, &quot;%s %s\n&quot;, property_getName(property), property_getAttributes(property));<br/>}</code></pre><h3>55、image圆角</h3><pre><code>- (UIImage *)circleImage<br/>{<br/>    // NO代表透明<br/>    UIGraphicsBeginImageContextWithOptions(self.size, NO, 1);<br/>    // 获得上下文<br/>    CGContextRef ctx = UIGraphicsGetCurrentContext();<br/>    // 添加一个圆<br/>    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);<br/>    // 方形变圆形<br/>    CGContextAddEllipseInRect(ctx, rect);<br/>    // 裁剪<br/>    CGContextClip(ctx);<br/>    // 将图片画上去<br/>    [self drawInRect:rect];<br/>    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();<br/>    UIGraphicsEndImageContext();<br/>    return image;<br/>}</code></pre><h3>56、image拉伸</h3><pre><code>+ (UIImage *)resizableImage:(NSString *)imageName<br/>{<br/>    UIImage *image = [UIImage imageNamed:imageName];<br/>    CGFloat imageW = image.size.width;<br/>    CGFloat imageH = image.size.height;<br/>    return [image resizableImageWithCapInsets:UIEdgeInsetsMake(imageH * 0.5, imageW * 0.5, imageH * 0.5, imageW * 0.5) resizingMode:UIImageResizingModeStretch];<br/>}</code></pre><h3>57、JSON字符串转字典</h3><pre><code>+ (NSDictionary *)parseJSONStringToNSDictionary:(NSString *)JSONString {<br/>    NSData *JSONData = [JSONString dataUsingEncoding:NSUTF8StringEncoding];<br/>    NSDictionary *responseJSON = [NSJSONSerialization JSONObjectWithData:JSONData options:NSJSONReadingMutableLeaves error:nil];<br/>    return responseJSON;<br/>}</code></pre><h3>58、身份证号验证</h3><pre><code>- (BOOL)validateIdentityCard {<br/>    BOOL flag;<br/>    if (self.length &lt;= 0) {<br/>        flag = NO;<br/>        return flag;<br/>    }<br/>    NSString *regex2 = @&quot;^(\\d{14}|\\d{17})(\\d|[xX])$&quot;;<br/>    NSPredicate *identityCardPredicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,regex2];<br/>    return [identityCardPredicate evaluateWithObject:self];<br/>}</code></pre><h3>59、获取设备mac地址</h3><pre><code>+ (NSString *)macAddress {<br/>    int                 mib[6];<br/>    size_t              len;<br/>    char                *buf;<br/>    unsigned char       *ptr;<br/>    struct if_msghdr    *ifm;<br/>    struct sockaddr_dl  *sdl;<br/><br/>    mib[0] = CTL_NET;<br/>    mib[1] = AF_ROUTE;<br/>    mib[2] = 0;<br/>    mib[3] = AF_LINK;<br/>    mib[4] = NET_RT_IFLIST;<br/><br/>    if((mib[5] = if_nametoindex(&quot;en0&quot;)) == 0) {<br/>        printf(&quot;Error: if_nametoindex error\n&quot;);<br/>        return NULL;<br/>    }<br/><br/>    if(sysctl(mib, 6, NULL, &amp;len, NULL, 0) &lt; 0) {<br/>        printf(&quot;Error: sysctl, take 1\n&quot;);<br/>        return NULL;<br/>    }<br/><br/>    if((buf = malloc(len)) == NULL) {<br/>        printf(&quot;Could not allocate memory. Rrror!\n&quot;);<br/>        return NULL;<br/>    }<br/><br/>    if(sysctl(mib, 6, buf, &amp;len, NULL, 0) &lt; 0) {<br/>        printf(&quot;Error: sysctl, take 2&quot;);<br/>        return NULL;<br/>    }<br/><br/>    ifm = (struct if_msghdr *)buf;<br/>    sdl = (struct sockaddr_dl *)(ifm + 1);<br/>    ptr = (unsigned char *)LLADDR(sdl);<br/>    NSString *outstring = [NSString stringWithFormat:@&quot;%02X:%02X:%02X:%02X:%02X:%02X&quot;,<br/>                           *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)];<br/>    free(buf);<br/><br/>    return outstring;<br/>}</code></pre><h3>60、导入自定义字体库</h3><blockquote><div>1、找到你想用的字体的 ttf 格式，拖入工程</div><div>2、在工程的plist中增加一行数组，“Fonts provided by application”</div><div>3、为这个key添加一个item，value为你刚才导入的ttf文件名</div><div>4、直接使用即可：label.font = [UIFont fontWithName:@&quot;你刚才导入的ttf文件名&quot; size:20.0]；</div></blockquote><h3>61、拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到</h3><pre><code>- (UIViewController *)getVisibleViewControllerFrom:(UIViewController*)vc {<br/>    if ([vc isKindOfClass:[UINavigationController class]]) {<br/>        return [self getVisibleViewControllerFrom:[((UINavigationController*) vc) visibleViewController]];<br/>    }else if ([vc isKindOfClass:[UITabBarController class]]){<br/>        return [self getVisibleViewControllerFrom:[((UITabBarController*) vc) selectedViewController]];<br/>    } else {<br/>        if (vc.presentedViewController) {<br/>            return [self getVisibleViewControllerFrom:vc.presentedViewController];<br/>        } else {<br/>            return vc;<br/>        }<br/>    }<br/>}</code></pre><h3>62、runtime为一个类动态添加属性</h3><pre><code>// 动态添加属性的本质是: 让对象的某个属性与值产生关联<br/>        objc_setAssociatedObject(self, WZBPlaceholderViewKey, placeholderView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</code></pre><h3>63、获取runtime为一个类动态添加的属性</h3><pre><code>objc_getAssociatedObject(self, WZBPlaceholderViewKey);</code></pre><h3>64、KVO监听某个对象的属性</h3><pre><code>// 添加监听者<br/>[self addObserver:self forKeyPath:property options:NSKeyValueObservingOptionNew context:nil];<br/><br/>// 当监听的属性值变化的时候会来到这个方法<br/>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {<br/>    if ([keyPath isEqualToString:@&quot;property&quot;]) {<br/>       [self textViewTextChange];<br/>       } else {<br/>     }<br/>}</code></pre><h3>65、Reachability判断网络状态</h3><pre><code>NetworkStatus status = [[Reachability reachabilityForInternetConnection] currentReachabilityStatus];<br/>    if (status == NotReachable) {<br/>        NSLog(@&quot;当前设备无网络&quot;);<br/>    }<br/>    if (status == ReachableViaWiFi) {<br/>        NSLog(@&quot;当前wifi网络&quot;);<br/>    }<br/>    if (status == ReachableViaWWAN) {<br/>        NSLog(@&quot;当前蜂窝移动网络&quot;);<br/>    }</code></pre><h3>66、AFNetworking监听网络状态</h3><pre><code>// 监听网络状况<br/>    AFNetworkReachabilityManager *mgr = [AFNetworkReachabilityManager sharedManager];<br/>    [mgr setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {<br/>        switch (status) {<br/>            case AFNetworkReachabilityStatusUnknown:<br/>                break;<br/>            case AFNetworkReachabilityStatusNotReachable: {<br/>                [SVProgressHUD showInfoWithStatus:@&quot;当前设备无网络&quot;];<br/>            }<br/>                break;<br/>            case AFNetworkReachabilityStatusReachableViaWiFi:<br/>                [SVProgressHUD showInfoWithStatus:@&quot;当前Wi-Fi网络&quot;];<br/>                break;<br/>            case AFNetworkReachabilityStatusReachableViaWWAN:<br/>                [SVProgressHUD showInfoWithStatus:@&quot;当前蜂窝移动网络&quot;];<br/>                break;<br/>            default:<br/>                break;<br/>        }<br/>    }];<br/>    [mgr startMonitoring];</code></pre><h3>67、透明颜色不影响子视图透明度</h3><pre><code>    [UIColor colorWithRed:&lt;#(CGFloat)#&gt; green:&lt;#(CGFloat)#&gt; blue:&lt;#(CGFloat)#&gt; alpha:&lt;#(CGFloat)#&gt;];</code></pre><h3>68、取图片某一点的颜色</h3><pre><code>    if (point.x &lt; 0 || point.y &lt; 0) return nil;<br/><br/>    CGImageRef imageRef = self.CGImage;<br/>    NSUInteger width = CGImageGetWidth(imageRef);<br/>    NSUInteger height = CGImageGetHeight(imageRef);<br/>    if (point.x &gt;= width || point.y &gt;= height) return nil;<br/><br/>    unsigned char *rawData = malloc(height * width * 4);<br/>    if (!rawData) return nil;<br/><br/>    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();<br/>    NSUInteger bytesPerPixel = 4;<br/>    NSUInteger bytesPerRow = bytesPerPixel * width;<br/>    NSUInteger bitsPerComponent = 8;<br/>    CGContextRef context = CGBitmapContextCreate(rawData,<br/>                                                 width,<br/>                                                 height,<br/>                                                 bitsPerComponent,<br/>                                                 bytesPerRow,<br/>                                                 colorSpace,<br/>                                                 kCGImageAlphaPremultipliedLast<br/>                                                 | kCGBitmapByteOrder32Big);<br/>    if (!context) {<br/>        free(rawData);<br/>        return nil;<br/>    }<br/>    CGColorSpaceRelease(colorSpace);<br/>    CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);<br/>    CGContextRelease(context);<br/><br/>    int byteIndex = (bytesPerRow * point.y) + point.x * bytesPerPixel;<br/>    CGFloat red   = (rawData[byteIndex]     * 1.0) / 255.0;<br/>    CGFloat green = (rawData[byteIndex + 1] * 1.0) / 255.0;<br/>    CGFloat blue  = (rawData[byteIndex + 2] * 1.0) / 255.0;<br/>    CGFloat alpha = (rawData[byteIndex + 3] * 1.0) / 255.0;<br/><br/>    UIColor *result = nil;<br/>    result = [UIColor colorWithRed:red green:green blue:blue alpha:alpha];<br/>    free(rawData);<br/>    return result;</code></pre><h3>69、判断该图片是否有透明度通道</h3><pre><code>  - (BOOL)hasAlphaChannel<br/>{<br/>    CGImageAlphaInfo alpha = CGImageGetAlphaInfo(self.CGImage);<br/>    return (alpha == kCGImageAlphaFirst ||<br/>            alpha == kCGImageAlphaLast ||<br/>            alpha == kCGImageAlphaPremultipliedFirst ||<br/>            alpha == kCGImageAlphaPremultipliedLast);<br/>}</code></pre><h3>70、获得灰度图</h3><pre><code>+ (UIImage*)covertToGrayImageFromImage:(UIImage*)sourceImage<br/>{<br/>    int width = sourceImage.size.width;<br/>    int height = sourceImage.size.height;<br/><br/>    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();<br/>    CGContextRef context = CGBitmapContextCreate (nil,width,height,8,0,colorSpace,kCGImageAlphaNone);<br/>    CGColorSpaceRelease(colorSpace);<br/><br/>    if (context == NULL) {<br/>        return nil;<br/>    }<br/><br/>    CGContextDrawImage(context,CGRectMake(0, 0, width, height), sourceImage.CGImage);<br/>    CGImageRef contextRef = CGBitmapContextCreateImage(context);<br/>    UIImage *grayImage = [UIImage imageWithCGImage:contextRef];<br/>    CGContextRelease(context);<br/>    CGImageRelease(contextRef);<br/><br/>    return grayImage;<br/>}</code></pre><h3>71、根据bundle中的文件名读取图片</h3><pre><code>   + (UIImage *)imageWithFileName:(NSString *)name {<br/>    NSString *extension = @&quot;png&quot;;<br/><br/>    NSArray *components = [name componentsSeparatedByString:@&quot;.&quot;];<br/>    if ([components count] &gt;= 2) {<br/>        NSUInteger lastIndex = components.count - 1;<br/>        extension = [components objectAtIndex:lastIndex];<br/><br/>        name = [name substringToIndex:(name.length-(extension.length+1))];<br/>    }<br/><br/>    // 如果为Retina屏幕且存在对应图片，则返回Retina图片，否则查找普通图片<br/>    if ([UIScreen mainScreen].scale == 2.0) {<br/>        name = [name stringByAppendingString:@&quot;@2x&quot;];<br/><br/>        NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension];<br/>        if (path != nil) {<br/>            return [UIImage imageWithContentsOfFile:path];<br/>        }<br/>    }<br/><br/>    if ([UIScreen mainScreen].scale == 3.0) {<br/>        name = [name stringByAppendingString:@&quot;@3x&quot;];<br/><br/>        NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension];<br/>        if (path != nil) {<br/>            return [UIImage imageWithContentsOfFile:path];<br/>        }<br/>    }<br/><br/>    NSString *path = [[NSBundle mainBundle] pathForResource:name ofType:extension];<br/>    if (path) {<br/>        return [UIImage imageWithContentsOfFile:path];<br/>    }<br/><br/>    return nil;<br/>}</code></pre><h3>72、合并两个图片</h3><pre><code>+ (UIImage*)mergeImage:(UIImage*)firstImage withImage:(UIImage*)secondImage {<br/>    CGImageRef firstImageRef = firstImage.CGImage;<br/>    CGFloat firstWidth = CGImageGetWidth(firstImageRef);<br/>    CGFloat firstHeight = CGImageGetHeight(firstImageRef);<br/>    CGImageRef secondImageRef = secondImage.CGImage;<br/>    CGFloat secondWidth = CGImageGetWidth(secondImageRef);<br/>    CGFloat secondHeight = CGImageGetHeight(secondImageRef);<br/>    CGSize mergedSize = CGSizeMake(MAX(firstWidth, secondWidth), MAX(firstHeight, secondHeight));<br/>    UIGraphicsBeginImageContext(mergedSize);<br/>    [firstImage drawInRect:CGRectMake(0, 0, firstWidth, firstHeight)];<br/>    [secondImage drawInRect:CGRectMake(0, 0, secondWidth, secondHeight)];<br/>    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();<br/>    UIGraphicsEndImageContext();<br/>    return image;<br/>}</code></pre><h3>73、根据bundle中的图片名创建imageview</h3><pre><code>+ (id)imageViewWithImageNamed:(NSString*)imageName<br/>{<br/>    return [[UIImageView alloc] initWithImage:[UIImage imageNamed:imageName]];<br/>}</code></pre><h3>74、为imageView添加倒影</h3><pre><code>    CGRect frame = self.frame;<br/>    frame.origin.y += (frame.size.height + 1);<br/><br/>    UIImageView *reflectionImageView = [[UIImageView alloc] initWithFrame:frame];<br/>    self.clipsToBounds = TRUE;<br/>    reflectionImageView.contentMode = self.contentMode;<br/>    [reflectionImageView setImage:self.image];<br/>    reflectionImageView.transform = CGAffineTransformMakeScale(1.0, -1.0);<br/><br/>    CALayer *reflectionLayer = [reflectionImageView layer];<br/><br/>    CAGradientLayer *gradientLayer = [CAGradientLayer layer];<br/>    gradientLayer.bounds = reflectionLayer.bounds;<br/>    gradientLayer.position = CGPointMake(reflectionLayer.bounds.size.width / 2, reflectionLayer.bounds.size.height * 0.5);<br/>    gradientLayer.colors = [NSArray arrayWithObjects:<br/>                            (id)[[UIColor clearColor] CGColor],<br/>                            (id)[[UIColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:0.3] CGColor], nil];<br/><br/>    gradientLayer.startPoint = CGPointMake(0.5,0.5);<br/>    gradientLayer.endPoint = CGPointMake(0.5,1.0);<br/>    reflectionLayer.mask = gradientLayer;<br/><br/>    [self.superview addSubview:reflectionImageView];</code></pre><h3>75、画水印</h3><pre><code>// 画水印<br/>- (void) setImage:(UIImage *)image withWaterMark:(UIImage *)mark inRect:(CGRect)rect<br/>{<br/>    if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 4.0)<br/>    {<br/>        UIGraphicsBeginImageContextWithOptions(self.frame.size, NO, 0.0);<br/>    }<br/>    //原图<br/>    [image drawInRect:self.bounds];<br/>    //水印图<br/>    [mark drawInRect:rect];<br/>    UIImage *newPic = UIGraphicsGetImageFromCurrentImageContext();<br/>    UIGraphicsEndImageContext();<br/>    self.image = newPic;<br/>}</code></pre><h3>76、让label的文字内容显示在左上／右上／左下／右下／中心顶／中心底部</h3><pre><code>自定义UILabel<br/>// 重写label的textRectForBounds方法<br/>- (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines {<br/>    CGRect rect = [super textRectForBounds:bounds limitedToNumberOfLines:numberOfLines];<br/>    switch (self.textAlignmentType) {<br/>        case WZBTextAlignmentTypeLeftTop: {<br/>            rect.origin = bounds.origin;<br/>        }<br/>            break;<br/>        case WZBTextAlignmentTypeRightTop: {<br/>            rect.origin = CGPointMake(CGRectGetMaxX(bounds) - rect.size.width, bounds.origin.y);<br/>        }<br/>            break;<br/>        case WZBTextAlignmentTypeLeftBottom: {<br/>            rect.origin = CGPointMake(bounds.origin.x, CGRectGetMaxY(bounds) - rect.size.height);<br/>        }<br/>            break;<br/>        case WZBTextAlignmentTypeRightBottom: {<br/>            rect.origin = CGPointMake(CGRectGetMaxX(bounds) - rect.size.width, CGRectGetMaxY(bounds) - rect.size.height);<br/>        }<br/>            break;<br/>        case WZBTextAlignmentTypeTopCenter: {<br/>            rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, CGRectGetMaxY(bounds) - rect.origin.y);<br/>        }<br/>            break;<br/>        case WZBTextAlignmentTypeBottomCenter: {<br/>            rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, CGRectGetMaxY(bounds) - CGRectGetMaxY(bounds) - rect.size.height);<br/>        }<br/>            break;<br/>        case WZBTextAlignmentTypeLeft: {<br/>            rect.origin = CGPointMake(0, rect.origin.y);<br/>        }<br/>            break;<br/>        case WZBTextAlignmentTypeRight: {<br/>            rect.origin = CGPointMake(rect.origin.x, 0);<br/>        }<br/>            break;<br/>        case WZBTextAlignmentTypeCenter: {<br/>            rect.origin = CGPointMake((CGRectGetWidth(bounds) - CGRectGetWidth(rect)) / 2, (CGRectGetHeight(bounds) - CGRectGetHeight(rect)) / 2);<br/>        }<br/>            break;<br/><br/>        default:<br/>            break;<br/>    }<br/>    return rect;<br/>}<br/>- (void)drawTextInRect:(CGRect)rect {<br/>    CGRect textRect = [self textRectForBounds:rect limitedToNumberOfLines:self.numberOfLines];<br/>    [super drawTextInRect:textRect];<br/>}</code></pre><h3>77、scrollView上的输入框，键盘挡住的问题</h3><pre><code>推荐用IQKeyboardManager这个框架！<br/>手动解决如下<br/>1、监听键盘弹出／消失的通知<br/>2、在通知中加入代码：<br/>NSDictionary* info = [aNotification userInfo];<br/>CGRect keyPadFrame=[[UIApplication sharedApplication].keyWindow convertRect:[[info objectForKey:UIKeyboardFrameBeginUserInfoKey] CGRectValue] fromView:self.view];<br/>CGSize kbSize =keyPadFrame.size;<br/>CGRect activeRect=[self.view convertRect:activeField.frame fromView:activeField.superview];<br/>CGRect aRect = self.view.bounds;<br/>aRect.size.height -= (kbSize.height);<br/><br/>CGPoint origin =  activeRect.origin;<br/>origin.y -= backScrollView.contentOffset.y;<br/>if (!CGRectContainsPoint(aRect, origin)) {<br/>    CGPoint scrollPoint = CGPointMake(0.0,CGRectGetMaxY(activeRect)-(aRect.size.height));<br/>    [backScrollView setContentOffset:scrollPoint animated:YES];<br/>}</code></pre><h3>78、frame布局的cell动态高度</h3><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这种通常在你的模型中添加一个辅助属性cellHeight，在模型中重写这个属性的get方法，根据你的布局和模型中的其他属性值计算出总高度。最后在tableView：heightForRow方法中，根据indexPath找出对应的模型，返回这个高度即可。</span></div></blockquote><h3>79、AutoLayout布局的cell动态高度</h3><pre><code>// 1、设置tableView的属性<br/>self.tableView.rowHeight = UITableViewAutomaticDimension;<br/>self.tableView.estimatedRowHeight = 44.0; // 这个属性非0，估计cell高度</code></pre><pre><code>// 2、至上而下设置cell的约束，注意，上下左右最好都要顶到cell的四周</code></pre><div><img src="稀土掘金  (二十九) iOS常用代码总结一_files/222.png" type="image/png" data-filename="222.png"/><br/></div><div><br/></div><h3>80、使用performSelector:调用函数，内存泄漏问题</h3><blockquote><div>当我们在开发中使用[obj performSelector:NSSelectorFromString(@&quot;aMethod&quot;)];这类方法时可能会收到一个警告&quot;performSelector may cause a leak because its selector is unknown&quot;.</div><div>是因为编译器不清楚这个对象能不能相应这个方法，如果不能，则是不安全的，而且编译器也不清楚该怎么处理这个方法的返回值！</div></blockquote><pre><code>使用以下代码调用即可：<br/>if (! obj) { return; }<br/>SEL selector = NSSelectorFromString(@&quot;aMethod&quot;);<br/>IMP imp = [obj methodForSelector:selector];<br/>void (*func)(id, SEL) = (void *)imp;<br/>func(obj, selector);<br/><br/>或者：<br/>SEL selector = NSSelectorFromString(@&quot;aMethod&quot;);<br/>((void (*)(id, SEL))[obj methodForSelector:selector])(obj, selector);</code></pre><h3>81、一个字符串是否包含另一个字符串</h3><pre><code>// 方法1<br/>if ([str1 containsString:str2]) {<br/>        NSLog(@&quot;str1包含str2&quot;);<br/>    } else {<br/>        NSLog(@&quot;str1不包含str2&quot;);<br/>    }<br/><br/>// 方法2<br/>if ([str1 rangeOfString: str2].location == NSNotFound) {<br/>        NSLog(@&quot;str1不包含str2&quot;);<br/>    } else {<br/>        NSLog(@&quot;str1包含str2&quot;);<br/>    }</code></pre><h3>82、cell去除选中效果</h3><pre><code>cell.selectionStyle = UITableViewCellSelectionStyleNone;</code></pre><h3>83、cell点按效果</h3><pre><code>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {<br/>    [tableView deselectRowAtIndexPath:indexPath animated:YES];<br/>}</code></pre><h3>84、当删除一个从xib拖出来的属性时，一定记得把xib中对应的线也删掉，不然会报类似[&lt;ViewController 0x7fea6ed05980&gt; setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key的crash</h3><div><img src="稀土掘金  (二十九) iOS常用代码总结一_files/333.png" type="image/png" data-filename="333.png"/><br/></div><div><br/></div><div><br/></div><div>点击这个叉号删除</div><h3>85、真机测试的时候报错：Could not launch &quot;你的 App&quot;，process launch failed: Security</h3><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">因为你的app没有上线，iOS9开始，需要手动信任Xcode生成的描述文件，打开手机设置-&gt;通用-&gt;描述文件-&gt;点击你的app的描述文件-&gt;点击信任</span></div></blockquote><h3>86、真机测试的时候报错：Could not find Developer Disk Image</h3><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这是因为你的设备系统版本大于Xcode能兼容的系统版本，比如你的设备是iOS10.3，而Xcode版本是8.2（Xcode8.2最大兼容iOS10.2），就会报这个错误。解决办法就是升级Xcode！</span></div></blockquote><h3>87、UITextView没有placeholder的问题？</h3><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">网上有很多此类自定义控件，也可以参考下我写的一个UITextView分类 </span><a href="https://github.com/WZBbiao/UITextView-WZB" style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">UITextView-WZB</a></div></blockquote><h3>88、移除字符串中的空格和换行</h3><pre><code>+ (NSString *)removeSpaceAndNewline:(NSString *)str {<br/>    NSString *temp = [str stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];<br/>    temp = [temp stringByReplacingOccurrencesOfString:@&quot;\r&quot; withString:@&quot;&quot;];<br/>    temp = [temp stringByReplacingOccurrencesOfString:@&quot;\n&quot; withString:@&quot;&quot;];<br/>    return temp;<br/>}</code></pre><h3>89、判断字符串中是否有空格</h3><pre><code>+ (BOOL)isBlank:(NSString *)str {<br/>    NSRange _range = [str rangeOfString:@&quot; &quot;];<br/>    if (_range.location != NSNotFound) {<br/>        //有空格<br/>        return YES;<br/>    } else {<br/>        //没有空格<br/>        return NO;<br/>    }<br/>}</code></pre><h3>90、获取一个视频的第一帧图片</h3><pre><code>    NSURL *url = [NSURL URLWithString:filepath];<br/>    AVURLAsset *asset1 = [[AVURLAsset alloc] initWithURL:url options:nil];<br/>    AVAssetImageGenerator *generate1 = [[AVAssetImageGenerator alloc] initWithAsset:asset1];<br/>    generate1.appliesPreferredTrackTransform = YES;<br/>    NSError *err = NULL;<br/>    CMTime time = CMTimeMake(1, 2);<br/>    CGImageRef oneRef = [generate1 copyCGImageAtTime:time actualTime:NULL error:&amp;err];<br/>    UIImage *one = [[UIImage alloc] initWithCGImage:oneRef];<br/><br/>    return one;</code></pre><h3>91、获取视频的时长</h3><pre><code>+ (NSInteger)getVideoTimeByUrlString:(NSString *)urlString {<br/>    NSURL *videoUrl = [NSURL URLWithString:urlString];<br/>    AVURLAsset *avUrl = [AVURLAsset assetWithURL:videoUrl];<br/>    CMTime time = [avUrl duration];<br/>    int seconds = ceil(time.value/time.timescale);<br/>    return seconds;<br/>}</code></pre><h3>92、字符串是否为空</h3><pre><code>+ (BOOL)isEqualToNil:(NSString *)str {<br/>    return str.length &lt;= 0 || [str isEqualToString:@&quot;&quot;] || !str;<br/>}</code></pre><h3>93、将app上传到App Store的时候通常会遇到这个问题</h3><div><img src="稀土掘金  (二十九) iOS常用代码总结一_files/444.png" type="image/png" data-filename="444.png"/><br/></div><div>try again</div><blockquote><div>很多人说这事苹果爸爸服务器问题，重复尝试几次，总会成功的！</div><div>但是经过尝试发现如果使用Application Loader上传成功率就非常高，所以还是推荐把ipa文件导出直接用Application Loader上传。</div><div>如果Application Loader也不行，需要检查下自己的网络，有时候vpn也会提高速度。</div></blockquote><h3>94、当tableView占不满一屏时，去除下边多余的单元格</h3><pre><code>self.tableView.tableHeaderView = [UIView new];<br/>self.tableView.tableFooterView = [UIView new];</code></pre><h3>95、isKindOfClass和isMemberOfClass的区别</h3><pre><code>isKindOfClass可以判断某个对象是否属于某个类，或者这个类的子类。<br/>isMemberOfClass更加精准，它只能判断这个对象类型是否为这个类(不能判断子类)</code></pre><h3>96、__block</h3><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">当一个局部变量需要在block里改变时，需要在定义时加上__block修饰，具体请看官方文档 </span><a href="http://developer.apple.com/library/ios/documentation/cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW6" style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">http://developer.apple.com/library/ios/documentation/cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW6</a></div></blockquote><h3>97、-[ViewController aMethod:]: unrecognized selector sent to instance 0x7fe91e607fb0</h3><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这是一个经典错误，ViewController不能响应aMethod这个方法，错误原因可能viewController文件中没有实现aMethod这个方法</span></div></blockquote><h3>98、UITableView (&lt;UITableView: 0x7ff19b027000; &gt;) failed to obtain a cell from its dataSource (&lt;ViewController: 0x7ff19a507520&gt;)</h3><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这个错误原因是tableView的代理方法-tableView:cellForRowAtIndexPath:需要返回一个UITableViewCell,而你返回了一个nil。另外这个地方返回值不是UITableViewCell类型也会导致崩溃</span></div></blockquote><h3>99、约束如何做UIView动画？</h3><pre><code>1、把需要改的约束Constraint拖条线出来，成为属性<br/>2、在需要动画的地方加入代码，改变此属性的constant属性<br/>3、开始做UIView动画，动画里边调用layoutIfNeeded方法<br/><br/>@property (weak, nonatomic) IBOutlet NSLayoutConstraint *buttonTopConstraint;<br/>self.buttonTopConstraint.constant = 100;<br/>    [UIView animateWithDuration:.5 animations:^{<br/>        [self.view layoutIfNeeded];<br/>    }];</code></pre><h3>100、从NSURL中拿到链接字符串</h3><pre><code>NSString *urlString = myURL.absoluteString;</code></pre><h3>101、将tableView滚动到顶部</h3><pre><code>[tableView setContentOffset:CGPointZero animated:YES];<br/>或者<br/>[tableView scrollRectToVisible:CGRectMake(0, 0, 1, 1) animated:YES];</code></pre><h3>102、如果用addTarget:action:forControlEvents:方法为一个button添加了很多点击事件，在某个时刻想一次删除怎么办？只需要调用下边这句代码</h3><pre><code>[youButton removeTarget:nil action:nil forControlEvents:UIControlEventAllEvents];</code></pre><h3>103、某个字体的高度</h3><pre><code>font.lineHeight;</code></pre><h3>104、删除某个view所有的子视图</h3><pre><code>[[someView subviews]<br/> makeObjectsPerformSelector:@selector(removeFromSuperview)];</code></pre><h3>105、删除NSUserDefaults所有记录</h3><pre><code>//方法一<br/>  NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];<br/> [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];   <br/> //方法二  <br/>- (void)resetDefaults {   <br/>  NSUserDefaults * defs = [NSUserDefaults standardUserDefaults];<br/>     NSDictionary * dict = [defs dictionaryRepresentation];<br/>     for (id key in dict) {<br/>          [defs removeObjectForKey:key];<br/>     }<br/>      [defs synchronize];<br/> }<br/>// 方法三<br/>[[NSUserDefaults standardUserDefaults] setPersistentDomain:[NSDictionary dictionary] forName:[[NSBundle mainBundle] bundleIdentifier]];</code></pre><h3>106、禁用系统滑动返回功能</h3><pre><code>- (void)viewDidAppear:(BOOL)animated<br/>{<br/>     [super viewDidAppear:animated];<br/>if ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) {self.navigationController.interactivePopGestureRecognizer.delegate = self;<br/>    }<br/>}<br/><br/>- (void)viewWillDisappear:(BOOL)animated {<br/>    [super viewWillDisappear:animated];<br/>    if ([self.navigationController respondsToSelector:@selector(interactivePopGestureRecognizer)]) {self.navigationController.interactivePopGestureRecognizer.delegate = nil;<br/>    }<br/>}<br/>- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer<br/>{<br/>     return NO;<br/>}</code></pre><h3>107、模拟器报错</h3><div><br/></div><div><img src="稀土掘金  (二十九) iOS常用代码总结一_files/555.png" type="image/png" data-filename="555.png"/><br/></div><div><br/></div><div>模拟器报错</div><blockquote><div>解决办法：</div><div>打开模拟器-&gt;Simulator-&gt;Reset Content and Settings...</div><div>如果不行，就重启试试！</div></blockquote><h3>108、自定义cell选中背景颜色</h3><pre><code>UIView *bgColorView = [[UIView alloc] init];<br/>bgColorView.backgroundColor = [UIColor redColor];<br/>[cell setSelectedBackgroundView:bgColorView];</code></pre><h3>109、UILabel设置内边距</h3><pre><code>子类化UILabel，重写drawTextInRect方法<br/>- (void)drawTextInRect:(CGRect)rect {<br/>    // 边距，上左下右<br/>    UIEdgeInsets insets = {0, 5, 0, 5};<br/>    [super drawTextInRect:UIEdgeInsetsInsetRect(rect, insets)];<br/>}</code></pre><h3>110、UILabel设置文字描边</h3><pre><code>子类化UILabel，重写drawTextInRect方法<br/>- (void)drawTextInRect:(CGRect)rect<br/>{<br/>    CGContextRef c = UIGraphicsGetCurrentContext();<br/>    // 设置描边宽度<br/>    CGContextSetLineWidth(c, 1);<br/>    CGContextSetLineJoin(c, kCGLineJoinRound);<br/>    CGContextSetTextDrawingMode(c, kCGTextStroke);<br/>    // 描边颜色<br/>    self.textColor = [UIColor redColor];<br/>    [super drawTextInRect:rect];<br/>    // 文本颜色<br/>    self.textColor = [UIColor yellowColor];<br/>    CGContextSetTextDrawingMode(c, kCGTextFill);<br/>    [super drawTextInRect:rect];<br/>}</code></pre><h3>111、使用模拟器截图</h3><blockquote><div>快捷键command + s</div><div>或者File-&gt;Save Screen Shot</div></blockquote><h3>112、scrollView滚动到最下边</h3><pre><code>CGPoint bottomOffset = CGPointMake(0, scrollView.contentSize.height - scrollView.bounds.size.height);<br/>[scrollView setContentOffset:bottomOffset animated:YES];</code></pre><h3>113、UIView背景颜色渐变</h3><pre><code>    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 320, 100)];<br/>    [self.view addSubview:view];<br/>    CAGradientLayer *gradient = [CAGradientLayer layer];<br/>    gradient.frame = view.bounds;<br/>    gradient.colors = [NSArray arrayWithObjects:(id)[[UIColor blackColor] CGColor], (id)[[UIColor whiteColor] CGColor], nil];<br/>    [view.layer insertSublayer:gradient atIndex:0];</code></pre><h3>114、停止UIView动画</h3><pre><code>[yourView.layer removeAllAnimations]</code></pre><h3>115、为UIView某个角添加圆角</h3><pre><code>// 左上角和右下角添加圆角<br/>UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:view.bounds byRoundingCorners:(UIRectCornerTopLeft | UIRectCornerBottomRight) cornerRadii:CGSizeMake(20, 20)];<br/>    CAShapeLayer *maskLayer = [CAShapeLayer layer];<br/>    maskLayer.frame = view.bounds;<br/>    maskLayer.path = maskPath.CGPath;<br/>    view.layer.mask = maskLayer;</code></pre><h3>116、删除Xcode Derived data缓存数据</h3><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">依次点击Xcode -&gt; Preferences -&gt; location，然后点击 Derived data路径后到小箭头，删除这个文件夹下的数据就可以了，如图</span></div><div><br/></div><div><img src="稀土掘金  (二十九) iOS常用代码总结一_files/666.png" type="image/png" data-filename="666.png"/><br/></div><div>Xcode Derived data</div></blockquote><h3>117、将一个view放置在其兄弟视图的最上面</h3><pre><code>[parentView bringSubviewToFront:yourView]</code></pre><h3>118、将一个view放置在其兄弟视图的最下面</h3><pre><code>[parentView sendSubviewToBack:yourView]</code></pre><h3>119、让手机震动一下</h3><pre><code>倒入框架<br/>#import &lt;AudioToolbox/AudioToolbox.h&gt;<br/>AudioServicesPlayAlertSound(kSystemSoundID_Vibrate);<br/>或者<br/>AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);</code></pre><h3>120、layoutSubviews方法什么时候调用？</h3><blockquote><div>1、init方法不会调用</div><div>2、addSubview方法等时候会调用</div><div>3、bounds改变的时候调用</div><div>4、scrollView滚动的时候会调用scrollView的layoutSubviews方法(所以不建议在scrollView的layoutSubviews方法中做复杂逻辑)</div><div>5、旋转设备的时候调用</div><div>6、子视图被移除的时候调用</div><div>参考请看：<a href="http://blog.logichigh.com/2011/03/16/when-does-layoutsubviews-get-called/">http://blog.logichigh.com/2011/03/16/when-does-layoutsubviews-get-called/</a></div></blockquote><h3>121、让UILabel在指定的地方换行</h3><pre><code>// 换行符为\n,在需要换行的地方加上这个符号即可，如 <br/>label.numberOfLines = 0;<br/>label.text = @&quot;此处\n换行&quot;;</code></pre><h3>122、摇一摇功能</h3><pre><code>1、打开摇一摇功能<br/>    [UIApplication sharedApplication].applicationSupportsShakeToEdit = YES;<br/>2、让需要摇动的控制器成为第一响应者<br/>[self becomeFirstResponder];<br/>3、实现以下方法<br/><br/>// 开始摇动<br/>- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event<br/>// 取消摇动<br/>- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event<br/>// 摇动结束<br/>- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event</code></pre><h3>123、获取图片大小</h3><pre><code>CGFloat imageWidth = image.size.width;<br/>    CGFloat imageHeight = imageWidth * image.scale;</code></pre><h3>124、获取view的坐标在整个window上的位置</h3><pre><code>// v上的(0, 0)点在toView上的位置<br/>CGPoint point = [v convertPoint:CGPointMake(0, 0) toView:[UIApplication sharedApplication].windows.lastObject];<br/>或者<br/>CGPoint point = [v.superview convertPoint:v.frame.origin toView:[UIApplication sharedApplication].windows.lastObject];</code></pre><h3>125、提交App Store审核程序限制</h3><blockquote><div>您的应用程序的未压缩大小必须小于4GB。每个Mach-O可执行文件（例如app_name.app/app_name）不能超过这些限制：</div><div>对于MinimumOSVersion小于7.0的应用程序：<span style="font-weight: bold;">TEXT二进制文件中所有部分的总数最多为80 MB 。</span></div><div><span style="font-weight: bold;">对于MinimumOSVersion7.x到8.x的应用程序：</span>TEXT对于二进制文件中每个体系结构片段的每个片段，最大为60 MB 。</div><div>对于MinimumOSVersion9.0或更高版本的应用程序：__TEXT二进制文件中所有部分的总数最多为500 MB 。参阅：<a href="https://developer.apple.com/library/content/documentation/LanguagesUtilities/Conceptual/iTunesConnect_Guide/Chapters/SubmittingTheApp.html">iTunes Connect开发者指南</a></div></blockquote><h3>126、修改UISegmentedControl的字体大小</h3><pre><code>[segment setTitleTextAttributes:@{NSFontAttributeName : [UIFont systemFontOfSize:15.0f]} forState:UIControlStateNormal];</code></pre><h3>127、在非ViewController的地方弹出UIAlertController对话框</h3><pre><code>//  最好抽成一个分类<br/>UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;Title&quot; message:@&quot;message&quot; preferredStyle:UIAlertControllerStyleAlert];<br/>//...<br/>id rootViewController = [UIApplication sharedApplication].delegate.window.rootViewController;<br/>if([rootViewController isKindOfClass:[UINavigationController class]])<br/>{<br/>    rootViewController = ((UINavigationController *)rootViewController).viewControllers.firstObject;<br/>}<br/>if([rootViewController isKindOfClass:[UITabBarController class]])<br/>{<br/>    rootViewController = ((UITabBarController *)rootViewController).selectedViewController;<br/>}<br/>[rootViewController presentViewController:alertController animated:YES completion:nil];</code></pre><h3>128、获取一个view所属的控制器</h3><pre><code>// view分类方法<br/>- (UIViewController *)belongViewController {<br/>    for (UIView *next = [self superview]; next; next = next.superview) {<br/>        UIResponder* nextResponder = [next nextResponder];<br/>        if ([nextResponder isKindOfClass:[UIViewController class]]) {<br/>            return (UIViewController *)nextResponder;<br/>        }<br/>    }<br/>    return nil;<br/>}</code></pre><h3>129、UIImage和base64互转</h3><pre><code>// view分类方法<br/>- (NSString *)encodeToBase64String:(UIImage *)image {<br/> return [UIImagePNGRepresentation(image) base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];<br/>}<br/><br/>- (UIImage *)decodeBase64ToImage:(NSString *)strEncodeData {<br/>  NSData *data = [[NSData alloc]initWithBase64EncodedString:strEncodeData options:NSDataBase64DecodingIgnoreUnknownCharacters];<br/>  return [UIImage imageWithData:data];<br/>}</code></pre><h3>130、UIWebView设置背景透明</h3><pre><code>[webView setBackgroundColor:[UIColor clearColor]];<br/>[webView setOpaque:NO];</code></pre><h3>131、判断NSDate是不是今天</h3><pre><code>NSDateComponents *otherDay = [[NSCalendar currentCalendar] components:NSCalendarUnitEra | NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay fromDate:aDate];<br/>NSDateComponents *today = [[NSCalendar currentCalendar] components:NSCalendarUnitEra | NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay fromDate:[NSDate date]];<br/>if([today day] == [otherDay day] &amp;&amp;<br/>   [today month] == [otherDay month] &amp;&amp;<br/>   [today year] == [otherDay year] &amp;&amp;<br/>   [today era] == [otherDay era]) {<br/>    // 是今天<br/>}</code></pre><h3>132、设置tableView分割线颜色</h3><pre><code>[self.tableView setSeparatorColor:[UIColor myColor]];</code></pre><h3>133、设置屏幕方向</h3><pre><code> NSNumber *orientationTarget = [NSNumber numberWithInt:UIInterfaceOrientationLandscapeLeft];<br/>[[UIDevice currentDevice] setValue:orientationTarget forKey:@&quot;orientation&quot;];<br/>[UIViewController attemptRotationToDeviceOrientation];</code></pre><h3>134、比较两个颜色是否相等</h3><pre><code>- (BOOL)isEqualToColor:(UIColor *)otherColor {<br/>    CGColorSpaceRef colorSpaceRGB = CGColorSpaceCreateDeviceRGB();<br/><br/>    UIColor *(^convertColorToRGBSpace)(UIColor*) = ^(UIColor *color) {<br/>        if (CGColorSpaceGetModel(CGColorGetColorSpace(color.CGColor)) == kCGColorSpaceModelMonochrome) {<br/>            const CGFloat *oldComponents = CGColorGetComponents(color.CGColor);<br/>            CGFloat components[4] = {oldComponents[0], oldComponents[0], oldComponents[0], oldComponents[1]};<br/>            CGColorRef colorRef = CGColorCreate( colorSpaceRGB, components );<br/><br/>            UIColor *color = [UIColor colorWithCGColor:colorRef];<br/>            CGColorRelease(colorRef);<br/>            return color;            <br/>        } else<br/>            return color;<br/>    };<br/><br/>    UIColor *selfColor = convertColorToRGBSpace(self);<br/>    otherColor = convertColorToRGBSpace(otherColor);<br/>    CGColorSpaceRelease(colorSpaceRGB);<br/><br/>    return [selfColor isEqual:otherColor];<br/>}</code></pre><h3>135、tableViewCell分割线顶到头</h3><pre><code>- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath {<br/>    [cell setSeparatorInset:UIEdgeInsetsZero];<br/>    [cell setLayoutMargins:UIEdgeInsetsZero];<br/>    cell.preservesSuperviewLayoutMargins = NO;<br/>}<br/><br/>- (void)viewDidLayoutSubviews {<br/>    [self.tableView setSeparatorInset:UIEdgeInsetsZero];<br/>    [self.tableView setLayoutMargins:UIEdgeInsetsZero];<br/>}</code></pre><h3>136、不让控制器的view随着控制器的xib拉伸或压缩</h3><pre><code>self.view.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;</code></pre><h3>137、cocoaPods报错 : [!] Unable to add a source with url <a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a> named master-1.</h3><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">You can try adding it manually in ~/.cocoapods/repos or via pod repo add.</span></div><blockquote><div>解决方法：这是因为电脑里安装了另外一个Xcode导致cocoapods找不到路径了</div><div>在终端执行 sudo xcode-select -switch /Applications/Xcode.app 即可</div></blockquote><h3>138、安装cocoapods的时候出现 ERROR: While executing gem ... (Errno::EPERM)</h3><pre><code>Operation not permitted - /usr/bin/pod</code></pre><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">解决办法：直接在终端执行 sudo gem install -n /usr/local/bin cocoapods</span></div></blockquote><h3>139、在状态栏增加网络请求的菊花，类似safari加载网页的时候状态栏菊花</h3><pre><code>[UIApplication sharedApplication].networkActivityIndicatorVisible = YES;</code></pre><h3>140、检查一个rect是否包含一个point</h3><pre><code>// point是否在rect内<br/>BOOL isContains = CGRectContainsPoint(rect, point);</code></pre><h3>141、在指定的宽度下，让UILabel自动设置最佳font</h3><pre><code>label.adjustsFontSizeToFitWidth = YES;</code></pre><h3>142、将一个image保存在相册中</h3><pre><code>UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil);<br/><br/>或者<br/>#import &lt;Photos/Photos.h&gt;<br/>[[PHPhotoLibrary sharedPhotoLibrary] performChanges:^{<br/>        PHAssetChangeRequest *changeRequest = [PHAssetChangeRequest creationRequestForAssetFromImage:image];<br/>        changeRequest.creationDate          = [NSDate date];<br/>    } completionHandler:^(BOOL success, NSError *error) {<br/>        if (success) {<br/>            NSLog(@&quot;successfully saved&quot;);<br/>        }<br/>        else {<br/>            NSLog(@&quot;error saving to photos: %@&quot;, error);<br/>        }<br/>    }];</code></pre><h3>143、修改cell.imageView的大小</h3><pre><code>UIImage *icon = [UIImage imageNamed:@&quot;&quot;];<br/>CGSize itemSize = CGSizeMake(30, 30);<br/>UIGraphicsBeginImageContextWithOptions(itemSize, NO ,0.0);<br/>CGRect imageRect = CGRectMake(0.0, 0.0, itemSize.width, itemSize.height);<br/>[icon drawInRect:imageRect];<br/>cell.imageView.image = UIGraphicsGetImageFromCurrentImageContext();<br/>UIGraphicsEndImageContext();</code></pre><h3>144、为一个view添加虚线边框</h3><pre><code> CAShapeLayer *border = [CAShapeLayer layer];<br/>    border.strokeColor = [UIColor colorWithRed:67/255.0f green:37/255.0f blue:83/255.0f alpha:1].CGColor;<br/>    border.fillColor = nil;<br/>    border.lineDashPattern = @[@4, @2];<br/>    border.path = [UIBezierPath bezierPathWithRect:view.bounds].CGPath;<br/>    border.frame = view.bounds;<br/>    [view.layer addSublayer:border];</code></pre><h3>145、UITextView中打开或禁用复制，剪切，选择，全选等功能</h3><pre><code>// 继承UITextView重写这个方法<br/>- (BOOL)canPerformAction:(SEL)action withSender:(id)sender<br/>{<br/>// 返回NO为禁用，YES为开启<br/>    // 粘贴<br/>    if (action == @selector(paste:)) return NO;<br/>    // 剪切<br/>    if (action == @selector(cut:)) return NO;<br/>    // 复制<br/>    if (action == @selector(copy:)) return NO;<br/>    // 选择<br/>    if (action == @selector(select:)) return NO;<br/>    // 选中全部<br/>    if (action == @selector(selectAll:)) return NO;<br/>    // 删除<br/>    if (action == @selector(delete:)) return NO;<br/>    // 分享<br/>    if (action == @selector(share)) return NO;<br/>    return [super canPerformAction:action withSender:sender];<br/>}</code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: SimSun; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%; font-weight: bold;">笔记整理：Edison</span></div><div style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: SimSun; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em; border-width: 100%; font-weight: bold; color: rgb(79, 129, 189); unicode-bidi: embed;">联系方式：QQ：277593 （笔记意见建议可加此Q，专人更新此笔记）；</span></div><div style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: SimSun; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em; border-width: 100%; color: rgb(79, 129, 189); unicode-bidi: embed;"> </span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: SimSun; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%; font-weight: bold;">注：小道途径获取到的笔记，无法自动更新，请谅解！(笔记平均每月更新一次，祝各位都能拿到心仪的offer)</span><span style="direction: ltr; font-family: SimSun; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%;"> </span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"/></div></span>
</div></body></html> 