<html>
<head>
  <title>面试  (十六) :2018-iOS笔试题&lt;一&gt;</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="391"/>
<h1>面试  (十六) :2018-iOS笔试题&lt;一&gt;</h1>

<div><span><h2>import””, import&lt;&gt;, 的区别</h2><div>1· #import和#include的区别：</div><div>import不会引发交叉编译，include会</div><div>#import&lt;&gt;和#import“”的区别：</div><div>import&lt;&gt;引用系统文件，对于系统自带头文件的饮用</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">import“”</span><span style="-en-paragraph: true;">引用自定义文件，首先会在用户目录下查找</span></div><h2>视图相关</h2><div>1· 没有navigationController的情况下，从一个viewController切换到另一个viewController的方法是：</div><div>[self presentModalViewController:nextViewController animated:YES]</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">pushViewController</span><span style="-en-paragraph: true;">需要有navigationController</span></div><hr/><div>2· UISplitViewController控制器可以呈现屏幕分栏视图的效果，MasterView占有320点的固定大小。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: B</span></div><div>A 是</div><div>B 否 </div><div>解释：</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">ios8 sdk 中 ，UISplitViewController 可以在 iphone 中 使用 了，masterView 的 宽度 是 整个 屏幕的 宽度，所以 不是 固定的 大小 320</span></div><hr/><div>3· iOS中导航设计模式有几种？</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: A B C 你的答案: A B C D (错误)</span></div><div>A 平铺导航</div><div>B 标签导航</div><div>C 树形导航</div><div>D 模态视图导航</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释：</span></div><div>我们经常会遇到在某个路径中滑出一个单屏、进行编辑、查看信息、操作界面的上的内容的情况发生。这是一种应用行为的特定形态，一般带有流程的界面变更的情况发生，比如一张页面临时取代了整个应用程序的显示屏，我们称这种处理方式为“模态视图”。默认情况下，模式视图从屏幕底部边缘滑上来切一半覆盖了当前整个屏幕,模态视图完成和程序主功能有关系的独立任务，尤其适合于主功能界面中欠缺的多级子任务。这种操作会暂时绕开应用的正常操作。</div><div><br/></div><div>模态视图常常被用来编辑或添加内容，当你需要的时候模态视图一般从屏幕底部滑出而后遮盖先前的页面，当你完成任务后滑出的页面也会相应的缩回去，然后可以继续之前的流程。有些控件和界面元素只在次要任务中被偶尔用到，模态视图很好的把他们暂时隐藏了，并且当需要的时候出现，有效的节约了屏幕空间。</div><div><br/></div><div>模态视图有点像是导航中的死胡同，为了能够让用户也可以同样方便的回到正常的流程中去，模态视图除了正常的操作之外一般还有加上一个“完成”按钮，或者“取消”按钮。</div><hr/><div>4· 模态视图专用属性有哪些？</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: A B C D</span></div><div>A UIModalPresentationFullScreen，全屏状态，是默认呈现样式，iPhone只能全屏呈现。</div><div>B UIModalPresentationPageSheet，它的宽度是固定的768点，在iPad竖屏情况下则全屏呈现。</div><div>C UIModalPresentationFormSheet，它的是固定的540x620点，无论是横屏还是竖屏情况下呈现尺寸都不会变化。</div><div>D UIModalPresentationCurrentContext，它与父视图控制器有相同的呈现方式。 </div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释：</span></div><div>作用：</div><div>临时中断当前工作流程，显示一个新的视图层次结构。</div><div>用途：</div><div>立即从用户那里收集信息；</div><div>临时显示一些内容；</div><div>临时改变工作模式；</div><div>为不同的设备方向实现可替代的界面；</div><div>使用指定类型的过渡动画来显示一个新的视图结构；</div><div>模态视图的显示风格：</div><div>通过设置属性modalpresentationStyle</div><div>UIModalPresentationFullScreen;</div><div>UIModalPresentationPageSheet;</div><div>UIModalPresentationFormSheet;</div><div>模态视图的过渡风格：</div><div>通过设置属性modalTransitionStyle</div><div>UIModalTransitionStyleCoverVertical;</div><div>UIModalTransitionStyleFlipHorizontal;</div><div>UIModalTransitionStyleCrossDissolve;</div><div>步骤：</div><div>创建一个要展示的视图控件；</div><div>在适当的地方分配一个委托对象；</div><div>调用当前视图控制前的presentModalViewController:animated:方法，传递你要模态显示的视图控制器；</div><h2>多线程相关</h2><div>1· 实现多线程都有哪几种方法？</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: B C</span></div><div>A 使用@synchronized(self)</div><div>B 使用GCD</div><div>C 使用NSOperationQueue</div><div>D 使用@thread </div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释：</span><span style="-en-paragraph: true;">@thred</span><span style="-en-paragraph: true;">是安卓的关键字</span></div><div>2· 关于NSOperation queue的说法，正确的是？</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: A C D</span></div><div>A 主要用于多线程并发处理</div><div>B 它是一个队列，有严格的先进先出</div><div>C 它不会遵守严格的先进先出</div><div>D NSOperationQueue可以通过调整权重来调整队列的执行顺序 </div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释：</span></div><div>首先NSOperationQueue是属于多线程并发处理这一部分，它主要用来提供一个可添加的操作队列，将一系列操作添加到队列中，然后根据操作的优先级和内部操作依赖来决定操作执行的顺序。高优先级的操作先于低优先级执行。一个操作所依赖的操作全部执行完毕后才能执行。所以A,C,D正确</div><h2>内存相关</h2><div>1· 与alloc相反，与retain相反，与alloc配对的分别是:</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">dealloc, release, release</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: B</span></div><div>A dealloc release dealloc</div><div>B dealloc release release</div><div>C dealloc dealloc dealloc</div><div>D release release release</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释:</span></div><div>alloc其实相当于c++中的构造函数，dealloc相当于析构函数；retain相反的是release，这个应该没异议，alloc配对使用的也是release，alloc会使对象的retainCount=1，所以配对的是release。</div><hr/><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">2· 下列程序输出是：</span></div><div>NSMutableArray* ary = [[NSMutableArray array] retain];</div><div>NSString *str = [NSString stringWithFormat:@&quot;test&quot;];</div><div>[str retain];</div><div>[ary addObject:str];</div><div>NSLog(@&quot;%@%d&quot;,str,[str retainCount]);</div><div>[str retain];</div><div>[str release];</div><div>[str release];</div><div>NSLog(@&quot;%@%d&quot;,str,[str retainCount]);</div><div>[ary removeAllObjects];</div><div>NSLog(@&quot;%@%d&quot;,str,[str retainCount]);</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">答案：</span></div><div>    -1, -1, -1 </div><div>解释：</div><div>NSString *str = [NSString <span style="font-weight: bold;">stringWithFormat</span>:@&quot;test”];</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">当中</span><span style="-en-paragraph: true;">stringWithFormat</span><span style="-en-paragraph: true;">是类方法，内存管理上是autorelease的，因此内存管理是-1</span></div><hr/><div>3· 下面关于 Objective-C 内存管理的描述错误的是</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: A C 你的答案: A B C (错误)</span></div><div>A 当使用ARC来管理内存时，代码中可以出现autorelease</div><div>B autoreleasepoll在drain的时候会释放在其中分配的对象</div><div>C 当使用ARC来管理内存时，在线程中大量分配对象而不用autoreleasepool则可能会造成内存泄露</div><hr/><div>4· 关于内存管理，下列说法错误的是</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: C</span></div><div>A 谁申请，谁释放</div><div>B 内存管理主要要避免“过早释放”和“内存泄漏”，对于“过早释放”需要注意@property设置特性时，一定要用对特性关键字，对于“内存泄漏”，一定要申请了要负责释放。</div><div>C 关键字alloc 或new 生成的对象可以自动释放；</div><div>D 设置正确的property属性，对于retain需要在合适的地方释放， </div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释:</span></div><div>alloc或new生成的对象不会自动释放，要自动释放需要调用autorelease方法。</div><div><br/></div><div>谁申请，谁释放。也不是很对，在non-ARC中，如果一个函数要返回一个在堆上alloc的对象，在返回的时候需要调用autorelease方法。实际上是你申请了，但释放交给了NSAutoReleasePool。</div><div><br/></div><h2>RunLoop相关</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">1· 选C</span></div><div>NSRunLoop的以下描述错误的是（） 1/1</div><div>A Runloop并不是由系统自动控制的</div><div>B 有3类对象可以被run loop监控：sources，timers，observers</div><div>C 线程是默认启动run loop的</div><div>D NSTimer可手动添加到新建的NSRunLoop中</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释：</span></div><div>A:Runloop的作用在于当有事情要做时它使当前的thread工作，没有事情做时又使thread 休眠sleep。Runloop并不是由系统自动控制的，尤其是对那些新建的次线程需要对其进行显示的控制。</div><div><br/></div><div>B：有3类对象可以被run loop监控：sources、timers、observers。当这些对象需要处理的时候，为了接收回调，首先必须通</div><div>过 CFRunLoopAddSource ,CFRunLoopAddTimer 或者 CFRunLoopAddObserver 把这些对象放入run loop。 要停止接收它的回调，可以通过CFRunLoopRemoveSource从run loop中移除某个对象。 </div><div><br/></div><div>C：每一个线程都有自己的runloop, 主线程是默认开启的，创建的子线程要手动开启，因为NSApplication 只启动main applicaiton thread。</div><div><br/></div><div>D：NSTimer默认添加到当前NSRunLoop中，也可以手动制定添加到自己新建的NSRunLoop的中。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">2· 对下述代码错误描述正确的是( )</span></div><div>NSTimer *myTimer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(doSomeThing:) userInfo:nil repeats:YES]; </div><div>[myTimer fire]</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: A</span></div><div>A 没有将timer加入runloop</div><div>B doSomeThing缺少参数</div><div>C 忘记传递数据给userInfo</div><div>D myTimer对象未通过[[myTimer alloc] init]方法初始化</div><div>解释：</div><div>NSTimer有两种初始化方法：</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">初始化方法一： </span><span style="-en-paragraph: true;">scheduledTimerWithTimeInterval:target:selector:userInfo:repeats: 方法</span></div><div>+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)seconds target:(id)target selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)repeats</div><div> </div><div>seconds ：需要调用的毫秒数</div><div>target ：调用方法需要发送的对象。即：发给谁</div><div>userInfo ：发送的参数</div><div>repeats ：指定定时器是否重复调用目标方法</div><div> </div><div>现在做个比喻：</div><div>可以把调度一个计时器与启动汽车的引擎相比较。被调度的计时器就是运行中的引擎。没有被调度的计时器就是一个已经准备好启动但是还没有运行的引擎。我们在程序里面 , 无论何时 , 都可以调度和取消调度计时器 , 就像根据我们所处的环境 , 决定汽车的引擎是启动还是停止。</div><div><br/></div><div>如果你想要在程序中 , 手动的在某一个确定时间点调度计时器 , 可以使用 NSTimer 的类方法 timerWithTimeInterval:target:selector:userInfo:repeats: 方法。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">初始化方法二：</span></div><div>如果，我们想在任何时候都能够随心所欲的 启动 / 停止定时器。</div><div>咋办？不用急，还有 NSTimer 的另一种初始化方法，能够满足我们的要求：</div><div>// 使用 timerWithTimeInterval 方法来实例化一个 NSTimer, 这时候 NSTimer 是不会启动的</div><div>self.paintingTimer = [NSTimer timerWithTimeInterval:1.0</div><div>                                                 target:self</div><div>                                               selector:@selector(paint:)</div><div>                                               userInfo:nil</div><div>                                                repeats:YES];</div><div> </div><div> </div><div>// 当需要调用时 , 可以把计时器添加到事件处理循环中</div><div> [[NSRunLoop currentRunLoop] addTimer:self.paintingTimer forMode:NSDefaultRunLoopMode];</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">总结： </span><span style="-en-paragraph: true;">scheduled</span><span style="-en-paragraph: true;">开头的方法初始化的，会将这个timer调度到当前运行的loop中; timer和init开头的初始化方法，只是创建，并没有调度到loop中，需要手动addTimer。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">3·</span></div><div>NSString *str = @“lanou”;</div><div>[str retain];</div><div>NSLog(@“%lu”,str.retainCount);</div><div>此处打印出来的值是多少().</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: D</span></div><div>A 1</div><div>B 2</div><div>C -1</div><div>D ULONG_MAX</div><div>解释：</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">这是一个放在常量区的字符串常量，返回的结果是UINT_MAX值 有些地方的回答</span></div><h2>TableView相关</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">1· 以下关于tableView编辑的方法中哪个不属于代理方法？</span><span style="-en-paragraph: true; font-weight: bold;">A</span></div><div>A -(void)setEditing:(BOOL)editing animated:(BOOL)animated</div><div><br/></div><div>B -(BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath</div><div><br/></div><div>C -(UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath</div><div><br/></div><div>D -(void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释： A是tableView自己的方法，不是代理</span></div><hr/><div>2· 下面哪些属于UITableViewDelegate协议的方法？</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: C</span></div><div>A tableView:cellForRowAtIndexPath:</div><div>B tableView:numberOfRowsInSection:</div><div>C tableView:didSelectRowAtIndexPath:</div><div>D numberOfSectionsInTableView:</div><div>解释：</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">代理的作用是用来完成指定的某种动作，所以必须是动作性的操作而不是数据性的操作</span></div><h2>property相关</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">1· 关于readwrite, readonly, assign, automatic的说法，下列说法错误的是</span></div><div>A readwrite 是可读可写特性；需要生成getter方法和setter方法时</div><div>B readonly 是只读特性 只会生成getter方法 不会生成setter方法 ;不希望属性在类外改变</div><div>C assign 是赋值特性，setter方法将传入参数赋值给实例变量；仅设置变量时；</div><div>D nonatomic 非原子操作，决定编译器生成的setter getter是否是原子操作；nonatomic表示多线程安全；一般使用atomic</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释：</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">D项说一般使用atomic是不对的，一般使用nonatomic。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">readonly, readwrite：是控制属性的访问权限，readonly只生成getter方法，其他类是无法修改其值的。readwrite是会同时生成getter和setter方法，其他类可以修改其值。</span></div><div>assign, retain, weak, strong, copy, unsafe_unretained：</div><div>在non-ARC中，assign和retain是一组，assign的对象属性引用计数不变，而retain会被+1。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">对应的在ARC中，weak和strong是一组，</span><span style="-en-paragraph: true; font-weight: bold;">weak的对象属性引用计数不变，而strong会被+1。</span></div><div><span style="font-weight: bold;">assign还用来赋值非对象属性</span>，例如，int，double，BOOL，char等。</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; font-weight: bold;">copy用来设置不可变的对象属性</span><span style="-en-paragraph: true;">，例如，NSString，NSArray，NSDictionary等。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">在ARC中，一个属性被设置为weak，当出了作用域，其值会被设置成nil。与其相对应的是unsafe_unretained，unsafe_unretained不会改变对象属性的引用计数，同时出了作用域的时候，其值也不会被设置成nil。unsafe_unretained相当于non-ARC中的assign。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">atomic, nonatomic: atomic是原子操作，nonatomic是非原子操作，一般常用的是nonatomic。</span></div><div>2· 设置代理为属性正确的是（）</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: A</span></div><div>A @property(nonatomic,assign)</div><div>B @property(atomic,copy)</div><div>C @property(nonatomic,copy)</div><div>D @property(nonatomic,retain)</div><div>解释：</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">用weak更好，但是A最接近</span></div><div>3· 关于Objective-C中属性的说明，以下错误的是（）</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: D</span></div><div>A readwrite是可读可写特性，需要生成getter方法和setter方法</div><div>B readonly是只读特性，只有getter方法，没有setter方法</div><div>C assign是赋值属性，setter方法将传入参数赋值给实例变量</div><div>D retain表示持有特性，copy属性表示拷贝属性，都会建立一个相同的对象</div><div>解释：</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">copy</span><span style="-en-paragraph: true;">是直接创建一个。</span></div><div><br/></div><div><br/></div></span>
</div></body></html> 