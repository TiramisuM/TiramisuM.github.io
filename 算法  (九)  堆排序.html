<html>
<head>
  <title>算法  (九) : 堆排序</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <meta name="application-data:corenote-hostUUID" content="C8940BC2-A53C-4B55-B59C-4779464BC778"/>
  <meta name="application-data:corenote-localUUID" content="6CAD3214-C172-4616-BB92-9DC1A0BA83FE"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1205"/>
<h1>算法  (九) : 堆排序</h1>

<div>
<span><h3><span style="font-size: 16px;">堆排序</span><br/></h3><h1><span style="font-weight: normal;"><span style="font-size: 16px;">堆排序(Heapsort)是指利用堆积树（堆）这种</span><a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" style="font-size: 16px;">数据结构</a><span style="font-size: 16px;">所设计的一种</span><a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" style="font-size: 16px;">排序算法</a><span style="font-size: 16px;">，它是选择排序的一种。可以利用</span><a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84" style="font-size: 16px;">数组</a><span style="font-size: 16px;">的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是</span><span style="font-size: 16px;">完全二叉树</span><span style="font-size: 16px;">。大根堆的要求是每个节点的值都不大于其父节点的值，即</span><span style="font-size: 16px;">A[PARENT[i]] &gt;= A[i]。</span><span style="font-size: 16px;">在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。</span></span></h1><div><span style="font-size: 16px;"><br/></span></div><h3>堆的定义</h3><ul><li>一个<span style="color: rgb(255, 0, 0);">完全二叉树</span>中，任意父结点总是大于或等于（小于或等于）任何一个子节点，则为大顶堆（小顶堆）。</li></ul><h3>堆的数组存储方式</h3><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">完全二叉树适合采用顺序存储的方式，因此一个数组可以看成一个完全二叉树。</span></div><ul><li><span style="font-size: 12px; font-weight: bold;">节点编号</span>：树根起，<span style="color: rgb(255, 0, 0);">自上层到下层，每层从左至右，给所有结点顺序编号</span>，能得到一个反映整个二叉树结构的线性序列。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><a href="http://images2015.cnblogs.com/blog/776887/201604/776887-20160422214654116-1340244394.png"><img src="算法  (九)  堆排序_files/Image.png" type="image/png" data-filename="Image.png" width="848"/></a></div><ul><li><span style="font-size: 12px; font-weight: bold;">编号特点</span>：</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">从一个结点的编号就可推得其双亲，左、右孩子，兄弟等结点的编号。假设编号为i的结点是</span><span style="-en-paragraph: true; color: rgb(255, 0, 0);">ki(1≤i≤n)，</span><span style="-en-paragraph: true;">则有：</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">　　①若i&gt;1，则ki的双亲编号为i/2；若i=1，则Ki是根结点，无双亲。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">　　②若2i≤n，则Ki的左孩子的编号是2i；否则，Ki无左孩子，即Ki必定是叶子。因此完全二叉树中编号i&gt;n/2的结点必定是叶结点。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">　　③若2i+1≤n，则Ki的右孩子的编号是2i+1；否则，Ki无右孩子。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; color: rgb(255, 0, 0);">注：ki(0≤i≤n)满足数组下标时,则可能的左右孩子分别为2i+1、2i+2。</span></div><h3>堆排序的思想（以大顶堆为例）</h3><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">利用堆顶记录的是最大关键字这一特性，每一轮取堆顶元素放入有序区，就类似选择排序每一轮选择一个最大值放入有序区，</span><span style="-en-paragraph: true; color: rgb(255, 0, 0);">可以把堆排序看成是选择排序的改进</span><span style="-en-paragraph: true;">。</span></div><ol><li>将初始待排序关键字序列(R0,R1,R2....Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[0]与最后一个元素R[n]交换，此时得到新的无序区(R0,R1,R2,......Rn-1)和新的有序区(Rn)；</li><li>由于交换后新的堆顶R[0]可能违反堆的性质，因此需要对当前无序区(R0,R1,R2,......Rn-1)调整为新堆。</li></ol><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">不断重复此2、3步骤直到有序区的元素个数为n-1，则整个排序过程完成。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; font-size: 12px;">算法分析</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><a href="http://images2015.cnblogs.com/blog/776887/201604/776887-20160424154906304-410384152.png"><img src="算法  (九)  堆排序_files/Image [1].png" type="image/png" data-filename="Image.png" width="714"/></a></div><h3>筛选算法</h3><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">//最难理解的地方</span></div><ul><li><span style="font-size: 12px; font-weight: bold;">目标</span>：一<span style="color: rgb(255, 0, 0);">个所有子树都为堆的完全二叉树</span>。意思就是这个二叉树只差跟节点不满足堆的结构。//很重要，很重要，很重要</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">    如下图：</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><a href="http://images2015.cnblogs.com/blog/776887/201604/776887-20160422214657179-153027674.png"><img src="算法  (九)  堆排序_files/Image [2].png" type="image/png" data-filename="Image.png" width="250"/></a></div><ul><li><span style="font-size: 12px; font-weight: bold;">方法</span>：首先将root和它的左右子树的根结点进行比较，<span style="color: rgb(255, 0, 0);">把最大的元素交换到root节点；然后顺着被破坏的路径一路调整下去</span>，直至叶子结点，就得到新的堆。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><a href="http://images2015.cnblogs.com/blog/776887/201604/776887-20160422214658445-1668290479.png"><img src="算法  (九)  堆排序_files/Image [3].png" type="image/png" data-filename="Image.png" width="251"/></a></div><ul><li><span style="font-size: 12px; font-weight: bold;">运用</span>：1.在上文提到的堆排序思想，2-3步骤中将无序区调整为堆的时候用到。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">          2.初始化堆</span></div><h3>初始化堆</h3><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; color: rgb(255, 0, 0);">从最后一个非叶子节点i</span><span style="-en-paragraph: true; color: rgb(255, 0, 0);">（i=n/2,n为节点个数）</span><span style="-en-paragraph: true;">开始，将以i为根节点的二叉树通过筛选调整为堆。以第一张图为例，编号顺序为8、7、6...1。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; color: rgb(255, 0, 0);">从最后一个非叶子节就保证了筛选算法的正确性，因为筛选算法的目标是一个所有子树都为堆的完全二叉树</span><span style="-en-paragraph: true;">。</span></div><h3>java实现堆排序</h3><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">package sort;</span></div><div><br/></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">import java.util.Arrays;</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">import util.MathUtil;</span></div><div><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;">/**</span></div><div><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;"> * 通过大顶堆实现堆排序，升序排序</span></div><div><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;"> *</span></div><div><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;"> */</span></div><div><br/></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">public class HeapSort {</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">    public </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">static</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;"> </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">void</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;"> main(String[] args) {</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">        </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">int</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">[] arr={</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">9</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">,</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">6</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">,</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">12</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">,</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">32</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">,</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">23</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">,</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">11</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">,</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">2</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">,</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">100</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">,</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">85</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">};</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">        sort(arr);</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">        System.</span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">out</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">.println(Arrays.toString(arr));</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">    }</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">    </span><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;">//这里将i定义为完全二叉树的根</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">    </span><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;">//将完全二叉树调整为大顶堆,前提是二叉树的根的子树已经为大顶堆。</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">    public </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">static</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;"> </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">void</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;"> adjustHeap(</span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">int</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">[]a ,</span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">int</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;"> i,</span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">int</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;"> size){</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">        </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">int</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;"> lChild=</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">2</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">*i+</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">1</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">;        </span><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;">//左孩子</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">        </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">int</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;"> rChild=</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">2</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">*i+</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">2</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">;        </span><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;">//又孩子</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">        </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">int</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;"> max=i;                </span><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;">//临时变量</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">        </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">if</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">(i&lt;size/</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">2</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">){            </span><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;">//如果i是叶子节点就结束</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">            </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">if</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">(lChild&lt;size&amp;&amp;a[max]&lt;a[lChild])</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">                max=lChild;</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">            </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">if</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">(rChild&lt;size&amp;&amp;a[max]&lt;a[rChild])</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">                max=rChild;</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">            </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">if</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">(max!=i){</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">                MathUtil.swap(a, max, i);</span><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;">//交换后破环了子树的堆结构</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">                adjustHeap(a, max, size);</span><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;">//递归，调节子树为堆</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">            }</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">        }</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">    }</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">    </span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">    </span><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;">//建立堆，堆是从下往上建立的，因为adjustHeap函数是建立在子树已经为大顶堆。</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">    public </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">static</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;"> </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">void</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;"> buildHeap(</span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">int</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">[]a,</span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">int</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;"> size){</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">        </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">for</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">(</span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">int</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;"> i=size/</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">2</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">;i&gt;=</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">0</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">;i--){</span><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;">//从最后一个非叶子节点，才能构成adjustHeap操作的目标二叉树</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">            adjustHeap(a, i, size);</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">        }</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">    }</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">    </span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">    </span><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;">//将数组分为两部分，一部分为有序区，在数组末尾，另一部分为无序区。堆属于无序区</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">    public </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">static</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;"> </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">void</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;"> sort(</span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">int</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">[] arr){</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">        </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">int</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;"> size=arr.length;</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">        buildHeap(arr, size);</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">        </span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">for</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">(</span><span style="font: 13.0px Menlo; color: #ba2da2; background-color: #ffffff;">int</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;"> i=size-</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">1</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">;i&gt;</span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">0</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">;i--){</span><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;">//i为无序区的长度，经过如下两步，长度递减</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">            </span><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;">//堆顶即下标为0的元素</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">            MathUtil.swap(arr, i, </span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">0</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">);</span><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;">//1.每次将堆顶元素和无序区最后一个元素交换，即将无序区最大的元素放入有序区</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">            adjustHeap(arr, </span><span style="font: 13.0px Menlo; color: #272ad8; background-color: #ffffff;">0</span><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">, i);   </span><span style="font: 13.0px Menlo; color: #008400; background-color: #ffffff;">//2.将无顺区调整为大顶堆，即选择出最大的元素。</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">        }</span></div><div><span style="font: 13.0px Menlo; color: #000000; background-color: #ffffff;">    }</span></div><div><span style="font-style: normal; font-variant-caps: normal; font-weight: normal; font-size: 13px; line-height: normal; font-family: Menlo; color: rgb(0, 0, 0);">}</span></div></span>
</div></body></html> 