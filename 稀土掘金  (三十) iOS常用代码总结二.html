<html>
<head>
  <title>稀土掘金  (三十) :iOS常用代码总结&lt;二&gt;</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <meta name="application-data:corenote-hostUUID" content="C8940BC2-A53C-4B55-B59C-4779464BC778"/>
  <meta name="application-data:corenote-localUUID" content="0044D8F2-C5AD-4F0D-A8BF-C34D5E92CDFE"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="877"/>
<h1>稀土掘金  (三十) :iOS常用代码总结&lt;二&gt;</h1>

<div>
<span><h3>1、设置UILabel行间距</h3><pre><code>NSMutableAttributedString* attrString = [[NSMutableAttributedString  alloc] initWithString:label.text];<br/>    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];<br/>    [style setLineSpacing:20];<br/>    [attrString addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, label.text.length)];<br/>    label.attributedText = attrString;</code></pre><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"> 或者使用xib，看下gif图</span></div><div><img src="稀土掘金  (三十) iOS常用代码总结二_files/111.gif" type="image/gif" data-filename="111.gif" width="353"/><br/></div><div>Untitled.gif</div></blockquote><h3>2、当使用-performSelector:withObject:withObject:afterDelay:方法时，需要传入多参数问题</h3><pre><code>// 方法一、<br/>// 把参数放进一个数组／字典，直接把数组／字典当成一个参数传过去，具体方法实现的地方再解析这个数组／字典<br/>NSArray * array = <br/>    [NSArray arrayWithObjects: @&quot;first&quot;, @&quot;second&quot;, nil];<br/>[self performSelector:@selector(fooFirstInput:) withObject: array afterDelay:15.0];<br/><br/>// 方法二、<br/>// 使用NSInvocation<br/>SEL aSelector = NSSelectorFromString(@&quot;doSoming:argument2:&quot;);<br/>    NSInteger argument1 = 10;<br/>    NSString *argument2 = @&quot;argument2&quot;;<br/>    if([self respondsToSelector:aSelector]) {<br/>        NSInvocation *inv = [NSInvocation invocationWithMethodSignature:[self methodSignatureForSelector:aSelector]];<br/>        [inv setSelector:aSelector];<br/>        [inv setTarget:self];<br/>        [inv setArgument:&amp;(argument1) atIndex:2];<br/>        [inv setArgument:&amp;(argument2) atIndex:3];<br/>        [inv performSelector:@selector(invoke) withObject:nil afterDelay:15.0];<br/>    }</code></pre><h3>3、UILabel显示不同颜色字体</h3><pre><code>NSMutableAttributedString * string = [[NSMutableAttributedString alloc] initWithString:label.text];<br/>[string addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0,5)];<br/>[string addAttribute:NSForegroundColorAttributeName value:[UIColor greenColor] range:NSMakeRange(5,6)];<br/>[string addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(11,5)];<br/>label.attributedText = string;</code></pre><h3>4、比较两个CGRect/CGSize/CGPoint是否相等</h3><pre><code>if (CGRectEqualToRect(rect1, rect2)) { // 两个区域相等<br/>        // do some<br/>    }<br/>    if (CGPointEqualToPoint(point1, point2)) { // 两个点相等<br/>        // do some<br/>    }<br/>    if (CGSizeEqualToSize(size1, size2)) { // 两个size相等<br/>        // do some<br/>    }</code></pre><h3>5、比较两个NSDate相差多少小时</h3><pre><code> NSDate* date1 = someDate;<br/> NSDate* date2 = someOtherDate;<br/> NSTimeInterval distanceBetweenDates = [date1 timeIntervalSinceDate:date2];<br/> double secondsInAnHour = 3600;<br/>// 除以3600是把秒化成小时，除以60得到结果为相差的分钟数<br/> NSInteger hoursBetweenDates = distanceBetweenDates / secondsInAnHour;</code></pre><h3>6、每个cell之间增加间距</h3><pre><code>// 方法一，每个分区只显示一行cell，分区头当作你想要的间距(注意，从数据源数组中取值的时候需要用indexPath.section而不是indexPath.row)<br/>- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView<br/>{<br/>    return yourArry.count;<br/>}<br/>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section<br/>{<br/>    return 1;<br/>}<br/>-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section<br/>{<br/>    return cellSpacingHeight;<br/>}<br/><br/>// 方法二，在cell的contentView上加个稍微低一点的view，cell上原本的内容放在你的view上，而不是contentView上，这样能伪造出一个间距来。<br/><br/>// 方法三，自定义cell，重写setFrame：方法<br/>- (void)setFrame:(CGRect)frame<br/>{<br/>    frame.size.height -= 20;<br/>    [super setFrame:frame];<br/>}</code></pre><h3>7、播放一张张连续的图片</h3><pre><code>// 加入现在有三张图片分别为animate_1、animate_2、animate_3<br/>// 方法一<br/>    imageView.animationImages = @[[UIImage imageNamed:@&quot;animate_1&quot;], [UIImage imageNamed:@&quot;animate_2&quot;], [UIImage imageNamed:@&quot;animate_3&quot;]];<br/>imageView.animationDuration = 1.0;<br/>// 方法二<br/>    imageView.image = [UIImage animatedImageNamed:@&quot;animate_&quot; duration:1.0];<br/>// 方法二解释下，这个方法会加载animate_为前缀的，后边0-1024，也就是animate_0、animate_1一直到animate_1024</code></pre><h3>8、加载gif图片</h3><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">推荐使用这个框架 </span><a href="https://github.com/Flipboard/FLAnimatedImage" style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">FLAnimatedImage</a></div></blockquote><h3>9、防止离屏渲染为image添加圆角</h3><pre><code>// image分类<br/>- (UIImage *)circleImage<br/>{<br/>// NO代表透明<br/>UIGraphicsBeginImageContextWithOptions(self.size, NO, 1);<br/>// 获得上下文<br/>CGContextRef ctx = UIGraphicsGetCurrentContext();<br/>// 添加一个圆<br/>CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);<br/>// 方形变圆形<br/>CGContextAddEllipseInRect(ctx, rect);<br/>// 裁剪<br/>CGContextClip(ctx);<br/>// 将图片画上去<br/>[self drawInRect:rect];<br/>UIImage *image = UIGraphicsGetImageFromCurrentImageContext();<br/>UIGraphicsEndImageContext();<br/>return image;<br/>}</code></pre><h3>10、查看系统所有字体</h3><pre><code>// 打印字体<br/>for (id familyName in [UIFont familyNames]) {<br/>    NSLog(@&quot;%@&quot;, familyName);<br/>    for (id fontName in [UIFont fontNamesForFamilyName:familyName]) NSLog(@&quot;  %@&quot;, fontName);<br/>}<br/>// 也可以进入这个网址查看 <a href="http://iosfonts.com/">http://iosfonts.com/</a></code></pre><h3>11、获取随机数</h3><pre><code>NSInteger i = arc4random();</code></pre><h3>12、获取随机数小数(0-1之间)</h3><pre><code>#define ARC4RANDOM_MAX      0x100000000<br/>double val = ((double)arc4random() / ARC4RANDOM_MAX);</code></pre><h3>13、AVPlayer视频播放完成的通知监听</h3><pre><code>[[NSNotificationCenter defaultCenter] <br/>      addObserver:self<br/>      selector:@selector(videoPlayEnd)<br/>      name:AVPlayerItemDidPlayToEndTimeNotification <br/>      object:nil];</code></pre><h3>14、判断两个rect是否有交叉</h3><pre><code> if (CGRectIntersectsRect(rect1, rect2)) {<br/>}</code></pre><h3>15、判断一个字符串是否为数字</h3><pre><code>NSCharacterSet *notDigits = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];<br/>    if ([str rangeOfCharacterFromSet:notDigits].location == NSNotFound)<br/>    {<br/>      // 是数字<br/>    } else<br/>    {<br/>      // 不是数字<br/>    }</code></pre><h3>16、将一个view保存为pdf格式</h3><pre><code>- (void)createPDFfromUIView:(UIView*)aView saveToDocumentsWithFileName:(NSString*)aFilename<br/>{<br/>    NSMutableData *pdfData = [NSMutableData data];<br/>    UIGraphicsBeginPDFContextToData(pdfData, aView.bounds, nil);<br/>    UIGraphicsBeginPDFPage();<br/>    CGContextRef pdfContext = UIGraphicsGetCurrentContext();<br/>    [aView.layer renderInContext:pdfContext];<br/>    UIGraphicsEndPDFContext();<br/><br/>    NSArray* documentDirectories = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask,YES);<br/>    NSString* documentDirectory = [documentDirectories objectAtIndex:0];<br/>    NSString* documentDirectoryFilename = [documentDirectory stringByAppendingPathComponent:aFilename];<br/>    [pdfData writeToFile:documentDirectoryFilename atomically:YES];<br/>    NSLog(@&quot;documentDirectoryFileName: %@&quot;,documentDirectoryFilename);<br/>}</code></pre><h3>17、让一个view在父视图中心</h3><pre><code>child.center = [parent convertPoint:parent.center fromView:parent.superview];</code></pre><h3>18、获取当前导航控制器下前一个控制器</h3><pre><code>- (UIViewController *)backViewController<br/>{<br/>    NSInteger myIndex = [self.navigationController.viewControllers indexOfObject:self];<br/><br/>    if ( myIndex != 0 &amp;&amp; myIndex != NSNotFound ) {<br/>        return [self.navigationController.viewControllers objectAtIndex:myIndex-1];<br/>    } else {<br/>        return nil;<br/>    }<br/>}</code></pre><h3>19、保存UIImage到本地</h3><pre><code>NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);<br/>NSString *filePath = [[paths objectAtIndex:0] stringByAppendingPathComponent:@&quot;Image.png&quot;];<br/><br/>[UIImagePNGRepresentation(image) writeToFile:filePath atomically:YES];</code></pre><h3>20、键盘上方增加工具栏</h3><pre><code>UIToolbar *keyboardDoneButtonView = [[UIToolbar alloc] init];<br/>[keyboardDoneButtonView sizeToFit];<br/>UIBarButtonItem *doneButton = [[UIBarButtonItem alloc] initWithTitle:@&quot;Done&quot;<br/>                                                               style:UIBarButtonItemStyleBordered target:self<br/>                                                              action:@selector(doneClicked:)];<br/>[keyboardDoneButtonView setItems:[NSArray arrayWithObjects:doneButton, nil]];<br/>txtField.inputAccessoryView = keyboardDoneButtonView;</code></pre><h3>21、copy一个view</h3><blockquote><div>因为UIView没有实现copy协议，因此找不到copyWithZone方法，使用copy的时候导致崩溃</div><div>但是我们可以通过归档再解档实现copy，这相当于对视图进行了一次深拷贝，代码如下</div></blockquote><pre><code>id copyOfView = <br/>[NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:originalView]];</code></pre><h3>22、在image上绘制文字并生成新的image</h3><pre><code>UIFont *font = [UIFont boldSystemFontOfSize:12];<br/>    UIGraphicsBeginImageContext(image.size);<br/>    [image drawInRect:CGRectMake(0,0,image.size.width,image.size.height)];<br/>    CGRect rect = CGRectMake(point.x, point.y, image.size.width, image.size.height);<br/>    [[UIColor whiteColor] set];<br/>    [text drawInRect:CGRectIntegral(rect) withFont:font]; <br/>    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();<br/>    UIGraphicsEndImageContext();</code></pre><h3>23、判断一个view是否为另一个view的子视图</h3><pre><code>// 如果myView是self.view本身，也会返回yes<br/>BOOL isSubView = [myView isDescendantOfView:self.view];</code></pre><h3>24、判断一个字符串是否包含另一个字符串</h3><pre><code>// 方法一、这种方法只适用于iOS8之后，如果是配iOS8之前用方法二<br/>if ([str containsString:otherStr]) NSLog(@&quot;包含&quot;);<br/><br/>// 方法二<br/>NSRange range = [str rangeOfString:otherStr];<br/>if (range.location != NSNotFound) NSLog(@&quot;包含&quot;);</code></pre><h3>25、UICollectionView自动滚动到某行</h3><pre><code>// 重写viewDidLayoutSubviews方法<br/>-(void)viewDidLayoutSubviews {<br/>   [super viewDidLayoutSubviews];<br/>   [self.collectionView scrollToItemAtIndexPath:indexPath atScrollPosition:UICollectionViewScrollPositionCenteredVertically animated:NO];<br/>}</code></pre><h3>26、修改系统UIAlertController</h3><pre><code>// 但是据说这种方法会被App Store拒绝(慎用！)<br/>UIAlertController *alertVC = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:@&quot;&quot; preferredStyle:UIAlertControllerStyleActionSheet];<br/>    NSMutableAttributedString *hogan = [[NSMutableAttributedString alloc] initWithString:@&quot;我是一个大文本&quot;];<br/>    [hogan addAttribute:NSFontAttributeName<br/>                  value:[UIFont systemFontOfSize:30]<br/>                  range:NSMakeRange(4, 1)];<br/>    [hogan addAttribute:NSForegroundColorAttributeName<br/>                  value:[UIColor redColor]<br/>                  range:NSMakeRange(4, 1)];<br/>    [alertVC setValue:hogan forKey:@&quot;attributedTitle&quot;];<br/><br/>    UIAlertAction *button = [UIAlertAction actionWithTitle:@&quot;Label text&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction *action){ }];<br/>    UIImage *accessoryImage = [UIImage imageNamed:@&quot;1&quot;];<br/>    [button setValue:accessoryImage forKey:@&quot;image&quot;];<br/>    [alertVC addAction:button];<br/>    [self presentViewController:alertVC animated:YES completion:nil];</code></pre><h3>27、判断某一行的cell是否已经显示</h3><pre><code>CGRect cellRect = [tableView rectForRowAtIndexPath:indexPath];<br/>BOOL completelyVisible = CGRectContainsRect(tableView.bounds, cellRect);</code></pre><h3>28、让导航控制器pop回指定的控制器</h3><pre><code>NSMutableArray *allViewControllers = [NSMutableArray arrayWithArray:[self.navigationController viewControllers]];<br/>for (UIViewController *aViewController in allViewControllers) {<br/>    if ([aViewController isKindOfClass:[RequiredViewController class]]) {<br/>        [self.navigationController popToViewController:aViewController animated:NO];<br/>    }<br/>}</code></pre><h3>29、动画修改label上的文字</h3><pre><code>// 方法一<br/>CATransition *animation = [CATransition animation];<br/>    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];<br/>    animation.type = kCATransitionFade;<br/>    animation.duration = 0.75;<br/>    [self.label.layer addAnimation:animation forKey:@&quot;kCATransitionFade&quot;];<br/>    self.label.text = @&quot;New&quot;;<br/><br/>// 方法二<br/>[UIView transitionWithView:self.label<br/>                      duration:0.25f<br/>                       options:UIViewAnimationOptionTransitionCrossDissolve<br/>                    animations:^{<br/><br/>                        self.label.text = @&quot;Well done!&quot;;<br/><br/>                    } completion:nil];<br/><br/>// 方法三<br/>[UIView animateWithDuration:1.0<br/>                     animations:^{<br/>                         self.label.alpha = 0.0f;<br/>                         self.label.text = @&quot;newText&quot;;<br/>                         self.label.alpha = 1.0f;<br/>                     }];</code></pre><h3>30、判断字典中是否包含某个key值</h3><pre><code>if ([dic objectForKey:@&quot;yourKey&quot;]) {<br/>    NSLog(@&quot;有这个值&quot;);<br/>} else {<br/>    NSLog(@&quot;没有这个值&quot;);<br/>}</code></pre><h3>31、获取屏幕方向</h3><pre><code>UIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation;<br/><br/>if(orientation == 0) //Default orientation <br/>    //默认<br/>else if(orientation == UIInterfaceOrientationPortrait)<br/>    //竖屏<br/>else if(orientation == UIInterfaceOrientationLandscapeLeft)<br/>    // 左横屏<br/>else if(orientation == UIInterfaceOrientationLandscapeRight)<br/>    //右横屏</code></pre><h3>32、设置UIImage的透明度</h3><pre><code>// 方法一、添加UIImage分类<br/>- (UIImage *)imageByApplyingAlpha:(CGFloat) alpha {<br/>    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0f);<br/><br/>    CGContextRef ctx = UIGraphicsGetCurrentContext();<br/>    CGRect area = CGRectMake(0, 0, self.size.width, self.size.height);<br/><br/>    CGContextScaleCTM(ctx, 1, -1);<br/>    CGContextTranslateCTM(ctx, 0, -area.size.height);<br/><br/>    CGContextSetBlendMode(ctx, kCGBlendModeMultiply);<br/><br/>    CGContextSetAlpha(ctx, alpha);<br/><br/>    CGContextDrawImage(ctx, area, self.CGImage);<br/><br/>    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();<br/><br/>    UIGraphicsEndImageContext();<br/><br/>    return newImage;<br/>}<br/><br/>// 方法二、如果没有奇葩需求，干脆用UIImageView设置透明度<br/>UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageWithName:@&quot;yourImage&quot;]];<br/>imageView.alpha = 0.5;</code></pre><h3>33、Attempt to mutate immutable object with insertString:atIndex:</h3><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这个错是因为你拿字符串调用insertString:atIndex:方法的时候，调用对象不是NSMutableString，应该先转成这个类型再调用</span></div></blockquote><h3>34、UIWebView添加单击手势不响应</h3><pre><code>UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(webViewClick)];<br/>        tap.delegate = self;<br/>        [_webView addGestureRecognizer:tap];<br/><br/>// 因为webView本身有一个单击手势，所以再添加会造成手势冲突，从而不响应。需要绑定手势代理，并实现下边的代理方法<br/>- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer{<br/>    return YES;<br/>}</code></pre><h3>35、获取手机RAM容量</h3><pre><code>// 需要导入#import &lt;mach/mach.h&gt;<br/>mach_port_t host_port;<br/>    mach_msg_type_number_t host_size;<br/>    vm_size_t pagesize;<br/><br/>    host_port = mach_host_self();<br/>    host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);<br/>    host_page_size(host_port, &amp;pagesize);<br/><br/>    vm_statistics_data_t vm_stat;<br/><br/>    if (host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size) != KERN_SUCCESS) {<br/>        NSLog(@&quot;Failed to fetch vm statistics&quot;);<br/>    }<br/><br/>    /* Stats in bytes */<br/>    natural_t mem_used = (vm_stat.active_count +<br/>                          vm_stat.inactive_count +<br/>                          vm_stat.wire_count) * pagesize;<br/>    natural_t mem_free = vm_stat.free_count * pagesize;<br/>    natural_t mem_total = mem_used + mem_free;<br/>    NSLog(@&quot;已用: %u 可用: %u 总共: %u&quot;, mem_used, mem_free, mem_total);</code></pre><h3>36、地图上两个点之间的实际距离</h3><pre><code>// 需要导入#import &lt;CoreLocation/CoreLocation.h&gt;<br/>CLLocation *locA = [[CLLocation alloc] initWithLatitude:34 longitude:113];<br/>    CLLocation *locB = [[CLLocation alloc] initWithLatitude:31.05 longitude:121.76];<br/>// CLLocationDistance求出的单位为米<br/>    CLLocationDistance distance = [locA distanceFromLocation:locB];</code></pre><h3>37、在应用中打开设置的某个界面</h3><pre><code>// 打开设置-&gt;通用<br/>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;prefs:root=General&quot;]];<br/><br/>// 以下是设置其他界面<br/>prefs:root=General&amp;path=About<br/>prefs:root=General&amp;path=ACCESSIBILITY<br/>prefs:root=AIRPLANE_MODE<br/>prefs:root=General&amp;path=AUTOLOCK<br/>prefs:root=General&amp;path=USAGE/CELLULAR_USAGE<br/>prefs:root=Brightness<br/>prefs:root=Bluetooth<br/>prefs:root=General&amp;path=DATE_AND_TIME<br/>prefs:root=FACETIME<br/>prefs:root=General<br/>prefs:root=General&amp;path=Keyboard<br/>prefs:root=CASTLE<br/>prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP<br/>prefs:root=General&amp;path=INTERNATIONAL<br/>prefs:root=LOCATION_SERVICES<br/>prefs:root=ACCOUNT_SETTINGS<br/>prefs:root=MUSIC<br/>prefs:root=MUSIC&amp;path=EQ<br/>prefs:root=MUSIC&amp;path=VolumeLimit<br/>prefs:root=General&amp;path=Network<br/>prefs:root=NIKE_PLUS_IPOD<br/>prefs:root=NOTES<br/>prefs:root=NOTIFICATIONS_ID<br/>prefs:root=Phone<br/>prefs:root=Photos<br/>prefs:root=General&amp;path=ManagedConfigurationList<br/>prefs:root=General&amp;path=Reset<br/>prefs:root=Sounds&amp;path=Ringtone<br/>prefs:root=Safari<br/>prefs:root=General&amp;path=Assistant<br/>prefs:root=Sounds<br/>prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK<br/>prefs:root=STORE<br/>prefs:root=TWITTER<br/>prefs:root=FACEBOOK<br/>prefs:root=General&amp;path=USAGE prefs:root=VIDEO<br/>prefs:root=General&amp;path=Network/VPN<br/>prefs:root=Wallpaper<br/>prefs:root=WIFI<br/>prefs:root=INTERNET_TETHERING<br/>prefs:root=Phone&amp;path=Blocked<br/>prefs:root=DO_NOT_DISTURB</code></pre><h3>38、在UITextView中显示html文本</h3><pre><code>    UITextView *textView = [[UITextView alloc] initWithFrame:CGRectMake(20, 30, 100, 199)];<br/>    textView.backgroundColor = [UIColor redColor];<br/>    [self.view addSubview:textView];<br/>    NSString *htmlString = @&quot;&lt;h1&gt;Header&lt;/h1&gt;&lt;h2&gt;Subheader&lt;/h2&gt;&lt;p&gt;Some &lt;em&gt;text&lt;/em&gt;&lt;/p&gt;![](http://blogs.<a href="http://babble.com/famecrawler/files/2010/11/mickey_mouse-1097.jpg">babble.com/famecrawler/files/2010/11/mickey_mouse-1097.jpg</a>)&quot;;<br/>    NSAttributedString *attributedString = [[NSAttributedString alloc] initWithData: [htmlString dataUsingEncoding:NSUnicodeStringEncoding] options: @{ NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType } documentAttributes: nil error: nil];<br/>    textView.attributedText = attributedString;</code></pre><h3>39、监听scrollView是否滚动到了顶部／底部</h3><pre><code>-(void)scrollViewDidScroll: (UIScrollView*)scrollView<br/>{<br/>    float scrollViewHeight = scrollView.frame.size.height;<br/>    float scrollContentSizeHeight = scrollView.contentSize.height;<br/>    float scrollOffset = scrollView.contentOffset.y;<br/><br/>    if (scrollOffset == 0)<br/>    {<br/>        // 滚动到了顶部<br/>    }<br/>    else if (scrollOffset + scrollViewHeight == scrollContentSizeHeight)<br/>    {<br/>        // 滚动到了底部<br/>    }<br/>}</code></pre><h3>40、UISlider增量／减量为固定值(假如为5)</h3><pre><code>- (void)setupSlider<br/>{<br/>    UISlider *slider = [[UISlider alloc] init];<br/>    [self.view addSubview:slider];<br/>    [slider addTarget:self action:@selector(sliderAction:) forControlEvents:UIControlEventValueChanged];<br/>    slider.maximumValue = 100;<br/>    slider.minimumValue = 0;<br/>    slider.frame = CGRectMake(200, 20, 100, 30);<br/>}<br/><br/>- (void)sliderAction:(UISlider *)slider<br/>{<br/>    [slider setValue:((int)((slider.value + 2.5) / 5) * 5) animated:NO];<br/>}</code></pre><h3>41、选中textField或者textView所有文本(我这里以textView为例)</h3><pre><code>[self.textView setSelectedTextRange:[self.textView textRangeFromPosition:self.textView.beginningOfDocument toPosition:self.textView.endOfDocument]]</code></pre><h3>42、从导航控制器中删除某个控制器</h3><pre><code>// 方法一、知道这个控制器所处的导航控制器下标<br/>NSMutableArray *navigationArray = [[NSMutableArray alloc] initWithArray: self.navigationController.viewControllers];<br/>[navigationArray removeObjectAtIndex: 2]; <br/>self.navigationController.viewControllers = navigationArray;<br/><br/>// 方法二、知道具体是哪个控制器<br/>NSArray* tempVCA = [self.navigationController viewControllers];<br/><br/>for(UIViewController *tempVC in tempVCA)<br/>{<br/>    if([tempVC isKindOfClass:[urViewControllerClass class]])<br/>    {<br/>        [tempVC removeFromParentViewController];<br/>    }<br/>}</code></pre><h3>43、隐藏UITextView/UITextField光标</h3><pre><code>textField.tintColor = [UIColor clearColor];</code></pre><h3>44、当UITextView/UITextField中没有文字时，禁用回车键</h3><pre><code>textField.enablesReturnKeyAutomatically = YES;</code></pre><h3>45、字符串encode编码(编码url字符串不成功的问题)</h3><pre><code>// 我们一般用这个方法处理stringByAddingPercentEscapesUsingEncoding但是这个方法好想不会处理／和&amp;这种特殊符号，这种情况就需要用下边这个方法处理<br/>@implementation NSString (NSString_Extended)<br/>- (NSString *)urlencode {<br/>    NSMutableString *output = [NSMutableString string];<br/>    const unsigned char *source = (const unsigned char *)[self UTF8String];<br/>    int sourceLen = strlen((const char *)source);<br/>    for (int i = 0; i &lt; sourceLen; ++i) {<br/>        const unsigned char thisChar = source[i];<br/>        if (thisChar == ' '){<br/>            [output appendString:@&quot;+&quot;];<br/>        } else if (thisChar == '.' || thisChar == '-' || thisChar == '_' || thisChar == '~' || <br/>                   (thisChar &gt;= 'a' &amp;&amp; thisChar &lt;= 'z') ||<br/>                   (thisChar &gt;= 'A' &amp;&amp; thisChar &lt;= 'Z') ||<br/>                   (thisChar &gt;= '0' &amp;&amp; thisChar &lt;= '9')) {<br/>            [output appendFormat:@&quot;%c&quot;, thisChar];<br/>        } else {<br/>            [output appendFormat:@&quot;%%%02X&quot;, thisChar];<br/>        }<br/>    }<br/>    return output;<br/>}</code></pre><h3>46、计算UILabel上某段文字的frame</h3><pre><code>@implementation UILabel (TextRect)<br/><br/>- (CGRect)boundingRectForCharacterRange:(NSRange)range<br/>{<br/>    NSTextStorage *textStorage = [[NSTextStorage alloc] initWithAttributedString:[self attributedText]];<br/>    NSLayoutManager *layoutManager = [[NSLayoutManager alloc] init];<br/>    [textStorage addLayoutManager:layoutManager];<br/>    NSTextContainer *textContainer = [[NSTextContainer alloc] initWithSize:[self bounds].size];<br/>    textContainer.lineFragmentPadding = 0;<br/>    [layoutManager addTextContainer:textContainer];<br/>    NSRange glyphRange;<br/>    [layoutManager characterRangeForGlyphRange:range actualGlyphRange:&amp;glyphRange];<br/>    return [layoutManager boundingRectForGlyphRange:glyphRange inTextContainer:textContainer];<br/>}</code></pre><h3>47、获取随机UUID</h3><pre><code>NSString *result;<br/>    if([[[UIDevice currentDevice] systemVersion] floatValue] &gt; 6.0)<br/>    {<br/>       result = [[NSUUID UUID] UUIDString];<br/>    }<br/>    else<br/>    {<br/>        CFUUIDRef uuidRef = CFUUIDCreate(NULL);<br/>        CFStringRef uuid = CFUUIDCreateString(NULL, uuidRef);<br/>        CFRelease(uuidRef);<br/>        result = (__bridge_transfer NSString *)uuid;<br/>    }</code></pre><h3>48、仿苹果抖动动画</h3><pre><code>#define RADIANS(degrees) (((degrees) * M_PI) / 180.0)<br/><br/>- (void)startAnimate {<br/>    view.transform = CGAffineTransformRotate(CGAffineTransformIdentity, RADIANS(-5));<br/><br/>    [UIView animateWithDuration:0.25 delay:0.0 options:(UIViewAnimationOptionAllowUserInteraction | UIViewAnimationOptionRepeat | UIViewAnimationOptionAutoreverse) animations:^ {<br/>                         view.transform = CGAffineTransformRotate(CGAffineTransformIdentity, RADIANS(5));<br/>                     } completion:nil];<br/>}<br/><br/>- (void)stopAnimate {<br/>    [UIView animateWithDuration:0.25 delay:0.0 options:(UIViewAnimationOptionAllowUserInteraction | UIViewAnimationOptionBeginFromCurrentState | UIViewAnimationOptionCurveLinear) animations:^ {<br/>                         view.transform = CGAffineTransformIdentity;<br/>                     } completion:nil];<br/>}</code></pre><h3>49、修改UISearBar内部背景颜色</h3><pre><code>UITextField *textField = [_searchBar valueForKey:@&quot;_searchField&quot;];<br/>textField.backgroundColor = [UIColor redColor];</code></pre><h3>50、UITextView滚动到顶部</h3><pre><code>    // 方法一<br/>    [self.textView scrollRangeToVisible:NSMakeRange(0, 0)];<br/>    // 方法二<br/>    [self.textView setContentOffset:CGPointZero animated:YES];</code></pre><h3>51、通知监听APP生命周期</h3><blockquote><div>UIApplicationDidEnterBackgroundNotification 应用程序进入后台</div><div>UIApplicationWillEnterForegroundNotification 应用程序将要进入前台</div><div>UIApplicationDidFinishLaunchingNotification 应用程序完成启动</div><div>UIApplicationDidFinishLaunchingNotification 应用程序由挂起变的活跃</div><div>UIApplicationWillResignActiveNotification 应用程序挂起(有电话进来或者锁屏)</div><div>UIApplicationDidReceiveMemoryWarningNotification 应用程序收到内存警告</div><div>UIApplicationDidReceiveMemoryWarningNotification 应用程序终止(后台杀死、手机关机等)</div><div>UIApplicationSignificantTimeChangeNotification 当有重大时间改变(凌晨0点，设备时间被修改，时区改变等)</div><div>UIApplicationWillChangeStatusBarOrientationNotification 设备方向将要改变</div><div>UIApplicationDidChangeStatusBarOrientationNotification 设备方向改变</div><div>UIApplicationWillChangeStatusBarFrameNotification 设备状态栏frame将要改变</div><div>UIApplicationDidChangeStatusBarFrameNotification 设备状态栏frame改变</div><div>UIApplicationBackgroundRefreshStatusDidChangeNotification 应用程序在后台下载内容的状态发生变化</div><div>UIApplicationProtectedDataWillBecomeUnavailable 本地受保护的文件被锁定,无法访问</div><div>UIApplicationProtectedDataWillBecomeUnavailable 本地受保护的文件可用了</div></blockquote><h3>52、触摸事件类型</h3><blockquote><div>UIControlEventTouchCancel 取消控件当前触发的事件</div><div>UIControlEventTouchDown 点按下去的事件</div><div>UIControlEventTouchDownRepeat 重复的触动事件</div><div>UIControlEventTouchDragEnter 手指被拖动到控件的边界的事件</div><div>UIControlEventTouchDragExit 一个手指从控件内拖到外界的事件</div><div>UIControlEventTouchDragInside 手指在控件的边界内拖动的事件</div><div>UIControlEventTouchDragOutside 手指在控件边界之外被拖动的事件</div><div>UIControlEventTouchUpInside 手指处于控制范围内的触摸事件</div><div>UIControlEventTouchUpOutside 手指超出控制范围的控制中的触摸事件</div></blockquote><h3>53、UITextField文字周围增加边距</h3><pre><code>    // 子类化UITextField，增加insert属性<br/>@interface WZBTextField : UITextField<br/>@property (nonatomic, assign) UIEdgeInsets insets;<br/>@end<br/><br/>// 在.m文件重写下列方法<br/>- (CGRect)textRectForBounds:(CGRect)bounds {<br/>    CGRect paddedRect = UIEdgeInsetsInsetRect(bounds, self.insets);<br/>    if (self.rightViewMode == UITextFieldViewModeAlways || self.rightViewMode == UITextFieldViewModeUnlessEditing) {<br/>        return [self adjustRectWithWidthRightView:paddedRect];<br/>    }<br/>    return paddedRect;<br/>}<br/><br/>- (CGRect)placeholderRectForBounds:(CGRect)bounds {<br/>    CGRect paddedRect = UIEdgeInsetsInsetRect(bounds, self.insets);<br/><br/>    if (self.rightViewMode == UITextFieldViewModeAlways || self.rightViewMode == UITextFieldViewModeUnlessEditing) {<br/>        return [self adjustRectWithWidthRightView:paddedRect];<br/>    }<br/>    return paddedRect;<br/>}<br/><br/>- (CGRect)editingRectForBounds:(CGRect)bounds {<br/>    CGRect paddedRect = UIEdgeInsetsInsetRect(bounds, self.insets);<br/>    if (self.rightViewMode == UITextFieldViewModeAlways || self.rightViewMode == UITextFieldViewModeWhileEditing) {<br/>        return [self adjustRectWithWidthRightView:paddedRect];<br/>    }<br/>    return paddedRect;<br/>}<br/><br/>- (CGRect)adjustRectWithWidthRightView:(CGRect)bounds {<br/>    CGRect paddedRect = bounds;<br/>    paddedRect.size.width -= CGRectGetWidth(self.rightView.frame);<br/><br/>    return paddedRect;<br/>}</code></pre><h3>54、监听UISlider拖动状态</h3><pre><code>// 添加事件<br/>[slider addTarget:self action:@selector(sliderValurChanged:forEvent:) forControlEvents:UIControlEventValueChanged];<br/><br/>// 实现方法<br/>- (void)sliderValurChanged:(UISlider*)slider forEvent:(UIEvent*)event {<br/>    UITouch *touchEvent = [[event allTouches] anyObject];<br/>    switch (touchEvent.phase) {<br/>        case UITouchPhaseBegan:<br/>            NSLog(@&quot;开始拖动&quot;);<br/>            break;<br/>        case UITouchPhaseMoved:<br/>            NSLog(@&quot;正在拖动&quot;);<br/>            break;<br/>        case UITouchPhaseEnded:<br/>            NSLog(@&quot;结束拖动&quot;);<br/>            break;<br/>        default:<br/>            break;<br/>    }<br/>}</code></pre><h3>55、设置UITextField光标位置</h3><pre><code>// textField需要设置的textField，index要设置的光标位置<br/>- (void)cursorLocation:(UITextField *)textField index:(NSInteger)index<br/>{<br/>    NSRange range = NSMakeRange(index, 0);<br/>    UITextPosition *start = [textField positionFromPosition:[textField beginningOfDocument] offset:range.location];<br/>    UITextPosition *end = [textField positionFromPosition:start offset:range.length];<br/>    [textField setSelectedTextRange:[textField textRangeFromPosition:start toPosition:end]];<br/>}</code></pre><h3>56、去除webView底部黑色</h3><pre><code>    [webView setBackgroundColor:[UIColor clearColor]];<br/>    [webView setOpaque:NO];<br/><br/>    for (UIView *v1 in [webView subviews])<br/>    {<br/>        if ([v1 isKindOfClass:[UIScrollView class]])<br/>        {<br/>            for (UIView *v2 in v1.subviews)<br/>            {<br/>                if ([v2 isKindOfClass:[UIImageView class]])<br/>                {<br/>                    v2.hidden = YES;<br/>                }<br/>            }<br/>        }<br/>    }</code></pre><h3>57、获取collectionViewCell在屏幕中的frame</h3><pre><code>UICollectionViewLayoutAttributes *attributes = [collectionView layoutAttributesForItemAtIndexPath:indexPath];<br/>CGRect cellRect = attributes.frame;<br/>CGRect cellFrameInSuperview = [collectionView convertRect:cellRect toView:[cv superview]];</code></pre><h3>58、比较两个UIImage是否相等</h3><pre><code>- (BOOL)image:(UIImage *)image1 isEqualTo:(UIImage *)image2<br/>{<br/>    NSData *data1 = UIImagePNGRepresentation(image1);<br/>    NSData *data2 = UIImagePNGRepresentation(image2);<br/><br/>    return [data1 isEqual:data2];<br/>}</code></pre><h3>59、解决当UIScrollView上有UIButton的时候，触摸到button滑动不了的问题</h3><pre><code>// 子类化UIScrollView，并重写以下方法<br/>- (instancetype)initWithFrame:(CGRect)frame {<br/>    if (self = [super initWithFrame:frame]) {<br/>        self.delaysContentTouches = NO;<br/>    }<br/><br/>    return self;<br/>}<br/><br/>- (BOOL)touchesShouldCancelInContentView:(UIView *)view {<br/>    if ([view isKindOfClass:UIButton.class]) {<br/>        return YES;<br/>    }<br/><br/>    return [super touchesShouldCancelInContentView:view];<br/>}</code></pre><h3>60、UITextView中的文字添加阴影效果</h3><pre><code>- (void)setTextLayer:(UITextView *)textView color:(UIColor *)color<br/>{<br/>    CALayer *textLayer = ((CALayer *)[textView.layer.sublayers objectAtIndex:0]);<br/>    textLayer.shadowColor = color.CGColor;<br/>    textLayer.shadowOffset = CGSizeMake(0.0f, 1.0f);<br/>    textLayer.shadowOpacity = 1.0f;<br/>    textLayer.shadowRadius = 1.0f;<br/>}</code></pre><h3>61、MD5加密</h3><pre><code>+ (NSString *)md5:(NSString *)str<br/>{<br/>    const char *concat_str = [str UTF8String];<br/>    unsigned char result[CC_MD5_DIGEST_LENGTH];<br/>    CC_MD5(concat_str, (unsigned int)strlen(concat_str), result);<br/>    NSMutableString *hash = [NSMutableString string];<br/>    for (int i =0; i &lt;16; i++){<br/>        [hash appendFormat:@&quot;%02X&quot;, result[i]];<br/>    }<br/>    return [hash uppercaseString];<br/>}</code></pre><h3>62、base64加密</h3><pre><code>@interface NSData (Base64)<br/>/**<br/> *  @brief  字符串base64后转data<br/> */<br/>+ (NSData *)dataWithBase64EncodedString:(NSString *)string<br/>{<br/>    if (![string length]) return nil;<br/>    NSData *decoded = nil;<br/>#if __MAC_OS_X_VERSION_MIN_REQUIRED &lt; __MAC_10_9 || __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_7_0<br/>    if (![NSData instancesRespondToSelector:@selector(initWithBase64EncodedString:options:)])<br/>    {<br/>#pragma clang diagnostic push<br/>#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;<br/>        decoded = [[self alloc] initWithBase64Encoding:[string stringByReplacingOccurrencesOfString:@&quot;[^A-Za-z0-9+/=]&quot; withString:@&quot;&quot; options:NSRegularExpressionSearch range:NSMakeRange(0, [string length])]];<br/>#pragma clang diagnostic pop<br/>    }<br/>    else<br/>#endif<br/>    {<br/>        decoded = [[self alloc] initWithBase64EncodedString:string options:NSDataBase64DecodingIgnoreUnknownCharacters];<br/>    }<br/>    return [decoded length]? decoded: nil;<br/>}<br/>/**<br/> *  @brief  NSData转string<br/> *  @param wrapWidth 换行长度  76  64<br/> */<br/>- (NSString *)base64EncodedStringWithWrapWidth:(NSUInteger)wrapWidth<br/>{<br/>    if (![self length]) return nil;<br/>    NSString *encoded = nil;<br/>#if __MAC_OS_X_VERSION_MIN_REQUIRED &lt; __MAC_10_9 || __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_7_0<br/>    if (![NSData instancesRespondToSelector:@selector(base64EncodedStringWithOptions:)])<br/>    {<br/>#pragma clang diagnostic push<br/>#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;<br/>        encoded = [self base64Encoding];<br/>#pragma clang diagnostic pop<br/><br/>    }<br/>    else<br/>#endif<br/>    {<br/>        switch (wrapWidth)<br/>        {<br/>            case 64:<br/>            {<br/>                return [self base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];<br/>            }<br/>            case 76:<br/>            {<br/>                return [self base64EncodedStringWithOptions:NSDataBase64Encoding76CharacterLineLength];<br/>            }<br/>            default:<br/>            {<br/>                encoded = [self base64EncodedStringWithOptions:(NSDataBase64EncodingOptions)0];<br/>            }<br/>        }<br/>    }<br/>    if (!wrapWidth || wrapWidth &gt;= [encoded length])<br/>    {<br/>        return encoded;<br/>    }<br/>    wrapWidth = (wrapWidth / 4) * 4;<br/>    NSMutableString *result = [NSMutableString string];<br/>    for (NSUInteger i = 0; i &lt; [encoded length]; i+= wrapWidth)<br/>    {<br/>        if (i + wrapWidth &gt;= [encoded length])<br/>        {<br/>            [result appendString:[encoded substringFromIndex:i]];<br/>            break;<br/>        }<br/>        [result appendString:[encoded substringWithRange:NSMakeRange(i, wrapWidth)]];<br/>        [result appendString:@&quot;\r\n&quot;];<br/>    }<br/>    return result;<br/>}<br/>/**<br/> *  @brief  NSData转string 换行长度默认64<br/> */<br/>- (NSString *)base64EncodedString<br/>{<br/>    return [self base64EncodedStringWithWrapWidth:0];<br/>}</code></pre><h3>63、AES加密</h3><pre><code>#import &lt;CommonCrypto/CommonCryptor.h&gt;<br/>@interface NSData (AES)<br/>/**<br/> *  利用AES加密数据<br/> */<br/>- (NSData*)encryptedWithAESUsingKey:(NSString*)key andIV:(NSData*)iv {<br/><br/>    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];<br/><br/>    size_t dataMoved;<br/>    NSMutableData *encryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSizeAES128];<br/><br/>    CCCryptorStatus status = CCCrypt(kCCEncrypt,kCCAlgorithmAES128,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,encryptedData.mutableBytes, encryptedData.length,&amp;dataMoved);<br/><br/>    if (status == kCCSuccess) {<br/>        encryptedData.length = dataMoved;<br/>        return encryptedData;<br/>    }<br/><br/>    return nil;<br/><br/>}<br/><br/>/**<br/> *  @brief  利用AES解密据<br/> */<br/>- (NSData*)decryptedWithAESUsingKey:(NSString*)key andIV:(NSData*)iv {<br/><br/>    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];<br/><br/>    size_t dataMoved;<br/>    NSMutableData *decryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSizeAES128];<br/><br/>    CCCryptorStatus result = CCCrypt(kCCDecrypt,kCCAlgorithmAES128,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,decryptedData.mutableBytes, decryptedData.length,&amp;dataMoved);<br/><br/>    if (result == kCCSuccess) {<br/>        decryptedData.length = dataMoved;<br/>        return decryptedData;<br/>    }<br/><br/>    return nil;<br/><br/>}</code></pre><h3>64、3DES加密</h3><pre><code>#import &lt;CommonCrypto/CommonCryptor.h&gt;<br/>@interface NSData (3DES)<br/>/**<br/> *  利用3DES加密数据<br/> */<br/>- (NSData*)encryptedWith3DESUsingKey:(NSString*)key andIV:(NSData*)iv {<br/><br/>    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];<br/><br/>    size_t dataMoved;<br/>    NSMutableData *encryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSize3DES];<br/><br/>    CCCryptorStatus result = CCCrypt(kCCEncrypt,kCCAlgorithm3DES,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,encryptedData.mutableBytes,encryptedData.length,&amp;dataMoved);<br/><br/>    if (result == kCCSuccess) {<br/>        encryptedData.length = dataMoved;<br/>        return encryptedData;<br/>    }<br/><br/>    return nil;<br/><br/>}<br/>/**<br/> *  @brief   利用3DES解密数据<br/> */<br/>- (NSData*)decryptedWith3DESUsingKey:(NSString*)key andIV:(NSData*)iv {<br/><br/>    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];<br/><br/>    size_t dataMoved;<br/>    NSMutableData *decryptedData = [NSMutableData dataWithLength:self.length + kCCBlockSize3DES];<br/><br/>    CCCryptorStatus result = CCCrypt(kCCDecrypt,kCCAlgorithm3DES,kCCOptionPKCS7Padding,keyData.bytes,keyData.length,iv.bytes,self.bytes,self.length,decryptedData.mutableBytes,decryptedData.length,&amp;dataMoved);<br/><br/>    if (result == kCCSuccess) {<br/>        decryptedData.length = dataMoved;<br/>        return decryptedData;<br/>    }<br/><br/>    return nil;<br/><br/>}</code></pre><h3>65、单个页面多个网络请求的情况，需要监听所有网络请求结束后刷新UI</h3><pre><code>dispatch_group_t group = dispatch_group_create();<br/>    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.wzb.test.www&quot;, DISPATCH_QUEUE_SERIAL);<br/>    dispatch_group_enter(group);<br/>    dispatch_group_async(group, serialQueue, ^{<br/>        // 网络请求一<br/>        [WebClick getDataSuccess:^(ResponseModel *model) {<br/>            dispatch_group_leave(group);<br/>        } failure:^(NSString *err) {<br/>            dispatch_group_leave(group);<br/>        }];<br/>    });<br/>    dispatch_group_enter(group);<br/>    dispatch_group_async(group, serialQueue, ^{<br/>        // 网络请求二<br/>        [WebClick getDataSuccess:getBigTypeRM onSuccess:^(ResponseModel *model) {<br/>            dispatch_group_leave(group);<br/>        }                                  failure:^(NSString *errorString) {<br/>            dispatch_group_leave(group);<br/>        }];<br/>    });<br/>    dispatch_group_enter(group);<br/>    dispatch_group_async(group, serialQueue, ^{<br/>        // 网络请求三<br/>        [WebClick getDataSuccess:^{<br/>            dispatch_group_leave(group);<br/>        } failure:^(NSString *errorString) {<br/>            dispatch_group_leave(group);<br/>        }];<br/>    });<br/><br/>    // 所有网络请求结束后会来到这个方法<br/>    dispatch_group_notify(group, serialQueue, ^{<br/>        dispatch_async(dispatch_get_global_queue(0, 0), ^{<br/>            dispatch_async(dispatch_get_main_queue(), ^{<br/>                // 刷新UI<br/>            });<br/>        });<br/>    });</code></pre><h3>66、解决openUrl延时问题</h3><pre><code>// 方法一<br/>dispatch_async(dispatch_get_main_queue(), ^{<br/><br/>    UIApplication *application = [UIApplication sharedApplication];<br/>    if ([application respondsToSelector:@selector(openURL:options:completionHandler:)]) {<br/>        [application openURL:URL options:@{}<br/>           completionHandler:nil];<br/>    } else {<br/>        [application openURL:URL];<br/>    }<br/>    });<br/>// 方法二<br/>[self performSelector:@selector(redirectToURL:) withObject:url afterDelay:0.1];<br/><br/>- (void) redirectToURL<br/>{<br/>UIApplication *application = [UIApplication sharedApplication];<br/>    if ([application respondsToSelector:@selector(openURL:options:completionHandler:)]) {<br/>        [application openURL:URL options:@{}<br/>           completionHandler:nil];<br/>    } else {<br/>        [application openURL:URL];<br/>    }<br/>}</code></pre><h3>67、页面跳转实现翻转动画</h3><pre><code>// modal方式<br/>    TestViewController *vc = [[TestViewController alloc] init];<br/>    vc.view.backgroundColor = [UIColor redColor];<br/>    vc.modalTransitionStyle = UIModalTransitionStyleCoverVertical;<br/>    [self presentViewController:vc animated:YES completion:nil];<br/><br/>// push方式<br/>    TestViewController *vc = [[TestViewController alloc] init];<br/>    vc.view.backgroundColor = [UIColor redColor];<br/>    [UIView beginAnimations:@&quot;View Flip&quot; context:nil];<br/>    [UIView setAnimationDuration:0.80];<br/>    [UIView setAnimationCurve:UIViewAnimationCurveEaseInOut];<br/>    [UIView setAnimationTransition:UIViewAnimationTransitionFlipFromRight forView:self.navigationController.view cache:NO];<br/>    [self.navigationController pushViewController:vc animated:YES];<br/>    [UIView commitAnimations];</code></pre><h3>68、tableView实现无限滚动</h3><pre><code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView<br/>{<br/>    CGFloat actualPosition = scrollView.contentOffset.y;<br/>    CGFloat contentHeight = scrollView.contentSize.height - scrollView.frame.size.height;<br/>    if (actualPosition &gt;= contentHeight) {<br/>        [self.dataArr addObjectsFromArray:self.dataArr];<br/>        [self.tableView reloadData];<br/>    }<br/>}</code></pre><h3>69、代码方式调整屏幕亮度</h3><pre><code>// brightness属性值在0-1之间，0代表最小亮度，1代表最大亮度<br/>[[UIScreen mainScreen] setBrightness:0.5];</code></pre><h3>70、获取当前应用CUP用量</h3><pre><code>float cpu_usage()<br/>{<br/>    kern_return_t kr;<br/>    task_info_data_t tinfo;<br/>    mach_msg_type_number_t task_info_count;<br/><br/>    task_info_count = TASK_INFO_MAX;<br/>    kr = task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)tinfo, &amp;task_info_count);<br/>    if (kr != KERN_SUCCESS) {<br/>        return -1;<br/>    }<br/><br/>    task_basic_info_t      basic_info;<br/>    thread_array_t         thread_list;<br/>    mach_msg_type_number_t thread_count;<br/><br/>    thread_info_data_t     thinfo;<br/>    mach_msg_type_number_t thread_info_count;<br/><br/>    thread_basic_info_t basic_info_th;<br/>    uint32_t stat_thread = 0; // Mach threads<br/><br/>    basic_info = (task_basic_info_t)tinfo;<br/><br/>    // get threads in the task<br/>    kr = task_threads(mach_task_self(), &amp;thread_list, &amp;thread_count);<br/>    if (kr != KERN_SUCCESS) {<br/>        return -1;<br/>    }<br/>    if (thread_count &gt; 0)<br/>        stat_thread += thread_count;<br/><br/>    long tot_sec = 0;<br/>    long tot_usec = 0;<br/>    float tot_cpu = 0;<br/>    int j;<br/><br/>    for (j = 0; j &lt; (int)thread_count; j++)<br/>    {<br/>        thread_info_count = THREAD_INFO_MAX;<br/>        kr = thread_info(thread_list[j], THREAD_BASIC_INFO,<br/>                         (thread_info_t)thinfo, &amp;thread_info_count);<br/>        if (kr != KERN_SUCCESS) {<br/>            return -1;<br/>        }<br/><br/>        basic_info_th = (thread_basic_info_t)thinfo;<br/><br/>        if (!(basic_info_th-&gt;flags &amp; TH_FLAGS_IDLE)) {<br/>            tot_sec = tot_sec + basic_info_th-&gt;user_time.seconds + basic_info_th-&gt;system_time.seconds;<br/>            tot_usec = tot_usec + basic_info_th-&gt;user_time.microseconds + basic_info_th-&gt;system_time.microseconds;<br/>            tot_cpu = tot_cpu + basic_info_th-&gt;cpu_usage / (float)TH_USAGE_SCALE * 100.0;<br/>        }<br/><br/>    } // for each thread<br/><br/>    kr = vm_deallocate(mach_task_self(), (vm_offset_t)thread_list, thread_count * sizeof(thread_t));<br/>    assert(kr == KERN_SUCCESS);<br/><br/>    return tot_cpu;<br/>}</code></pre><h3>71、float数据取整四舍五入</h3><pre><code>    CGFloat f = 4.65;<br/>    NSLog(@&quot;%d&quot;, (int)f);    // 打印结果4<br/><br/>    CGFloat f = 4.65;<br/>    NSLog(@&quot;%d&quot;, (int)round(f));    // 打印结果5</code></pre><h3>72、删除UISearchBar系统默认边框</h3><pre><code>    // 方法一<br/>    searchBar.searchBarStyle = UISearchBarStyleMinimal;<br/><br/>    // 方法二<br/>    [searchBar setBackgroundImage:[[UIImage alloc]init]];<br/><br/>    // 方法三<br/>    searchBar.barTintColor = [UIColor whiteColor];</code></pre><h3>73、为UICollectionViewCell设置圆角和阴影</h3><pre><code>cell.contentView.layer.cornerRadius = 2.0f;<br/>cell.contentView.layer.borderWidth = 1.0f;<br/>cell.contentView.layer.borderColor = [UIColor clearColor].CGColor;<br/>cell.contentView.layer.masksToBounds = YES;<br/><br/>cell.layer.shadowColor = [UIColor lightGrayColor].CGColor;<br/>cell.layer.shadowOffset = CGSizeMake(0, 2.0f);<br/>cell.layer.shadowRadius = 2.0f;<br/>cell.layer.shadowOpacity = 1.0f;<br/>cell.layer.masksToBounds = NO;<br/>cell.layer.shadowPath = [UIBezierPath bezierPathWithRoundedRect:cell.bounds cornerRadius:cell.contentView.layer.cornerRadius].CGPath;</code></pre><h3>74、让正在滑动的scrollView停止滚动(不是禁止，而是暂时停止滚动)</h3><pre><code>[scrollView setContentOffset:scrollView.contentOffset animated:NO];</code></pre><h3>75、使用xib设置UIView的边框、圆角</h3><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">圆角和边框看下图即可设置</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><img src="稀土掘金  (三十) iOS常用代码总结二_files/222.png" type="image/png" data-filename="222.png" width="620"/><br/></div></blockquote><div><br/></div><div>xib设置圆角边框.png</div><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">但是增加layer.borderColor的keyPath设置边框颜色并不能起作用，后来查了资料，这里应该用layer.borderUIColor，但是这里设置的颜色不起作用，无论设置什么颜色显示出来的都是黑色的。后来又去查了下，有种解决方案是给CALayer添加一个分类，提供一个 - (void)setBorderUIColor:(UIColor *)color;方法就可以解决了，实现如下：</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><img src="稀土掘金  (三十) iOS常用代码总结二_files/333.png" type="image/png" data-filename="333.png" width="315"/><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div></blockquote><div><br/></div><div>xib设置边框颜色.png</div><pre><code>#import &quot;CALayer+BorderColor.h&quot;<br/><br/>@implementation CALayer (BorderColor)<br/><br/>- (void)setBorderUIColor:(UIColor *)color<br/>{<br/>    self.borderColor = color.CGColor;<br/>}</code></pre><h3>76、根据经纬度获取城市等信息</h3><pre><code>// 创建经纬度<br/>    CLLocation *location = [[CLLocation alloc] initWithLatitude:latitude longitude:longitude];<br/>    //创建一个译码器<br/>    CLGeocoder *cLGeocoder = [[CLGeocoder alloc] init];<br/>    [cLGeocoder reverseGeocodeLocation:userLocation completionHandler:^(NSArray *placemarks, NSError *error) {<br/>        CLPlacemark *place = [placemarks objectAtIndex:0];<br/>        // 位置名<br/>    　　NSLog(@&quot;name,%@&quot;,<a href="http://place.name">place.name</a>);<br/>    　　// 街道<br/>    　　NSLog(@&quot;thoroughfare,%@&quot;,place.thoroughfare);<br/>    　　// 子街道<br/>    　　NSLog(@&quot;subThoroughfare,%@&quot;,place.subThoroughfare);<br/>    　　// 市<br/>    　　NSLog(@&quot;locality,%@&quot;,place.locality);<br/>    　　// 区<br/>    　　NSLog(@&quot;subLocality,%@&quot;,place.subLocality); <br/>    　　// 国家<br/>    　　NSLog(@&quot;country,%@&quot;,place.country);<br/>        }<br/>    }];<br/><br/>/*  CLPlacemark中属性含义<br/>name                    地名<br/><br/>thoroughfare            街道<br/><br/>subThoroughfare        街道相关信息，例如门牌等<br/><br/>locality                城市<br/><br/>subLocality            城市相关信息，例如标志性建筑<br/><br/>administrativeArea      直辖市<br/><br/>subAdministrativeArea  其他行政区域信息（自治区等）<br/><br/>postalCode              邮编<br/><br/>ISOcountryCode          国家编码<br/><br/>country                国家<br/><br/>inlandWater            水源，湖泊<br/><br/>ocean                  海洋<br/><br/>areasOfInterest        关联的或利益相关的地标<br/>*/</code></pre><h3>77、如何防止添加多个NSNotification观察者？</h3><pre><code>// 解决方案就是添加观察者之前先移除下这个观察者<br/>[[NSNotificationCenter defaultCenter] removeObserver:observer name:name object:object];<br/>        [[NSNotificationCenter defaultCenter] addObserver:observer selector:selector name:name object:object];</code></pre><h3>78、将一个xib添加到另外一个xib上</h3><pre><code>// 假设你的自定义view名字为CustomView，你需要在CustomView.m中重写 `- (instancetype)initWithCoder:(NSCoder *)aDecoder` 方法，代码如下：<br/>- (instancetype)initWithCoder:(NSCoder *)aDecoder {<br/>    if ((self = [super initWithCoder:aDecoder])) {<br/>        [self addSubview:[[[NSBundle mainBundle] loadNibNamed:@&quot;CustomView&quot; owner:self options:nil] objectAtIndex:0]];<br/>    }<br/>    return self;<br/>}</code></pre><pre><img src="稀土掘金  (三十) iOS常用代码总结二_files/444.png" type="image/png" data-filename="444.png" width="620"/><br/></pre><pre><code><br/></code></pre><div><br/></div><div>将一个xib添加到另外一个xib上.png</div><h3>79、处理字符串，使其首字母大写</h3><pre><code>    NSString *str = @&quot;abcdefghijklmn&quot;;<br/>    NSString *resultStr;<br/>    if (str &amp;&amp; str.length &gt; 0) {<br/>        resultStr = [str stringByReplacingCharactersInRange:NSMakeRange(0,1) withString:[[str substringToIndex:1] capitalizedString]];<br/>    }<br/>    NSLog(@&quot;%@&quot;, resultStr);</code></pre><h3>80、判断一个UIAlertView/UIAlertController是否显示</h3><pre><code>// UIAlertView自带属性<br/>if (alert.visible)<br/>{<br/>      NSLog(@&quot;显示了&quot;);<br/>} else {<br/>      NSLog(@&quot;未显示&quot;);<br/>}<br/><br/>// UIAlertController没有visible属性，需要自己判断，添加一个全局变量 BOOL visible<br/>UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;Title&quot; message:@&quot;message&quot; preferredStyle:UIAlertControllerStyleAlert];<br/>    UIAlertAction *alertAction = [UIAlertAction actionWithTitle:@&quot;ActionTitle&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) {<br/>        self.visible = NO;<br/>    }];<br/>    UIAlertAction *calcelAction = [UIAlertAction actionWithTitle:@&quot;calcelTitle&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) {<br/>        self.visible = NO;<br/>    }];<br/>    [alertController addAction:alertAction];<br/>    [alertController addAction:calcelAction];<br/>    [self presentViewController:alertController animated:YES completion:^{<br/>        self.visible = YES;<br/>    }];</code></pre><h3>81、获取字符串中的数字</h3><pre><code>- (NSString *)getNumberFromStr:(NSString *)str<br/>{<br/>    NSCharacterSet *nonDigitCharacterSet = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];<br/>    return [[str componentsSeparatedByCharactersInSet:nonDigitCharacterSet] componentsJoinedByString:@&quot;&quot;];<br/>}<br/><br/>    NSLog(@&quot;%@&quot;, [self getNumberFromStr:@&quot;a0b0c1d2e3f4fda8fa8fad9fsad23&quot;]); // 00123488923</code></pre><h3>82、为UIView的某个方向添加边框</h3><pre><code>// 添加UIView分类<br/><br/>// UIView+WZB.h<br/>#import &lt;UIKit/UIKit.h&gt;<br/><br/><br/>/**<br/> 边框方向<br/><br/> - WZBBorderDirectionTop: 顶部<br/> - WZBBorderDirectionLeft: 左边<br/> - WZBBorderDirectionBottom: 底部<br/> - WZBBorderDirectionRight: 右边<br/> */<br/>typedef NS_ENUM(NSInteger, WZBBorderDirectionType) {<br/>    WZBBorderDirectionTop = 0,<br/>    WZBBorderDirectionLeft,<br/>    WZBBorderDirectionBottom,<br/>    WZBBorderDirectionRight<br/>};<br/><br/>@interface UIView (WZB)<br/><br/><br/>/**<br/> 为UIView的某个方向添加边框<br/><br/> @param direction 边框方向<br/> @param color 边框颜色<br/> @param width 边框宽度<br/> */<br/>- (void)wzb_addBorder:(WZBBorderDirectionType)direction color:(UIColor *)color width:(CGFloat)width;<br/><br/>@end<br/><br/>// UIView+WZB.m<br/>#import &quot;UIView+WZB.h&quot;<br/><br/>@implementation UIView (WZB)<br/><br/>- (void)wzb_addBorder:(WZBBorderDirectionType)direction color:(UIColor *)color width:(CGFloat)width<br/>{<br/>    CALayer *border = [CALayer layer];<br/>    border.backgroundColor = color.CGColor;<br/>    switch (direction) {<br/>        case WZBBorderDirectionTop:<br/>        {<br/>            border.frame = CGRectMake(0.0f, 0.0f, self.bounds.size.width, width);<br/>        }<br/>            break;<br/>        case WZBBorderDirectionLeft:<br/>        {<br/>            border.frame = CGRectMake(0.0f, 0.0f, width, self.bounds.size.height);<br/>        }<br/>            break;<br/>        case WZBBorderDirectionBottom:<br/>        {<br/>            border.frame = CGRectMake(0.0f, self.bounds.size.height - width, self.bounds.size.width, width);<br/>        }<br/>            break;<br/>        case WZBBorderDirectionRight:<br/>        {<br/>            border.frame = CGRectMake(self.bounds.size.width - width, 0, width, self.bounds.size.height);<br/>        }<br/>            break;<br/><br/>        default:<br/>            break;<br/>    }<br/>    [self.layer addSublayer:border];<br/>}</code></pre><h3>83、通过属性设置UISwitch、UIProgressView等控件的宽高</h3><pre><code>mySwitch.transform = CGAffineTransformMakeScale(5.0f, 5.0f);<br/><br/>progressView.transform = CGAffineTransformMakeScale(5.0f, 5.0f);</code></pre><h3>84、自动搜索功能，用户连续输入的时候不搜索，用户停止输入的时候自动搜索(我这里设置的是0.5s，可根据需求更改)</h3><pre><code>// 输入框文字改变的时候调用<br/>-(void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchText{<br/>    // 先取消调用搜索方法<br/>    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(searchNewResult) object:nil];<br/>    // 0.5秒后调用搜索方法<br/>    [self performSelector:@selector(searchNewResult) withObject:nil afterDelay:0.5];<br/>}</code></pre><h3>85、修改UISearchBar的占位文字颜色</h3><pre><code>    // 方法一（推荐使用）<br/>    UITextField *searchField = [searchBar valueForKey:@&quot;_searchField&quot;];<br/>    [searchField setValue:[UIColor blueColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];<br/><br/>    // 方法二（已过期）<br/>    [[UILabel appearanceWhenContainedIn:[UISearchBar class], nil] setTextColor:[UIColor redColor]];<br/><br/>    // 方法三（已过期）<br/>    NSDictionary *placeholderAttributes = @{NSForegroundColorAttributeName : [UIColor redColor], NSFontAttributeName : [UIFont fontWithName:@&quot;HelveticaNeue&quot; size:15],};<br/>    NSAttributedString *attributedPlaceholder = [[NSAttributedString alloc] initWithString:searchBar.placeholder attributes:placeholderAttributes];<br/>    [[UITextField appearanceWhenContainedIn:[UISearchBar class], nil] setAttributedPlaceholder:attributedPlaceholder];</code></pre><h3>86、某个界面多个事件同时响应引起的问题(比如，两个button同时按push到新界面，两个都会响应，可能导致push重叠)</h3><pre><code>// UIView有个属性叫做exclusiveTouch，设置为YES后，其响应事件会和其他view互斥(有其他view事件响应的时候点击它不起作用)<br/>view.exclusiveTouch = YES;<br/><br/>// 一个一个设置太麻烦了，可以全局设置<br/>[[UIView appearance] setExclusiveTouch:YES];<br/><br/>// 或者只设置button<br/>[[UIButton appearance] setExclusiveTouch:YES];</code></pre><h3>87、修改tabBar的frame</h3><pre><code>// 子类化UITabBarViewController，我这里以修改tabBar高度为例，重写viewWillLayoutSubviews方法<br/>#import &quot;WZBTabBarViewController.h&quot;<br/><br/>@interface WZBTabBarViewController ()<br/><br/>@end<br/><br/>@implementation WZBTabBarViewController<br/>- (void)viewWillLayoutSubviews {<br/><br/>    CGRect tabFrame = self.tabBar.frame;<br/>    tabFrame.size.height = 100;<br/>    tabFrame.origin.y = self.view.frame.size.height - 100;<br/>    self.tabBar.frame = tabFrame;<br/>}<br/>@end</code></pre><h3>88、修改键盘背景颜色</h3><pre><code>// 设置某个键盘颜色<br/>    textField.keyboardAppearance = UIKeyboardAppearanceAlert;<br/><br/>// 设置工程中所有键盘颜色<br/>[[UITextField appearance] setKeyboardAppearance:UIKeyboardAppearanceAlert];</code></pre><h3>89、修改image颜色</h3><pre><code>UIImage *image = [UIImage imageNamed:@&quot;test&quot;];<br/>    imageView.image = [image imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];<br/>    CGRect rect = CGRectMake(0, 0, image.size.width, image.size.height);<br/>    UIGraphicsBeginImageContext(rect.size);<br/>    CGContextRef context = UIGraphicsGetCurrentContext();<br/>    CGContextClipToMask(context, rect, image.CGImage);<br/>    CGContextSetFillColorWithColor(context, [[UIColor redColor] CGColor]);<br/>    CGContextFillRect(context, rect);<br/>    UIImage *img = UIGraphicsGetImageFromCurrentImageContext();<br/>    UIGraphicsEndImageContext();<br/><br/>    UIImage *flippedImage = [UIImage imageWithCGImage:img.CGImage scale:1.0 orientation: UIImageOrientationDownMirrored];<br/>    imageView.image = flippedImage;</code></pre><h3>90、动画执行removeFromSuperview</h3><pre><code>    [UIView animateWithDuration:0.2<br/>                     animations:^{<br/>                         view.alpha = 0.0f;<br/>                     } completion:^(BOOL finished){<br/>                         [view removeFromSuperview];<br/>                     }];</code></pre><h3>91、启动页显示延时</h3><pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions<br/>{<br/>//  延时10s<br/>    sleep(10);<br/>    return YES;<br/>}</code></pre><h3>92、设置UIButton高亮时的背景颜色</h3><pre><code>// 方法一、子类化UIButton，重写setHighlighted:方法，代码如下<br/>#import &quot;WZBButton.h&quot;<br/><br/>@implementation WZBButton<br/><br/>- (void)setHighlighted:(BOOL)highlighted {<br/>    [super setHighlighted:highlighted];<br/><br/>    UIColor *normalColor = [UIColor greenColor];<br/>    UIColor *highlightedColor = [UIColor redColor];<br/>    self.backgroundColor = highlighted ? highlightedColor : normalColor;<br/><br/>}<br/><br/>// 方法二、利用setBackgroundImage:forState:方法<br/>[button setBackgroundImage:[self imageWithColor:[UIColor blueColor]] forState:UIControlStateHighlighted];<br/><br/>- (UIImage *)imageWithColor:(UIColor *)color {<br/>    CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f);<br/>    UIGraphicsBeginImageContext(rect.size);<br/>    CGContextRef context = UIGraphicsGetCurrentContext();<br/><br/>    CGContextSetFillColorWithColor(context, [color CGColor]);<br/>    CGContextFillRect(context, rect);<br/><br/>    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();<br/>    UIGraphicsEndImageContext();<br/><br/>    return image;<br/>}</code></pre><h3>93、关于图片拉伸</h3><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">推荐看这个博客，讲的很详细</span><a href="http://blog.csdn.net/q199109106q/article/details/8615661" style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">http://blog.csdn.net/q199109106q/article/details/8615661</a></div></blockquote><h3>94、利用runtime获取一个类所有属性</h3><pre><code>- (NSArray *)allPropertyNames:(Class)aClass<br/>{<br/>    unsigned count;<br/>    objc_property_t *properties = class_copyPropertyList(aClass, &amp;count);<br/><br/>    NSMutableArray *rv = [NSMutableArray array];<br/><br/>    unsigned i;<br/>    for (i = 0; i &lt; count; i++)<br/>    {<br/>        objc_property_t property = properties[i];<br/>        NSString *name = [NSString stringWithUTF8String:property_getName(property)];<br/>        [rv addObject:name];<br/>    }<br/><br/>    free(properties);<br/><br/>    return rv;<br/>}</code></pre><h3>95、设置textView的某段文字变成其他颜色</h3><pre><code>- (void)setupTextView:(UITextView *)textView text:(NSString *)text color:(UIColor *)color {<br/>    NSMutableAttributedString *string = [[NSMutableAttributedString alloc]initWithString:textView.text];<br/>    [string addAttribute:NSForegroundColorAttributeName value:color range:[textView.text rangeOfString:text]];<br/>    [textView setAttributedText:string];<br/>}</code></pre><h3>96、让push跳转动画像modal跳转动画那样效果(从下往上推上来)</h3><pre><code>- (void)push<br/>{<br/>TestViewController *vc = [[TestViewController alloc] init];<br/>    vc.view.backgroundColor = [UIColor redColor];<br/>    CATransition* transition = [CATransition animation];<br/>    transition.duration = 0.4f;<br/>    transition.type = kCATransitionMoveIn;<br/>    transition.subtype = kCATransitionFromTop;<br/>    [self.navigationController.view.layer addAnimation:transition forKey:kCATransition];<br/>    [self.navigationController pushViewController:vc animated:NO];<br/>}<br/><br/>- (void)pop<br/>{<br/>CATransition* transition = [CATransition animation];<br/>    transition.duration = 0.4f;<br/>    transition.type = kCATransitionReveal;<br/>    transition.subtype = kCATransitionFromBottom;<br/>    [self.navigationController.view.layer addAnimation:transition forKey:kCATransition];<br/>    [self.navigationController popViewControllerAnimated:NO];<br/>}</code></pre><h3>97、上传图片太大，压缩图片</h3><pre><code>-(UIImage *)resizeImage:(UIImage *)image<br/>{<br/>    float actualHeight = image.size.height;<br/>    float actualWidth = image.size.width;<br/>    float maxHeight = 300.0;<br/>    float maxWidth = 400.0;<br/>    float imgRatio = actualWidth/actualHeight;<br/>    float maxRatio = maxWidth/maxHeight;<br/>    float compressionQuality = 0.5;//50 percent compression<br/><br/>    if (actualHeight &gt; maxHeight || actualWidth &gt; maxWidth)<br/>    {<br/>        if(imgRatio &lt; maxRatio)<br/>        {<br/>            //adjust width according to maxHeight<br/>            imgRatio = maxHeight / actualHeight;<br/>            actualWidth = imgRatio * actualWidth;<br/>            actualHeight = maxHeight;<br/>        }<br/>        else if(imgRatio &gt; maxRatio)<br/>        {<br/>            //adjust height according to maxWidth<br/>            imgRatio = maxWidth / actualWidth;<br/>            actualHeight = imgRatio * actualHeight;<br/>            actualWidth = maxWidth;<br/>        }<br/>        else<br/>        {<br/>            actualHeight = maxHeight;<br/>            actualWidth = maxWidth;<br/>        }<br/>    }<br/><br/>    CGRect rect = CGRectMake(0.0, 0.0, actualWidth, actualHeight);<br/>    UIGraphicsBeginImageContext(rect.size);<br/>    [image drawInRect:rect];<br/>    UIImage *img = UIGraphicsGetImageFromCurrentImageContext();<br/>    NSData *imageData = UIImageJPEGRepresentation(img, compressionQuality);<br/>    UIGraphicsEndImageContext();<br/><br/>    return [UIImage imageWithData:imageData];<br/><br/>}</code></pre><div><br/></div><div><br/></div><div><span style="direction: ltr; font-family: SimSun; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%; font-weight: bold;">笔记整理：Edison</span></div><div style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: SimSun; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em; border-width: 100%; font-weight: bold; color: rgb(79, 129, 189); unicode-bidi: embed;">联系方式：QQ：277593 （笔记意见建议可加此Q，专人更新此笔记）；</span></div><div style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: SimSun; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em; border-width: 100%; color: rgb(79, 129, 189); unicode-bidi: embed;"> </span></div><div><span style="direction: ltr; font-family: SimSun; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%; font-weight: bold;">注：小道途径获取到的笔记，无法自动更新，请谅解！(笔记平均每月更新一次，祝各位都能拿到心仪的offer)</span><span style="direction: ltr; font-family: SimSun; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%;"> </span></div></span>
</div></body></html> 