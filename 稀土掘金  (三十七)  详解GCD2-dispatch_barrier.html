<html>
<head>
  <title>稀土掘金  (三十七) : 详解GCD&lt;2&gt;-dispatch_barrier</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <meta name="application-data:corenote-hostUUID" content="C8940BC2-A53C-4B55-B59C-4779464BC778"/>
  <meta name="application-data:corenote-localUUID" content="8D5D8D32-357D-42E5-A397-12EA18CA11A8"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="924"/>
<h1>稀土掘金  (三十七) : 详解GCD&lt;2&gt;-dispatch_barrier</h1>

<div><span><div><span style="font-weight: bold;">dispatch_barrier</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">讲完了GCD详解一。我们来看看一个不太常用的GCD。dispatch_barrier。 这个barrier我感觉使用霸道总裁来形容比较合适。这里借用raywenderlich上介绍barrier的一张图。</span></div><div><br style="font-weight: bold;"/></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image.png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="476"/><br/></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">看的有点懵逼？</span></div><div><span style="font-weight: bold;">不要紧。我来解释一下。 首先，在一个并行队列中，有多个线程在执行多个任务，在这个并行队列中，有一个dispatch_barrier任务。这样会有一个什么效果呢？ 就是，所有在这个dispatch_barrier之后的任务总会等待barrier之前的所有任务结束之后，才会执行。那么细心的同学可能会发现这里有个问题，既然所有在barrier之后的任务都会等待在barrier之前的任务结束之后执行，那么barrier本身执行是否会阻塞当前线程？ 所以，dispatch_barrier也是有两个方法的。dispatch_barrier_sync和dispatch_barrier_async.</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-size: 18px; font-weight: bold;">dispatch_barrier_sync</span></div><div><span style="font-weight: bold;">还是看代码理解的更快一点。代码如下：</span></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [1].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="472"/><br/></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [2].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="476"/><br/></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [3].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="477"/><br/></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">运行之后的输出结果是：</span></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [4].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="471"/><br/></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [5].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="477"/><br/></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [6].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="480"/><br/></div><div><span style="font-weight: bold;">ok，总结一下。</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">dispatch_barrier_sync确实是会在队列中充当一个栅栏的作用，凡是在他之后进入队列的任务，总会在dispatch_barrier_sync之前的所有任务执行完毕之后才执行。</span></div><div><span style="font-weight: bold;">见名知意，dispatch_barrier_sync是会在主线程执行队列中的任务的，所以，Running on Main Thread这句话会被阻塞，从而在barrier之后执行。</span></div><div><br style="font-weight: bold;"/></div><div><br/></div><div><span style="font-size: 18px; font-weight: bold;">dispatch_barrier_async</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">再看看dispatch_barrier_async执行的效果。</span></div><div><span style="font-weight: bold;">代码如下：</span></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [7].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="474"/><br/></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [8].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="471"/><br/></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [9].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="472"/><br/></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">结果如下：</span></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [10].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="474"/><br/></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [11].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="473"/><br/></div><div><span style="font-weight: bold;">dispatch_barrier_async会开辟一条新的线程执行其中的任务，所以不会阻塞当前线程。其他的功能和dispatch_barrier_sync相同。</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-size: 18px; font-weight: bold;">几个小问题</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">1.为什么我们只举了barrier和并行队列的例子，而没有举barrier和串行队列的例子？</span></div><div><span style="font-weight: bold;">因为，barrier和串行队列配合是完全没有意义的。barrier的目的是什么？目的是为了在某种情况下，同一个队列中一些并发任务必须在另一些并发任务之后执行，所以需要一个类似于拦截的功能，迫使后执”</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">“行的任务必须等待。那么，串行队列中的所有任务本身就是按照顺序执行的，那么又有什么必要使用拦截的功能呢？</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">2.在global queue中使用barrier没有意义，为什么？</span></div><div><span style="font-weight: bold;">barrier实现的基本条件是，要写在同一队列中。举个例子，你现在创建了两个并行队列，你在其中一个队列中插入了一个barrier任务，那么你不可能期待他可以在第二个队列中生效，对吧。同样的，每一次使用global queue，系统分配给你的可能是不同的并行队列，你在其中插入一个barrier任务，又有什么意义呢？</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">该做点什么了</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">思考一个问题，NSMutableDictionary是否是线程安全的？</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">做个测试：</span></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [12].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="472"/><br/></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [13].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="474"/><br/></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [14].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="474"/><br/></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">运行结果是，直接崩了。。 因为NSMutableDictionary不是线程安全的，任意一个线程在往字典里写入数据的时候是不允许有其他线程访问的，不管是读或者写都不可以。 所以，现在的任务就是，我们需要使用gcd来实现一个线程安全的NSMutableDictionary。</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">第一个方案，serial queue + dispatch_async</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">首先，串行队列能保证每一个读或者写操作都是按顺序执行的，并且会在同一个线程执行任务，dispatch_async又能保证读写操作均能在异步线程执行，所以不会卡当前线程。所以表面上看是没问题的。 关键的问题是，太慢了,因为你每次只会有一个线程读或者写。如果同时有一百个读的请求，那么你的数据必须要按照顺序，一个一个的读出来。所以这个方案行不通。</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">第二个方案，concurrent queue + dispatch_async</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">用这个方案意味着，我们可以多线程同时读取字典里的数据。但是我们得确保一个条件。我们读取字典数据的时候，必须保证没有别的线程在写。 所以，确定读取线程安全的条件变成了，如何迫使写的这个操作在同一时刻[…]</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">写数据。因为假如有多个写的操作，每一个写操作总会等待前一个写操作完成之后才执行。</span></div><div><span style="font-weight: bold;">所以代码如下：</span></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [15].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="474"/><br/></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [16].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="469"/><br/></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [17].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="473"/><br/></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [18].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="475"/><br/></div><div><img src="稀土掘金  (三十七)  详解GCD2-dispatch_barrier_files/Image [19].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="470"/><br/></div><div><span style="font-weight: bold;">这里可能会有人存疑，外部用__weak关键在声明weakSelf这个没什么问题，防止retain cycle。但里面为什么又用__strong声明了一个strongSelf？</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">这是因为，你享受了weak的好处，同时也要承担风险，由于不持有这个weakSelf，所以你无法保证在代码运行过程中，self不会被释放。</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">那可能又有人问了，你在外部用weak声明的原因是防止retain cycle，结果又在里面声明了一个strong，那不相当于做无用功了么。但问题是，在block内部声明的strongSelf是局部！</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">变量，他的生命周期只是在block内而已，当block执行完它自动就被销毁了。所以不会造成retain cycle。</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">还有一个问题，如果在第一句__strong typeof(weakSelf)strongSelf = weakSelf;的时候weakSelf已经被销毁了怎么办？</span></div><div><br style="font-weight: bold;"/></div><div><span style="font-weight: bold;">你没看我下面有个if(！strongSelf)么？不就是应对这种情况的。</span></div></span>
</div></body></html> 