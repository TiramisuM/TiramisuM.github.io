<html>
<head>
  <title>稀土掘金  (十四) : 移动端的加解密</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <meta name="application-data:corenote-hostUUID" content="C8940BC2-A53C-4B55-B59C-4779464BC778"/>
  <meta name="application-data:corenote-localUUID" content="9AC63A3E-491D-4B26-9190-B4221F941430"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1271"/>
<h1>稀土掘金  (十四) : 移动端的加解密</h1>

<div>
<span><div>首先罗列一些知识点：</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">1.加密算法通常分为对称性加密算法和非对称性加密算法：对于对称性加密算法，信息接收双方都需事先知道密匙和加解密算法且其密匙是相同的，之后便是对数据进行 加解密了。非对称算法与之不同，发送双方A,B事先均生成一堆密匙，然后A将自己的公有密匙发送给B，B将自己的公有密匙发送给A，如果A要给B发送消息，则先需要用B的公有密匙进行消息加密，然后发送给B端，此时B端再用自己的私有密匙进行消息解密，B向A发送消息时为同样的道理。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">2.关于公钥私钥和数字签名， 通过一个发送邮件的故事让大家有一个深刻的理解，非常棒的案例：</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">相信你会明白非对称加密在网络传输中的安全性的体现， 当然就是之前谈到的https。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">总而言之：公钥与私钥的作用是：用公钥加密的内容只能用私钥解密，用私钥加密的内容只能 用公钥解密。公钥加密私钥解密， 没问题,也可以说是&quot;公共密钥加密系统&quot;私钥加密公钥解密,一般不这么说，应叫&quot;私钥签名,公钥验证&quot;,也可以说是“公共密钥签名系统”</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">引用一段总结的话：</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">公钥加密私钥解密， 没问题,也可以说是&quot;公共密钥加密系统&quot;私钥加密公钥解密,一般不这么说，应叫&quot;私钥签名,公钥验证&quot;,也可以说是“公共密钥签名系统”再来说一下&quot;公共密钥签名系统&quot;目的:(如果晕就多看几遍，这个没搞清，后面的代码就更晕)A欲传（信息）给B，但又怕B不确信该信息是A发的。1．A选计算（信息）的HASH值，如用MD5方式计算,得到：[MD5（信息）]2．然后用自已的私钥加密HASH值，得到：[私钥（MD5（信息））]3．最后将信息与密文一起传给B：传给B：[（信息） + 私钥（MD5（信息））]B接到 ：[（信息） + 私钥（MD5（信息））]1．先用相同的HASH算法算出（信息）的HASH值，这里也使用MD5方式 得到： [MD5（信息）!]2. 再用A的公钥解密 [ 私钥（MD5（信息））] [公钥(私钥（MD5（信息））)] = [（MD5（信息）] 如能解开,证明该 [ 私钥（MD5（信息））]是A发送的3.再比效[MD5（信息）!]与[（MD5（信息）] 如果相同,表示（信息）在传递过程中没有被他人修改过</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">OK, 到现在为止， 你已经懂得了公钥， 私钥， 以及数字证书的概念了， 当然你也知道什么是对称加密和非对称加密，有可能你不是很清楚，为了让你更清楚，给你再讲个活生生的例子，这个例子还要从我的恋爱说起， 高中的时候喜欢上一个女生， 那时候青春年少，还喜欢用纸质给她写情书， 每天写一些“透明的”文字很繁琐，于是有一天，我忽然一个念想，把情书改成用汉语拼音写abcd……xyz, 原来字母是a就用z代替，b用y代替，c用x代替，……z用a代替， 这样，一个只有我们俩能看的懂的情书就这样诞生了。其实现在想想， 这不正是一种对称式加密么。哈哈。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">说完了故事，再来普及下一点简单的知识喽</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">3.几种对称性加密算法：AES,DES,3DES</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">DES是一种分组数据加密技术（先将数据分成固定长度的小数据块，之后进行加密），速度较快，适用于大量数据加密，而3DES是一种基于DES的加密算法，使用3个不同密匙对同一个分组数据块进行3次加密，如此以使得密文强度更高。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">相较于DES和3DES算法而言，AES算法有着更高的速度和资源使用效率，安全级别也较之更高了，被称为下一代加密标准。对于具体的算法我们不做深入的了解， 之前有一篇文章写得很好， 由于时间问题， 我就不给大家找了。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">4.几种非对称性加密算法：RSA,DSA,ECC</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">RSA和DSA的安全性及其它各方面性能都差不多，而ECC较之则有着很多的性能优越，包括处理速度，带宽要求，存储空间等等</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">5.几种线性散列算法（签名算法）：MD5,SHA1,HMAC</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这几种算法只生成一串不可逆的密文，经常用其效验数据传输过程中是否经过修改，因为相同的生成算法对于同一明文只会生成唯一的密文，若相同算法生成的密文不同，则证明传输数据进行过了修改。通常在数据传说过程前，使用MD5和SHA1算法均需要发送和接收数据双方在数据传送之前就知道密匙生成算法，而HMAC与之不同的是需要生成一个密匙，发送方用此密匙对数据进行摘要处理（生成密文），接收方再利用此密匙对接收到的数据进行摘要处理，再判断生成的密文是否相同。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">6.对于各种加密算法的选用</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">由于对称加密算法的密钥管理是一个复杂的过程，密钥的管理直接决定着他的安全性，因此当数据量很小时，我们可以考虑采用非对称加密算法。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">在实际的操作过程中我们通常采用的方式是：采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。如果在选定了加密算法后，那采用多少位的密钥呢？一般来说，密钥越长，运行的速度就越慢，应该根据的我们实际需要的安全级别来选择，一般来说，RSA建议采用1024位的数字，ECC建议采用160位，AES采用128为即可。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">需要注意的是：</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">哈希函数,比如MD5,SHA，这些都不是加密算法。要注意他们的区别和用途，很多网友都把md5说成是加密算法，这是严重不正确的啊。哈希函数：MD5，SHA 是没有密钥的，相当与指纹的概念，因此也是不可逆的； md5是128位的，SHA有不同的算法，有128，256等位。。。如SHA-256,SHA-384然后 就是 Base64,这更加不属于加密算法的范围了，它只是将byte[]数组进行了转换，为什么要转换呢？就是因为很多加密后的密文后者一些特殊的byte[]数组需要显示出来，或者需要进行传递（电子邮件），但是直接转换就会导致很多不可显示的字符，会丢失一些信息，因此就转换位Base64编码，这些都是可显示的字符。所以转换后，长度会增加。它是可逆的。 再就是 3DES,DES 这才是加密算法，因此也是可逆的，加解密需要密钥,也就是你说的key最后是 RSA ,这是公钥密码，也就是加密和解密密钥不同，也是可逆的。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">罗列了这么多知识点， 我想这篇文章你应该有收藏的必要了吧，为了更形象，更好玩， 我从网上找了一些在线工具：</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">1.1-Base64</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><a href="http://www1.tc711.com/tool/BASE64.htm" style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">http://www1.tc711.com/tool/BASE64.htm</a></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><img src="稀土掘金  (十四)  移动端的加解密_files/Image.png" type="image/png" data-filename="Image.png"/><br/></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><img src="稀土掘金  (十四)  移动端的加解密_files/Image [1].png" type="image/png" data-filename="Image.png"/><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">可以按出来这是可逆的编解码，注意不是加密幺！！！</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">1.2-MD5</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><a href="http://tool.chinaz.com/Tools/MD5.aspx?q=32324&amp;md5type=1" style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">http://tool.chinaz.com/Tools/MD5.aspx?q=32324&amp;md5type=1</a></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><img src="稀土掘金  (十四)  移动端的加解密_files/Image [2].png" type="image/png" data-filename="Image.png"/><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">其实这个也不能叫加密工具幺，今晚写到这里吧， 眼睛很累了，明天把这篇文章写完。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">1.3-SHA-1,SHA-2,SHA-256,SHA-512,SHA-3</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">好吧，哈希的工具找到了一个更好的工具连接，里面也有MD5.里面还有哈希的一些说明。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><a href="http://www.atool.org/hash.php" style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">http://www.atool.org/hash.php</a><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"> 这个链接值的收藏一下， 主要是用到哈希的时候可以经常用。</span></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><img src="稀土掘金  (十四)  移动端的加解密_files/Image [3].png" type="image/png" data-filename="Image.png"/><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">2.1 AES DES</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">以上我们主要说了哈希算法和数字证书的一些知识， 现在我们看一下对称加密的一些在线工具</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">DES </span><a href="http://e-file.arkoo.com/tools/des3.htm" style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">http://e-file.arkoo.com/tools/des3.htm</a></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这个链接可谓非常干净好用，形象直观可逆过程，哈哈。</span></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><img src="稀土掘金  (十四)  移动端的加解密_files/Image [4].png" type="image/png" data-filename="Image.png"/><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">AES </span><a href="http://www.seacha.com/tools/aes.html" style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">http://www.seacha.com/tools/aes.html</a></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><img src="稀土掘金  (十四)  移动端的加解密_files/Image [5].png" type="image/png" data-filename="Image.png"/><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">忽然发现这个在线工具也还凑合</span><a href="http://encode.chahuo.com/" style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">http://encode.chahuo.com/</a></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><img src="稀土掘金  (十四)  移动端的加解密_files/Image [6].png" type="image/png" data-filename="Image.png"/><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">如此般， 对称加密基本上都弄完了，现在我们只简单的了解下非对称加解密的RSA,上面的过程我们已经说的非常详细了吧。重点已经用黑色字体标注出来了。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">加密数据</span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div><br/></div></td><td><div>    RSAEncryptor *rsa = [[RSAEncryptor alloc] init];  </div><div>    NSLog(@&quot;encryptor using rsa&quot;);  </div><div>    NSString *publicKeyPath = [[NSBundle mainBundle] pathForResource:@&quot;public_key&quot; ofType:@&quot;der&quot;];  </div><div>    NSLog(@&quot;public key: %@&quot;, publicKeyPath);  </div><div>    [rsa loadPublicKeyFromFile:publicKeyPath];  </div><div>    NSString *securityText = @&quot;hello ~&quot;;  </div><div>    NSString *encryptedString = [rsa rsaEncryptString:securityText];  </div><div>    NSLog(@&quot;encrypted data: %@&quot;, encryptedString);</div></td></tr></tbody></table><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">解密数据在</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">iOS下解码需要先加载private key, 之后在对数据解码. 解码的时候先进行Base64 decode, 之后在用private key decrypt加密数据.</span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div><br/></div></td><td><div>    NSLog(@&quot;decryptor using rsa&quot;);  </div><div>    [rsa loadPrivateKeyFromFile:[[NSBundle mainBundle] pathForResource:@&quot;private_key&quot; ofType:@&quot;p12&quot;] password:@&quot;123456&quot;];  </div><div>    NSString *decryptedString = [rsa rsaDecryptString:encryptedString];  </div><div>    NSLog(@&quot;decrypted data: %@&quot;, decryptedString);</div></td></tr></tbody></table><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">在支付宝支付过程中就使用了RSA加密。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">在在这里有必要提醒下小编自己， 有时间需要研究下苹果证书的工作机制。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">弄到这里， 我主要是找一些代码给大家用，看看我自己先建一个工程吧。</span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div><br/></div></td><td><div>#import @interface Helper : NSObject</div><div>MD5</div><div>+ (NSString *) md5:(NSString *)str;</div><div>Base64</div><div>+ (NSString *)base64StringFromText:(NSString *)text;</div><div>+ (NSString *)textFromBase64String:(NSString *)base64;</div><div>+ (NSString *)base64EncodedStringFrom:(NSData *)data;</div><div>DES加密</div><div>+(NSString *)encryptSting:(NSString *)sText key:(NSString *)key andDesiv:(NSString *)ivDes;</div><div>DES解密</div><div>+(NSString *)decryptWithDESString:(NSString *)sText key:(NSString *)key andiV:(NSString *)iv;</div><div>AES加密</div><div>+ (NSData *)AES128EncryptWithKey:(NSString *)key iv:(NSString *)iv withNSData:(NSData *)data;</div><div>AES解密</div><div>+ (NSData *)AES128DecryptWithKey:(NSString *)key iv:(NSString *)iv withNSData:(NSData *)data;</div><div>@end</div></td></tr></tbody></table><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div>3</div></td><td><div>#import &quot;Helper.h&quot;</div><div>#import #importstatic const char encodingTable[] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;</div><div>#define LocalStr_None  @&quot;&quot;</div><div>@implementation Helper</div><div>//Md5</div><div>+ (NSString *) md5:(NSString *)str {</div><div>    if (str == nil) {</div><div>        return nil;</div><div>    }</div><div>    const char *cStr = [str UTF8String];</div><div>    unsigned char result[16];</div><div>    CC_MD5( cStr, strlen(cStr), result );</div><div>    return [NSString stringWithFormat:</div><div>            @&quot;XXXXXXXXXXXXXXXX&quot;,</div><div>            result[0], result[1], result[2], result[3],</div><div>            result[4], result[5], result[6], result[7],</div><div>            result[8], result[9], result[10], result[11],</div><div>            result[12], result[13], result[14], result[15]</div><div>            ];</div><div>}</div><div><br/></div><div>转化为Base64</div><div>+ (NSString *)base64StringFromText:(NSString *)text</div><div>{</div><div>    if (text &amp;&amp; ![text isEqualToString:LocalStr_None]) {</div><div>        取项目的bundleIdentifier作为KEY  改动了此处</div><div>        NSString *key = [[NSBundle mainBundle] bundleIdentifier];</div><div>        NSData *data = [text dataUsingEncoding:NSUTF8StringEncoding];</div><div>        IOS 自带DES加密 Begin  改动了此处</div><div>        data = [self DESEncrypt:data WithKey:key];</div><div>        IOS 自带DES加密 End</div><div>        return [self base64EncodedStringFrom:data];</div><div>    }</div><div>    else {</div><div>        return LocalStr_None;</div><div>    }</div><div>}</div><div><br/></div><div>由base64转化</div><div>+ (NSString *)textFromBase64String:(NSString *)base64</div><div>{</div><div>    if (base64 &amp;&amp; ![base64 isEqualToString:LocalStr_None]) {</div><div>        取项目的bundleIdentifier作为KEY   改动了此处</div><div>        NSString *key = [[NSBundle mainBundle] bundleIdentifier];</div><div>        NSData *data = [self dataWithBase64EncodedString:base64];</div><div>        IOS 自带DES解密 Begin    改动了此处</div><div>        data = [self DESDecrypt:data WithKey:key];</div><div>        IOS 自带DES加密 End</div><div>        return [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</div><div>    }</div><div>    else {</div><div>        return LocalStr_None;</div><div>    }</div><div>}</div><div><br/></div><div>DES加密</div><div>+(NSString *)encryptSting:(NSString *)sText key:(NSString *)key andDesiv:(NSString *)ivDes</div><div>{</div><div>    if ((sText == nil || sText.length == 0)</div><div>        || (sText == nil || sText.length == 0)</div><div>        || (ivDes == nil || ivDes.length == 0)) {</div><div>        return @&quot;&quot;;</div><div>    }</div><div>    </div><div>gb2312 编码</div><div>    NSStringEncoding encoding =CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000);</div><div>    NSData* encryptData = [sText dataUsingEncoding:encoding];</div><div>    size_t  dataInLength = [encryptData length];</div><div>    const void *   dataIn = (const void *)[encryptData bytes];</div><div>    CCCryptorStatus ccStatus = nil;</div><div>    uint8_t *dataOut = NULL; //可以理解位type/typedef 的缩写（有效的维护了代码，比如：一个人用int，一个人用long。最好用typedef来定义）</div><div>    size_t dataOutMoved = 0;</div><div>    size_t    dataOutAvailable = (dataInLength + kCCBlockSizeDES) &amp; ~(kCCBlockSizeDES - 1);  dataOut = malloc( dataOutAvailable * sizeof(uint8_t));</div><div>    memset((void *)dataOut, 0x0, dataOutAvailable);//将已开辟内存空间buffer的首 1 个字节的值设为值 0</div><div>    const void *iv = (const void *) [ivDes cStringUsingEncoding:NSASCIIStringEncoding];</div><div>    </div><div>    CCCrypt函数 加密/解密</div><div>    ccStatus = CCCrypt(kCCEncrypt,  加密/解密</div><div>                       kCCAlgorithmDES,  加密根据哪个标准（des，3des，aes。。。。）</div><div>                       kCCOptionPKCS7Padding,  选项分组密码算法(des:对每块分组加一次密  3DES：对每块分组加三个不同的密)</div><div>                       [key UTF8String],  密钥    加密和解密的密钥必须一致</div><div>                       kCCKeySizeDES,   DES 密钥的大小（kCCKeySizeDES=8）</div><div>                       iv,   可选的初始矢量</div><div>                       dataIn,  数据的存储单元</div><div>                       dataInLength, 数据的大小</div><div>                       (void *)dataOut, 用于返回数据</div><div>                       dataOutAvailable,</div><div>                       &amp;dataOutMoved);</div><div>    </div><div>    编码 base64</div><div>    NSData *data = [NSData dataWithBytes:(const void *)dataOut length:(NSUInteger)dataOutMoved];</div><div>    Byte *bytes = (Byte *)[data bytes];</div><div>    下面是Byte 转换为16进制。</div><div>    NSString *hexStr=@&quot;&quot;;</div><div>    for(int i=0;i&lt;[data length];i++){</div><div>        NSString *newHexStr = [NSString stringWithFormat:@&quot;%x&quot;,bytes[i]&amp;0xff];16进制数</div><div>        if([newHexStr length]==1)</div><div>            hexStr = [NSString stringWithFormat:@&quot;%@0%@&quot;,hexStr,newHexStr];</div><div>        else</div><div>            hexStr = [NSString stringWithFormat:@&quot;%@%@&quot;,hexStr,newHexStr];</div><div>    }</div><div>    free(dataOut);</div><div>    return hexStr;</div><div>}</div><div><br/></div><div>DES解密</div><div>+(NSString *)decryptWithDESString:(NSString *)sText key:(NSString *)key andiV:(NSString *)iv</div><div>{</div><div>    if ((sText == nil || sText.length == 0)</div><div>        || (sText == nil || sText.length == 0)</div><div>        || (iv == nil || iv.length == 0)) {</div><div>        return @&quot;&quot;;</div><div>    }</div><div>    const void *dataIn;</div><div>    size_t dataInLength;</div><div>    char *myBuffer = (char *)malloc((int)[sText length] / 2 + 1);</div><div>    bzero(myBuffer, [sText length] / 2 + 1);</div><div>    for (int i = 0; i &lt; [sText length] - 1; i += 2) {</div><div>        unsigned int anInt;</div><div>        NSString * hexCharStr = [sText substringWithRange:NSMakeRange(i, 2)];</div><div>        NSScanner * scanner = [[NSScanner alloc] initWithString:hexCharStr];</div><div>        [scanner scanHexInt:&amp;anInt];</div><div>        myBuffer[i / 2] = (char)anInt;</div><div>    }</div><div>    NSData *decryptData =[NSData dataWithBytes:myBuffer length:[sText length] / 2 ];</div><div>    转成utf-8并decode</div><div>    dataInLength = [decryptData length];</div><div>    dataIn = [decryptData bytes];</div><div>    free(myBuffer);</div><div>    CCCryptorStatus ccStatus = nil;</div><div>    uint8_t *dataOut = NULL; 可以理解位type/typedef 的缩写（有效的维护了代码，比如：一个人用int，一个人用long。最好用typedef来定义）</div><div>    size_t dataOutAvailable = 0; size_t  是操作符sizeof返回的结果类型</div><div>    size_t dataOutMoved = 0;</div><div>    dataOutAvailable = (dataInLength + kCCBlockSizeDES) &amp; ~(kCCBlockSizeDES - 1);</div><div>    dataOut = malloc( dataOutAvailable * sizeof(uint8_t));</div><div>    memset((void *)dataOut, 0x0, dataOutAvailable);将已开辟内存空间buffer的首 1 个字节的值设为值 0</div><div>    const void *ivDes = (const void *) [iv cStringUsingEncoding:NSASCIIStringEncoding];</div><div>    CCCrypt函数 加密/解密</div><div>    ccStatus = CCCrypt(kCCDecrypt,  加密/解密</div><div>                       kCCAlgorithmDES,  加密根据哪个标准（des，3des，aes。。。。）</div><div>                       kCCOptionPKCS7Padding,  选项分组密码算法(des:对每块分组加一次密  3DES：对每块分组加三个不同的密)</div><div>                       [key UTF8String],  密钥    加密和解密的密钥必须一致</div><div>                       kCCKeySizeDES,   DES 密钥的大小（kCCKeySizeDES=8）</div><div>                       ivDes,   可选的初始矢量</div><div>                       dataIn,  数据的存储单元</div><div>                       dataInLength, 数据的大小</div><div>                       (void *)dataOut, 用于返回数据</div><div>                       dataOutAvailable,</div><div>                       &amp;dataOutMoved);</div><div>    NSStringEncoding encoding =CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000);</div><div>    NSString *result  = [[NSString alloc] initWithData:[NSData dataWithBytes:(const void *)dataOut length:(NSUInteger)dataOutMoved] encoding:encoding];</div><div>    free(dataOut);</div><div>    return result;</div><div>}</div><div>AES加密</div><div>+ (NSData *)AES128EncryptWithKey:(NSString *)key iv:(NSString *)iv withNSData:(NSData *)data</div><div>{</div><div>    char keyPtr[kCCKeySizeAES128+1];</div><div>    bzero(keyPtr, sizeof(keyPtr));</div><div>    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];</div><div>    char ivPtr[kCCKeySizeAES128+1];</div><div>    bzero(ivPtr, sizeof(ivPtr));</div><div>    [iv getCString:ivPtr maxLength:sizeof(ivPtr) encoding:NSUTF8StringEncoding];</div><div>    NSUInteger dataLength = [data length];</div><div>    int diff = kCCKeySizeAES128 - (dataLength % kCCKeySizeAES128);</div><div>    int newSize = 0;</div><div>    if(diff &gt; 0)</div><div>    {</div><div>        newSize = (int)(dataLength + diff);</div><div>    }</div><div>    char dataPtr[newSize];</div><div>    memcpy(dataPtr, [data bytes], [data length]);</div><div>    for(int i = 0; i &lt; diff; i++)</div><div>    {</div><div>        dataPtr[i + dataLength] = 0x00;</div><div>    }</div><div>    size_t bufferSize = newSize + kCCBlockSizeAES128;</div><div>    void *buffer = malloc(bufferSize);</div><div>    size_t numBytesEncrypted = 0;</div><div>    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,</div><div>                                          kCCAlgorithmAES128,</div><div>                                          0x00, //No padding</div><div>                                          keyPtr,</div><div>                                          kCCKeySizeAES128,</div><div>                                          ivPtr,</div><div>                                          dataPtr,</div><div>                                          sizeof(dataPtr),</div><div>                                          buffer,</div><div>                                          bufferSize,</div><div>                                          &amp;numBytesEncrypted);</div><div>    if(cryptStatus == kCCSuccess)</div><div>    {</div><div>        NSData *data =[NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];</div><div>        NSString *str = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];</div><div>        return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];</div><div>    }</div><div>    return nil;</div><div>}</div><div>AES解密</div><div>+ (NSData *)AES128DecryptWithKey:(NSString *)key iv:(NSString *)iv withNSData:(NSData *)data</div><div>{</div><div>    char keyPtr[kCCKeySizeAES128+1];</div><div>    bzero(keyPtr, sizeof(keyPtr));</div><div>    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];</div><div>    char ivPtr[kCCKeySizeAES128+1];</div><div>    bzero(ivPtr, sizeof(ivPtr));</div><div>    [iv getCString:ivPtr maxLength:sizeof(ivPtr) encoding:NSUTF8StringEncoding];</div><div>    NSUInteger dataLength = [data length];</div><div>    size_t bufferSize = dataLength + kCCBlockSizeAES128;</div><div>    void *buffer = malloc(bufferSize);</div><div>    size_t numBytesEncrypted = 0;</div><div>    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,</div><div>                                          kCCAlgorithmAES128,</div><div>                                          0x00, //No padding</div><div>                                          keyPtr,</div><div>                                          kCCKeySizeAES128,</div><div>                                          ivPtr,</div><div>                                          [data bytes],</div><div>                                          dataLength,</div><div>                                          buffer,</div><div>                                          bufferSize,</div><div>                                          &amp;numBytesEncrypted);</div><div>    if(cryptStatus == kCCSuccess)</div><div>    {</div><div>        NSData *data =[NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];</div><div>        NSString *str = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];</div><div>        return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];</div><div>    }</div><div>    return nil;</div><div>}</div><div>/******************************************************************************</div><div> 函数名称 : + (NSData *)dataWithBase64EncodedString:(NSString *)string</div><div> 函数描述 : base64格式字符串转换为文本数据</div><div> 输入参数 : (NSString *)string</div><div> 输出参数 : N/A</div><div> 返回参数 : (NSData *)</div><div> 备注信息 :</div><div> ******************************************************************************/</div><div>+ (NSData *)dataWithBase64EncodedString:(NSString *)string</div><div>{</div><div>    if (string == nil)</div><div>        [NSException raise:NSInvalidArgumentException format:nil];</div><div>    if ([string length] == 0)</div><div>        return [NSData data];</div><div>    static char *decodingTable = NULL;</div><div>    if (decodingTable == NULL)</div><div>    {</div><div>        decodingTable = malloc(256);</div><div>        if (decodingTable == NULL)</div><div>            return nil;</div><div>        memset(decodingTable, CHAR_MAX, 256);</div><div>        NSUInteger i;</div><div>        for (i = 0; i &lt; 64; i++)</div><div>            decodingTable[(short)encodingTable[i]] = i;</div><div>    }</div><div>    const char *characters = [string cStringUsingEncoding:NSASCIIStringEncoding];</div><div>    if (characters == NULL)       Not an ASCII string!</div><div>        return nil;</div><div>    char *bytes = malloc((([string length] + 3) / 4) * 3);</div><div>    if (bytes == NULL)</div><div>        return nil;</div><div>    NSUInteger length = 0;</div><div>    NSUInteger i = 0;</div><div>    while (YES)</div><div>    {</div><div>        char buffer[4];</div><div>        short bufferLength;</div><div>        for (bufferLength = 0; bufferLength &lt; 4; i++)</div><div>        {</div><div>            if (characters[i] == '\0')</div><div>                break;</div><div>            if (isspace(characters[i]) || characters[i] == '=')</div><div>                continue;</div><div>            buffer[bufferLength] = decodingTable[(short)characters[i]];</div><div>            if (buffer[bufferLength++] == CHAR_MAX)        Illegal character!</div><div>            {</div><div>                free(bytes);</div><div>                return nil;</div><div>            }</div><div>        }</div><div>        if (bufferLength == 0)</div><div>            break;</div><div>        if (bufferLength == 1)        At least two characters are needed to produce one byte!</div><div>        {</div><div>            free(bytes);</div><div>            return nil;</div><div>        }</div><div>        Decode the characters in the buffer to bytes.</div><div>        bytes[length++] = (buffer[0] &lt;&lt; 2) | (buffer[1] &gt;&gt; 4);</div><div>        if (bufferLength &gt; 2)</div><div>            bytes[length++] = (buffer[1] &lt;&lt; 4) | (buffer[2] &gt;&gt; 2);</div><div>        if (bufferLength &gt; 3)</div><div>            bytes[length++] = (buffer[2] &lt;&lt; 6) | buffer[3];</div><div>    }</div><div>    bytes = realloc(bytes, length);</div><div>    return [NSData dataWithBytesNoCopy:bytes length:length];</div><div>}</div><div>/******************************************************************************</div><div> 函数名称 : + (NSString *)base64EncodedStringFrom:(NSData *)data</div><div> 函数描述 : 文本数据转换为base64格式字符串</div><div> 输入参数 : (NSData *)data</div><div> 输出参数 : N/A</div><div> 返回参数 : (NSString *)</div><div> 备注信息 :</div><div> ******************************************************************************/</div><div>+ (NSString *)base64EncodedStringFrom:(NSData *)data</div><div>{</div><div>    if ([data length] == 0)</div><div>        return @&quot;&quot;;</div><div>    char *characters = malloc((([data length] + 2) / 3) * 4);</div><div>    if (characters == NULL)</div><div>        return nil;</div><div>    NSUInteger length = 0;</div><div>    NSUInteger i = 0;</div><div>    while (i &lt; [data length])</div><div>    {</div><div>        char buffer[3] = {0,0,0};</div><div>        short bufferLength = 0;</div><div>        while (bufferLength &lt; 3 &amp;&amp; i &lt; [data length])</div><div>            buffer[bufferLength++] = ((char *)[data bytes])[i++];</div><div>        Encode the bytes in the buffer to four characters, including padding &quot;=&quot; characters if necessary.</div><div>        characters[length++] = encodingTable[(buffer[0] &amp; 0xFC) &gt;&gt; 2];</div><div>        characters[length++] = encodingTable[((buffer[0] &amp; 0x03) &lt;&lt; 4) | ((buffer[1] &amp; 0xF0) &gt;&gt; 4)];</div><div>        if (bufferLength &gt; 1)</div><div>            characters[length++] = encodingTable[((buffer[1] &amp; 0x0F) &lt;&lt; 2) | ((buffer[2] &amp; 0xC0) &gt;&gt; 6)];</div><div>        else characters[length++] = '=';</div><div>        if (bufferLength &gt; 2)</div><div>            characters[length++] = encodingTable[buffer[2] &amp; 0x3F];</div><div>        else characters[length++] = '=';</div><div>    }</div><div>    return [[NSString alloc] initWithBytesNoCopy:characters length:length encoding:NSASCIIStringEncoding freeWhenDone:YES];</div><div>}</div><div>@end</div></td></tr><tr><td><div><br/></div></td><td><div><br/></div></td></tr></tbody></table><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">以上是接口和实现文件， 现在我们来看看调用</span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div><br/></div></td><td><div>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {</div><div>    MD5</div><div>    NSString *md5Str = [Helper md5:@&quot;我爱你&quot;];</div><div>    NSLog(@&quot;md5Str is %@&quot;,md5Str); Log is 4F2016C6B934D55BD7120E5D0E62CCE3</div><div>    Base64</div><div>    NSString *Base64Str = [Helper base64StringFromText:@&quot;我爱你&quot;];</div><div>    NSLog(@&quot;Base64Str is %@&quot;,Base64Str); Log is 5oiR54ix5L2g</div><div>    NSString *oriBase64Str = [Helper textFromBase64String:Base64Str];</div><div>    NSLog(@&quot;oriBase64Str is %@&quot;,oriBase64Str); Log is  我爱你</div><div>    DES</div><div>    NSString *desEnStr = [Helper encryptSting:@&quot;我爱你&quot; key:@&quot;521&quot; andDesiv:@&quot;521&quot;];</div><div>    NSLog(@&quot;desEnStr is %@&quot;,desEnStr); Log is  389280aa791ee933</div><div>    NSString *desDeStr =[Helper decryptWithDESString:desEnStr key:@&quot;521&quot; andiV:@&quot;521&quot;];</div><div>    NSLog(@&quot;desDeStr is %@&quot;,desDeStr); Log is  我爱你</div><div>    AES</div><div>    NSData *aesEnData = [Helper AES128EncryptWithKey:@&quot;521&quot; iv:@&quot;521&quot; withNSData:[@&quot;我爱你&quot; dataUsingEncoding:NSUTF8StringEncoding]];</div><div>    NSString *aesEnStr = [Helper base64EncodedStringFrom:aesEnData];</div><div>    NSLog(@&quot;aesEnStr is %@&quot;,aesEnStr); Log is HZKhnRLlQ8XjMjpelOAwsQ==</div><div>    NSData *aesDeData = [Helper AES128DecryptWithKey:@&quot;521&quot; iv:@&quot;521&quot; withNSData:aesEnData];</div><div>    NSString *aesDEStr = [Helper base64EncodedStringFrom:aesDeData];</div><div>    NSString *result = [Helper textFromBase64String:aesDEStr];</div><div>    NSLog(@&quot;aesDEStr is %@ and result is %@&quot;,aesDEStr,result); Log is aesDEStr is 5oiR54ix5L2gAAAAAAAAAA== and result is 我爱你</div><div>    return YES;</div><div>}</div></td></tr></tbody></table><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">写到这里， 产生了一个问题， 就是上面的AES加密最终生成的Base64字符串和工具不一样 ，不知道是什么问题， 还请高手帮忙解答一下。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">了解下cookie在客户端里的应用</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">首先带大家了解下什么是cookie吧</span></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><img src="稀土掘金  (十四)  移动端的加解密_files/Image [7].png" type="image/png" data-filename="Image.png"/><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这是维基百科里一段对cookie的描述，可见cookie是服务器生成的发给客户端，具体应用例如：我们打开淘宝的某一个页面，登陆了账号和密码， 当我们再跳转到其他淘宝界面的时候，我们不必每一次都重新登陆界面， 这就是cookie的作用， 其实cookie还能记录用户选的订单， 至于深一层的了解， 我还不是很清楚， 因为没有学过前端的开发，感兴趣的读者可以自行了解。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">其实cookie也可以在客户端使用的。NSHTTPCookieStorage在iOS上是一个单例。那么首先我们通过代码的方式看看怎么添加cookie和删除cookie，</span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div><br/></div></td><td><div>增加cookies</div><div>+ (void)addCookiesToRequest:(NSMutableDictionary *)cookieDic</div><div>{</div><div>    NSEnumerator * enumeratorKey = [cookieDic keyEnumerator];</div><div>    for (NSObject * key in enumeratorKey) {</div><div>        NSHTTPCookie *userInfoCookie = [NSHTTPCookie cookieWithProperties:</div><div>                                        [NSDictionary dictionaryWithObjectsAndKeys:</div><div>                                         @&quot;.<a href="http://baidu.com">baidu.com</a>&quot;, NSHTTPCookieDomain,</div><div>                                         @&quot;/&quot;, NSHTTPCookiePath,</div><div>                                         [NSString stringWithFormat:@&quot;%@&quot;,key],  NSHTTPCookieName,</div><div>                                         [NSDate dateWithTimeIntervalSinceNow:30*24*3600], NSHTTPCookieExpires,</div><div>                                         [NSString stringWithFormat:@&quot;%@&quot;,[cookieDic objectForKey:key]], NSHTTPCookieValue,</div><div>                                         nil]];</div><div>        [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:userInfoCookie];</div><div>        NSHTTPCookie *txdaiCookie = [NSHTTPCookie cookieWithProperties:</div><div>                                        [NSDictionary dictionaryWithObjectsAndKeys:</div><div>                                         @&quot;.<a href="http://jingdong.com">jingdong.com</a>&quot;, NSHTTPCookieDomain,</div><div>                                         @&quot;/&quot;, NSHTTPCookiePath,</div><div>                                         [NSString stringWithFormat:@&quot;%@&quot;,key],  NSHTTPCookieName,</div><div>                                         [NSDate dateWithTimeIntervalSinceNow:30*24*3600], NSHTTPCookieExpires,</div><div>                                         [NSString stringWithFormat:@&quot;%@&quot;,[cookieDic objectForKey:key]], NSHTTPCookieValue,</div><div>                                         nil]];</div><div>        [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:txdaiCookie];</div><div>    }</div><div>}</div></td></tr></tbody></table><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">同样删除cookie也非常简单</span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div><br/></div></td><td><div>删除基本cookies</div><div>+(void)deleteBaseCookie{</div><div>    NSHTTPCookie *passportCookie = [NSHTTPCookie cookieWithProperties:</div><div>                                    [NSDictionary dictionaryWithObjectsAndKeys:</div><div>                                     @&quot;.<a href="http://baidu.com">baidu.com</a>&quot;, NSHTTPCookieDomain,</div><div>                                     @&quot;/&quot;, NSHTTPCookiePath,</div><div>                                     @&quot;sfut&quot;,  NSHTTPCookieName,</div><div>                                     @&quot;&quot;, NSHTTPCookieValue,</div><div>                                     nil]];</div><div>    [[NSHTTPCookieStorage sharedHTTPCookieStorage] deleteCookie:passportCookie];</div><div>    NSHTTPCookie *txdaiCookie = [NSHTTPCookie cookieWithProperties:</div><div>                                 [NSDictionary dictionaryWithObjectsAndKeys:</div><div>                                  @&quot;.<a href="http://jingdong.com">jingdong.com</a>&quot;, NSHTTPCookieDomain,</div><div>                                  @&quot;/&quot;, NSHTTPCookiePath,</div><div>                                  @&quot;sfut&quot;,  NSHTTPCookieName,</div><div>                                  @&quot;&quot;, NSHTTPCookieValue,</div><div>                                  nil]];</div><div>    [[NSHTTPCookieStorage sharedHTTPCookieStorage] deleteCookie:txdaiCookie];</div><div>}</div></td></tr></tbody></table><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">那么最后一个问题就是我们在客户端什么情况下才添加或者删除cookie呢。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">当我们的应用在加载一个wap页面的时候，可能wap需要知道客户端的一些信息， 比如你是登陆状态还是什么状态，因为这时候我们就可以设置cookie,wap可以拿到请求的cookie</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">当然需要注意的是在wap将要销毁的时候，要把cookie信息给移除掉。</span></div><div><br/></div><div style="font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%; font-weight: bold;">笔记整理：Edison</span></div><div style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em; border-width: 100%; font-weight: bold; color: rgb(79, 129, 189); unicode-bidi: embed;">联系方式：QQ：277593 （笔记意见建议可加此Q，专人更新此笔记）；</span></div><div style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em; border-width: 100%; color: rgb(79, 129, 189); unicode-bidi: embed;"> </span></div><div style="font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%; font-weight: bold;">注：小道途径获取到的笔记，无法自动更新，请谅解！(笔记平均每月更新一次，祝各位都能拿到心仪的offer)</span><span style="direction: ltr; font-family: Menlo; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%;"> </span></div><div><br/></div></span>
</div></body></html> 