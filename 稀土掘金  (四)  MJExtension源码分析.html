<html>
<head>
  <title>稀土掘金  (四) : MJExtension源码分析</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <meta name="application-data:corenote-hostUUID" content="C8940BC2-A53C-4B55-B59C-4779464BC778"/>
  <meta name="application-data:corenote-localUUID" content="2B283A02-6214-401D-988D-17E104D03AA3"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1573"/>
<h1>稀土掘金  (四) : MJExtension源码分析</h1>

<div>
<span><div>A fast, convenient and nonintrusive conversion between JSON and model.</div><div>转换速度快、使用简单方便的字典转模型框架</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">总体来说：上手快，使用简单。</span></div><div><img src="稀土掘金  (四)  MJExtension源码分析_files/Image.png" type="image/png" data-filename="Image.png"/><br/></div><h2>关键类</h2><pre><code><font color="#0433ff"><span>#import &quot;NSObject+MJCoding.h&quot;</span><br/><span>#import &quot;NSObject+MJProperty.h&quot;</span><br/><span>#import &quot;NSObject+MJClass.h&quot;</span><br/><span>#import &quot;NSObject+MJKeyValue.h&quot;</span><br/><span>#import &quot;NSString+MJExtension.h&quot;</span><br/><span>#import &quot;MJExtensionConst.h&quot;</span></font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">除此之外还有一些辅助类，比如：MJFoundation.h、MJProperty.h、MJPropertyKey.h、MJPropertyType.h。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">根据类的名字，大致就能猜到是用来做什么用的。我们先从最简单的开始分析。</span></div><h2>MJExtensionConst</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这里定义了整个库的常量和宏定义。类似于一个项目中的预编译文件。包含了方法弃用宏，自定义Log日志、自定义断言、快速打印所有属性、自定义类型编码字符串常量</span></div><ul><li>方法弃用：一般在做项目中比较少用到，做SDK用到的机会比较大。#define MJExtensionDeprecated(instead) NS_DEPRECATED(2_0, 2_0, 2_0, 2_0, instead)可能好多同学对这里的2_0不是很懂。这里简单扩展一下：<br/>一、NS_AVAILABEL_IOS<br/>例如：</li><li>(void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (^)(void))completion NS_AVAILABLE_IOS(5_0);<br/>该NS_AVAILABLE_IOS(5_0)告诉我们这个方法可以在iOS5.0及以后的版本中使用。如果我们在比指定版本更老的版本中调用这个方法，就会引起崩溃。<br/>二、NS_AVAILABLE<br/><span style="color: rgb(4, 51, 255);">- (void)setObject:(id)obj atIndexedSubscript:(NSUInteger)idx NS_AVAILABLE(10_8, 6_0);</span><br/>这里的NS_AVAILABLE宏告诉我们这方法分别随Mac OS 10.8和iOS 6.0被引入。<br/>三、NS_DEPRECATED_IOS<br/>例如：</li><ul><li>(void)presentModalViewController:(UIViewController *)modalViewController animated:(BOOL)animated NS_DEPRECATED_IOS(2_0, 6_0);<br/>NS_DEPRECATED_IOS(2_0, 6_0)<br/>这里的宏有两个版本号，前面一个表明了这个方法被引入时的iOS版本，后面一个表名它被废弃时的iOS版本。本废弃并不是指这个方法就不存在了，知识意味着我们应当开始考虑将相关代码迁移到新的API上去了。<br/>四、NS_DEPRECATED<br/>例如：</li></ul><li>(void)removeObjectsFromIndices:(NSUInteger *)indices numIndices:(NSUInteger)cnt NS_DEPRECATED(10_0, 10_6, 2_0, 4_0);<br/>这里表示这个方法虽Max OS 10.0和iOS 2.0被引入，在Mac OS 10.6和iOS 4.0后背废弃。<br/>`` 根据上面的解释，我们可以知道这里的#define MJExtensionDeprecated(instead) NS_DEPRECATED(2_0, 2_0, 2_0, 2_0, instead)`代码在Max OS 2.0和iOS 2.0被引入，在Mac OS 2.0和iOS 2.0后背废弃。是不是有什么不对？？😒😒</li><li>宏定义函数（日志输出，构建错误等）：看一个断言的例子<br/><span style="color: rgb(4, 51, 255);">#define MJExtensionAssertError(condition, returnValue, clazz, msg) </span><br/><span style="color: rgb(4, 51, 255);">[clazz setMj_error:nil]; </span><br/><span style="color: rgb(4, 51, 255);">if ((condition) == NO) { </span><br/><span style="color: rgb(4, 51, 255);">  MJExtensionBuildError(clazz, msg); </span><br/><span style="color: rgb(4, 51, 255);">  return returnValue;</span><br/><span style="color: rgb(4, 51, 255);">}</span><br/>有一个细节(condition)，这里为什么要用（condition）多加一对括号，因为conditionh是一个表达式，为了保证执行顺序。<br/>这种特性是从c语言移植过来的，在宏定义每行最后加上斜杠``，表示宏定义函数，如果有参数可以按照上面的例子进行传递。</li><li>最后来看一看类型编码：大致根据名称就知道符号代表什么类型的参数<br/><span style="color: rgb(4, 51, 255);">NSString *const MJPropertyTypeInt = @&quot;i&quot;;</span><br/><span style="color: rgb(4, 51, 255);">NSString *const MJPropertyTypeShort = @&quot;s&quot;;</span><br/><span style="color: rgb(4, 51, 255);">NSString *const MJPropertyTypeFloat = @&quot;f&quot;;</span><br/><span style="color: rgb(4, 51, 255);">NSString *const MJPropertyTypeDouble = @&quot;d&quot;;</span><br/><span style="color: rgb(4, 51, 255);">NSString *const MJPropertyTypeLong = @&quot;l&quot;;</span><br/><span style="color: rgb(4, 51, 255);">NSString *const MJPropertyTypeLongLong = @&quot;q&quot;;</span><br/><span style="color: rgb(4, 51, 255);">NSString *const MJPropertyTypeChar = @&quot;c&quot;;</span><br/><span style="color: rgb(4, 51, 255);">NSString *const MJPropertyTypeBOOL1 = @&quot;c&quot;;</span><br/><span style="color: rgb(4, 51, 255);">NSString *const MJPropertyTypeBOOL2 = @&quot;b&quot;;</span><br/><span style="color: rgb(4, 51, 255);">NSString *const MJPropertyTypePointer = @&quot;*&quot;;</span><br/><span style="color: rgb(4, 51, 255);">NSString *const MJPropertyTypeIvar = @&quot;^{objc_ivar=}&quot;;</span><br/><span style="color: rgb(4, 51, 255);">NSString *const MJPropertyTypeMethod = @&quot;^{objc_method=}&quot;;</span><br/><span style="color: rgb(4, 51, 255);">NSString *const MJPropertyTypeBlock = @&quot;@?&quot;;</span><br/><span style="color: rgb(4, 51, 255);">NSString *const MJPropertyTypeClass = @&quot;#&quot;;</span><br/><span style="color: rgb(4, 51, 255);">NSString *const MJPropertyTypeSEL = @&quot;:&quot;;</span><br/><span style="color: rgb(4, 51, 255);">NSString *const MJPropertyTypeId = @&quot;@&quot;;</span></li></ul><h2>MJFoundation.h</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这个类做的事情就是判断类是不是属于Foundation框架里面的。可能很好奇如何判断这个类是不是Foundation框架呢。这里用的是穷举法，由于框架里面的类太多。这里就把最后常用的几个类进行判断。如下：</span></div><pre><code> <font color="#0433ff">foundationClasses_ = [NSSet setWithObjects:<br/>                              [NSURL <span>class],<br/></span>                              [NSDate <span>class],<br/></span>                              [NSValue <span>class],<br/></span>                              [NSData <span>class],<br/></span>                              [NSError <span>class],<br/></span>                              [NSArray <span>class],<br/></span>                              [NSDictionary <span>class],<br/></span>                              [NSString <span>class],<br/></span>                              [NSAttributedString <span>class], nil];</span></font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">然后判断</span></div><pre><code><font color="#0433ff">+ (BOOL)isClassFromFoundation:(Class)c<br/>{<br/>    if (c == [NSObject class] || c == [NSManagedObject class]) return YES;<br/><br/>    __block BOOL result = NO;<br/>    [[self foundationClasses] enumerateObjectsUsingBlock:^(Class foundationClass, BOOL *stop) {<br/>        if ([c isSubclassOfClass:foundationClass]) {<br/>            result = YES;<br/>            *stop = YES;<br/>        }<br/>    }];<br/>    return result;<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这里加__block是为了在block内部可以修改result.</span></div><h2>NSString+MJExtension.h</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这个类作用就是对字符串的一些操作，比如变量的命名方法转换。常见的驼峰转下划线（loveYou -&gt; love_you）、下划线转驼峰（love_you -&gt; loveYou）、首字母变大写、首字母变小写、是不是整形、是不是URL格式</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">其实就是一个工具分类,操作变量或者属性名</span></div><h2>MJPropertyType（基础类型）</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">对属性的具体类型进行封装，简单来说就是讲类型编码转为我们熟知的类型。暴露给外面使用，其属性如下：</span></div><pre><code><font color="#0433ff">/** 类型标识符，类型编码 */<br/>@property (nonatomic, copy) NSString *code;<br/><br/>/** 是否为id类型 */<br/>@property (nonatomic, readonly, getter=isIdType) BOOL idType;<br/><br/>/** 是否为基本数字类型：int、float等 */<br/>@property (nonatomic, readonly, getter=isNumberType) BOOL numberType;<br/><br/>/** 是否为BOOL类型 */<br/>@property (nonatomic, readonly, getter=isBoolType) BOOL boolType;<br/><br/>/** 对象类型（如果是基本数据类型，此值为nil） */<br/>@property (nonatomic, readonly) Class typeClass;<br/><br/>/** 类型是否来自于Foundation框架，比如NSString、NSArray */<br/>@property (nonatomic, readonly, getter = isFromFoundation) BOOL fromFoundation;<br/>/** 类型是否不支持KVC */<br/>@property (nonatomic, readonly, getter = isKVCDisabled) BOOL KVCDisabled;</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; color: rgb(4, 51, 255);">通过类方法初始化</span><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; color: rgb(4, 51, 255);">+ (instancetype)cachedTypeWithCode:(NSString *)code</span><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; color: rgb(4, 51, 255);">。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">因为总共的类型就如上提到的那几种，所以这里用了一个静态的字典保存结果。下次直接从结果中取，如果有则不用依次判断了</span></div><pre><code>static NSMutableDictionary *types_; 静态字典<br/>+ (void)initialize<br/>{<br/>    types_ = [NSMutableDictionary dictionary];<br/>}</code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">注意这里的initialize，如果你对Swizzle熟悉，那么load应该知道。顺便就提下两者的区别。</span></div><table><thead><tr><td><div>对比点</div></td><td><div>+(void)load</div></td><td><div>+(void)initialize</div></td></tr></thead><tbody><tr><td style="text-align: center;"><div>执行时机 </div></td><td style="text-align: center;"><div>在程序运行后立即执行 </div></td><td style="text-align: center;"><div>在类的方法第一次被调时执行 </div></td></tr><tr><td style="text-align: center;"><div>若自身未定义，是否沿用父类的方法？ </div></td><td style="text-align: center;"><div>否 </div></td><td style="text-align: center;"><div>是 </div></td></tr><tr><td style="text-align: center;"><div>类别中的定义 </div></td><td style="text-align: center;"><div>全都执行，但后于类中的方法 </div></td><td style="text-align: center;"><div>覆盖类中的方法，只执行一个 </div></td></tr></tbody></table><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">那缓存怎么实现的呢？</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">一般缓存的思路都一样：在第一次使用的时候保存结果。如果以后有相同的情况则直接从以前的结果中返回就可以了。</span></div><pre><code><font color="#0433ff">+ (instancetype)cachedTypeWithCode:(NSString *)code<br/>{<br/>    MJExtensionAssertParamNotNil2(code, nil);<br/><br/>    从缓存中取，如果没有才去设置<br/>    MJPropertyType *<span>type =</span> types_[code];<br/>    if (<span>type == nil) {</span><br/>        <span>type =</span> [[self alloc] init];<br/>        <span>type.code =</span> code;<br/>        存储起来<br/>        types_[code] = <span>type;</span><br/>    }<br/>    return <span>type;</span><br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">接下里看看类型编码的转换部分。</span></div><pre><code><font color="#0433ff">参数类型转换<br/>- (void)setCode:(NSString *)code<br/>{<br/>    _code = code;<br/><br/>    MJExtensionAssertParamNotNil(code);<br/><br/>    if ([code isEqualToString:MJPropertyTypeId]) {<br/>        _idType = YES;<br/>    } else if (code.length == 0) {<br/>        _KVCDisabled = YES;<br/>    } else if (code.length &gt; 3 &amp;&amp; [code hasPrefix:@&quot;@\&quot;&quot;]) {<br/>        去掉@&quot;和&quot;，截取中间的类型名称<br/>        _code = [code substringWithRange:NSMakeRange(2, code.length - 3)];<br/>        得到类型类型<br/>        _typeClass = NSClassFromString(_code);<br/>        _fromFoundation = [MJFoundation isClassFromFoundation:_typeClass];<br/>        是否为NSNumber类型<br/>        _numberType = [_typeClass isSubclassOfClass:[NSNumber class]];<br/><br/>    } else if ([code isEqualToString:MJPropertyTypeSEL] ||<br/>               [code isEqualToString:MJPropertyTypeIvar] ||<br/>               [code isEqualToString:MJPropertyTypeMethod]) {<br/>        _KVCDisabled = YES;<br/>    }<br/><br/>    是否为数字类型<br/>    NSString *lowerCode = _code.lowercaseString;<br/>    NSArray *numberTypes = @[MJPropertyTypeInt, MJPropertyTypeShort, MJPropertyTypeBOOL1, MJPropertyTypeBOOL2, MJPropertyTypeFloat, MJPropertyTypeDouble, MJPropertyTypeLong, MJPropertyTypeLongLong, MJPropertyTypeChar];<br/><br/>    是否为基本数据类型<br/>    if ([numberTypes containsObject:lowerCode]) {<br/>        _numberType = YES;<br/><br/>        if ([lowerCode isEqualToString:MJPropertyTypeBOOL1]<br/>            || [lowerCode isEqualToString:MJPropertyTypeBOOL2]) {<br/>            _boolType = YES;<br/>        }<br/>    }<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">比较重要的是这一段</span></div><pre><code><font color="#0433ff"> if ([code isEqualToString:MJPropertyTypeId]) {<br/>        _idType = YES;<br/>    } else if (code.length == 0) {<br/>        _KVCDisabled = YES;<br/>    } else if (code.length &gt; 3 &amp;&amp; [code hasPrefix:@&quot;@\&quot;&quot;]) {<br/>        去掉@&quot;和&quot;，截取中间的类型名称<br/>        _code = [code substringWithRange:NSMakeRange(2, code.length - 3)];<br/>        得到类型类型<br/>        _typeClass = NSClassFromString(_code);<br/>        _fromFoundation = [MJFoundation isClassFromFoundation:_typeClass];<br/>        是否为NSNumber类型<br/>        _numberType = [_typeClass isSubclassOfClass:[NSNumber class]];<br/><br/>    } else if ([code isEqualToString:MJPropertyTypeSEL] ||<br/>               [code isEqualToString:MJPropertyTypeIvar] ||<br/>               [code isEqualToString:MJPropertyTypeMethod]) {<br/>        _KVCDisabled = YES;<br/>    }</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">传进来的code就是属性所对应的属性名称，比如NSArray对应@&quot;NSArray&quot;。自定义的类，签名都会有一个@符号，后面接上类名。形式如@Classname。</span></div><h2>MJPropertyKey.h</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这个类是对属性进行分类。所有属性可以归为两类一种是字典，也就是键值对（NSDictionary）和数组（NSArray）。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">外面通过调用- (id)valueInObject:(id)object从传进来的id类型中取值。</span></div><h2>MJProperty.h</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">对objc_property_t封装，存储一个属性值相关的详细信息，将objc_property_t转为能够直接用的对象。它是对objc_property_t类型的一次封装，便于我们使用。同事它也依赖于上面所介绍的几种数据类型。从.h文件看到#import &quot;MJPropertyType.h&quot; #import &quot;MJPropertyKey.h&quot;。同样也依赖于#import &quot;MJFoundation.h&quot; #import &quot;MJExtensionConst.h&quot;</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">初始化入口函数+ (instancetype)cachedPropertyWithProperty:(objc_property_t)property。正如上面所说目的就是将runtime中的objc_property_t转为MJProperty方便我们的使用。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">具体实现：</span></div><pre><code><font color="#0433ff">+ (instancetype)cachedPropertyWithProperty:(objc_property_t)property<br/>{<br/>    MJProperty *propertyObj = objc_getAssociatedObject(self, property);<br/>    if (propertyObj == nil) {<br/>        propertyObj = [[self alloc] init];<br/>        转为MJProperty<br/>        propertyObj.property = property;<br/>        objc_setAssociatedObject(self, property, propertyObj, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br/>    }<br/>    return propertyObj;<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">MJProperty *propertyObj = objc_getAssociatedObject(self, property);这句话是动态给类添加属性，也就是说，给类添加了一个属性名为property的MJProperty类型属性。</span><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">注意这里是一个类方法，也就是这里的</span><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">self</span><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">代表什么。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这里的缓存方法是通过懒加载的形式实现的，将需要缓存的属性动态添加到类上面。如果没有则新加属性有则直接返回属性。这样做的目的是为了一个类可能在项目中会用到很多次字典转模型。所以保存一份之后就不用每次都创建新的属性标识了。</span><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">以空间换时间</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">把这个方法执行完，就得到了如下三个属性的值：</span></div><pre><code><font color="#0433ff">/** 成员属性 */<br/>@property (nonatomic, assign) objc_property_t property;<br/>/** 成员属性的名字 */<br/>@property (nonatomic, readonly) NSString *name;<br/><br/>/** 成员属性的类型 */<br/>@property (nonatomic, readonly) MJPropertyType *type;</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; color: rgb(4, 51, 255);">除了公开的属性还有两个私有属性：</span></div><pre><code><font color="#0433ff">@property (strong, nonatomic) NSMutableDictionary *propertyKeysDict;<br/>@property (strong, nonatomic) NSMutableDictionary *objectClassInArrayDict;</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; color: rgb(4, 51, 255);">他们分别保存了的类型是</span><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; color: rgb(4, 51, 255);">MJPropertyKey</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">通过</span></div><pre><code><font color="#0433ff">/**<br/> * 设置object的成员变量值<br/> */<br/>- (void)<span>setValue:(id)value forObject:(id)object</span>;<br/>/**<br/> * 得到object的成员属性值<br/> */<br/>- (id)<span>valueForObject:(id)object</span>;</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; color: rgb(4, 51, 255);">对特定的属性存取值。</span></div><pre><code><font color="#0433ff">/** 非数组类型 */<br/>- (void)<span>setOriginKey:(id)originKey forClass:(Class)c</span>;<br/>- (NSArray *)<span>propertyKeysForClass:(Class)c</span>;<br/><br/>/** 模型数组中的保存模型类型 */<br/>- (void)<span>setObjectClassInArray:(Class)objectClass forClass:(Class)c</span>;<br/>- (Class)<span>objectClassInArrayForClass:(Class)c</span>;</font></code></pre><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">记：本来该上个周就完成的。拖到了现在还没有分析完。</span></div></blockquote><h2>NSObject+MJClass.h</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">从这个类开始，就进入了分析NSObject分类的程度了。前面分析的对象是为NSObject所依赖的。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这个类的功能大致可以归为遍历、属性白名单、属性黑名单。所以可以重点来看看这三个部分。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">外部通过+ (NSMutableArray *)mj_totalIgnoredPropertyNames;和+ (NSMutableArray *)mj_totalAllowedCodingPropertyNames;获得黑名单与白名单。</span></div><h3>类的遍历</h3><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">遍历就两个方法：</span></div><pre><code><font color="#0433ff">+ (void)<span>mj_enumerateClasses:(MJClassesEnumeration)enumeration</span>;<br/>+ (void)<span>mj_enumerateAllClasses:(MJClassesEnumeration)enumeration</span>;</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">mj_enumerateClasses只要当前遍历的是Foundatoin框架的就会退出遍历，否则会一直沿着继承树遍历。mj_enumerateAllClasses会遍历继承树上所有的类。</span><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">为什么会存在遍历到</span><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">Foundatoin</span><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">框架就停止遍历了，因为我们自定义的模型大部分是继承至NSObject这中类型。这是为什么停止，那为什么要遍历。因为自定义的模型可能继承自己我们自定义的模型。为了保护所有的信息，比如属性信息，所以需要遍历。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">注意这里的参数是其实是一个typedef void (^MJClassesEnumeration)(Class c, BOOL *stop);Block。写法有点类似系统中数组遍历。这种写法值得学习，平时我们遍历都是在类中直接调用一个方法，而通过这样传递Block这样就更加解耦了。其实也可以通过Target-Action模式实现。注意这里的Bool类型传的是指针哦，就像*stop。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">相关的实现：</span></div><pre><code><font color="#0433ff">+ (void)mj_enumerateClasses:(MJClassesEnumeration)enumeration<br/>{<br/>     1.没有block就直接返回<br/>    if (enumeration == nil) return;<br/><br/>     2.停止遍历的标记<br/>    BOOL stop = NO;<br/><br/>     3.当前正在遍历的类<br/>    Class c = self;<br/><br/>     4.开始遍历每一个类<br/>    while (c &amp;&amp; !stop) {<br/>         4.1.执行操作<br/>         对一般类型取地址传递<br/>        enumeration(c, &amp;stop);<br/><br/>         4.2.获得父类<br/>        c = class_getSuperclass(c);<br/><br/>        if ([MJFoundation isClassFromFoundation:c]) break;<br/>    }<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">重点看看这句</span></div><pre><code> <font color="#0433ff"> 4.1.执行操作<br/>        对一般类型取地址传递<br/>        enumeration(c, &amp;stop);</font></code></pre><h3>白名单配置</h3><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">配置白名单是为了对属性进行过滤。只有在白名单中的属性名才会进行字典和模型的转换。来说一下这里涉及的配置方法。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">外部调用者，通过类方法传入Block参数进行配置。typedef NSArray * (^MJAllowedPropertyNames)();这是传入的Block定义。可以看到返回的是一个数组。为什么不直接将白名单属性暴露处理出来给调用者直接使用呢？大概是遵循了设计模式中的知道最少原则。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">在.m文件中定义了几个保存白名单、黑名单的静态数组。定义如下：</span></div><pre><code><font color="#0433ff">static NSMutableDictionary *allowedPropertyNamesDict_;<br/>static NSMutableDictionary *ignoredPropertyNamesDict_;<br/>static NSMutableDictionary *allowedCodingPropertyNamesDict_;<br/>static NSMutableDictionary *ignoredCodingPropertyNamesDict_;</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">为了保存传入的Block信息，需要给分类动态添加属性。</span></div><pre><code><font color="#0433ff">在分类中新增属性<br/>static const char MJAllowedPropertyNamesKey = '\0'; 白名单<br/>static const char MJIgnoredPropertyNamesKey = '\0'; 黑名单<br/>static const char MJAllowedCodingPropertyNamesKey = '\0'; 归档白名单<br/>static const char MJIgnoredCodingPropertyNamesKey = '\0'; 归档黑名单</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">比如这里的MJAllowedPropertyNamesKey就是白名单传进来的属性名称了。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">设置白名单的入口：</span></div><pre><code><font color="#0433ff">+ (void)mj_setupAllowedPropertyNames:(MJAllowedPropertyNames)allowedPropertyNames;<br/>{<br/>    [self mj_setupBlockReturnValue:allowedPropertyNames key:&amp;MJAllowedPropertyNamesKey];<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">最终调用的是mj_setupBlockReturnValue</span></div><pre><code><font color="#0433ff">+ (void)mj_setupBlockReturnValue:(id (^)())block key:(const char *)key<br/>{<br/>    if (block) {<br/>        objc_setAssociatedObject(self, key, block(), OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br/>    } else {<br/>        objc_setAssociatedObject(self, key, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br/>    }<br/><br/>    清空数据<br/>    [[self dictForKey:key] removeAllObjects];<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">可以很清楚的看到这里将block作为自身的属性。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">除了这种方式还有一种：</span><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">那就是在类中实现mj_allowedPropertyNames比如：</span></div><pre><code><font color="#0433ff">+ (NSArray *)mj_allowedPropertyNames {<br/>    return @[@&quot;name&quot;,@&quot;icon&quot;];<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">后面获取可用属性的时候会对这两种方式都判断。</span></div><h3>设置黑名单</h3><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">设置黑名单的方式和设置白名单类似。</span></div><h3>最终可转换的数组</h3><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">调用这个方法mj_totalIgnoredPropertyNames就是返回经过过滤后的属性。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">一共有两种方式，一种是通过Selecotr一种是通过Block设置。</span></div><pre><code><font color="#0433ff">+ (NSMutableArray *)mj_totalObjectsWithSelector:(SEL)selector key:(const char *)key<br/>{<br/>    NSMutableArray *array = [self dictForKey:key][NSStringFromClass(self)];<br/>    if (array) return array;<br/><br/>    创建、存储<br/>    [self dictForKey:key][NSStringFromClass(self)] = array = [NSMutableArray array];<br/><br/>    if ([self respondsToSelector:selector]) {<br/>#pragma clang diagnostic push<br/><span>#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br/>        NSArray *subArray = [self performSelector:selector];<br/>#pragma clang diagnostic pop<br/>        if (subArray) {<br/>            [array addObjectsFromArray:subArray];<br/>        }<br/>    }<br/><br/>    [self mj_enumerateAllClasses:^(__unsafe_unretained Class c, BOOL *stop) {<br/>        NSArray *subArray = objc_getAssociatedObject(c, key);<br/>        [array addObjectsFromArray:subArray];<br/>    }];<br/>    return array;<br/>}</font></code></pre><h4>通过Selector</h4><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">selector是使用者如果想添加白名单需要自定义实现类方法mj_allowedPropertyNames。返回的是一个白名单数组。黑名单原理类似。key是指定过滤的是白名单还是黑名单。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">selector的方式需要给对应的类添加一个类方法如：</span></div><pre><code><font color="#0433ff">+ (NSArray *)mj_allowedPropertyNames {<br/>    return @[@&quot;name&quot;,@&quot;icon&quot;];<br/>}</font></code></pre><h4>通过Block</h4><blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">疑惑：前面设置的是一个返回值类型为数组的Block。代码：</span></div><pre><code>  <font color="#0433ff">if (block) {<br/>        objc_setAssociatedObject(self, key, block(), OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br/>    } else {<br/>        objc_setAssociatedObject(self, key, nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br/>    }</font></code></pre></blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">但是取得时候又是直接取得数组。难道这个时候block会自动执行，然后返回执行结果</span></div><blockquote><pre><code>  <span><font color="#0433ff">[self mj_enumerateAllClasses:^<span>(__unsafe_unretained Class c, BOOL *stop)</span> {<br/>        NSArray *subArray = objc_getAssociatedObject<span>(c, key)</span>;<br/>        <span>[array addObjectsFromArray:subArray];<br/>    }];</span></font></span></code></pre></blockquote><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">最后通过实践证明，确实能够从</span><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">objc_getAssociatedObject(c, key);</span><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">得到对应的数组。也就是作为属性的</span><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">block</span><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">执行了。</span></div><h2>NSObject+MJCoding.h</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这个类是用于归档。只有实现了MJCoding协议的类才能够归档。</span></div><pre><code><font color="#0433ff">/**<br/> *  这个数组中的属性名才会进行归档<br/> */<br/>+ (NSArray *)mj_allowedCodingPropertyNames;<br/>/**<br/> *  这个数组中的属性名将会被忽略：不进行归档<br/> */<br/>+ (NSArray *)mj_ignoredCodingPropertyNames;</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">在进行归档的时候，我们只需要在Implemenion中添加MJExtensionCodingImplementation。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">实际上是宏定义了NSCode进行归档，解档。</span></div><pre><code><font color="#0433ff">#define MJCodingImplementation \<br/>- (id)initWithCoder:(NSCoder *)decoder \<br/>{ \<br/>if (self = [super init]) { \<br/>[self mj_decode:decoder]; \<br/>} \<br/>return self; \<br/>} \<br/>\<br/>- (void)encodeWithCoder:(NSCoder *)encoder \<br/>{ \<br/>[self mj_encode:encoder]; \<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; color: rgb(4, 51, 255);">看一看归档的部分，解档的步骤一样。</span></div><pre><code><font color="#0433ff">- (void)mj_encode:(NSCoder *)encoder<br/>{<br/>    Class clazz = [self class];<br/><br/>    NSArray *allowedCodingPropertyNames = [clazz mj_totalAllowedCodingPropertyNames];<br/>    NSArray *ignoredCodingPropertyNames = [clazz mj_totalIgnoredCodingPropertyNames];<br/><br/>    [clazz mj_enumerateProperties:^(MJProperty *property, BOOL *stop) {<br/>        检测是否被忽略<br/>        if (allowedCodingPropertyNames.count &amp;&amp; ![allowedCodingPropertyNames containsObject:property.name]) return;<br/>        if ([ignoredCodingPropertyNames containsObject:property.name]) return;<br/><br/>        id value = [property valueForObject:self];<br/>        if (value == nil) return;<br/>        [encoder encodeObject:value forKey:property.name];<br/>    }];<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">直接看重点：</span></div><pre><code> <font color="#0433ff"> id value = [property valueForObject:self];<br/>  if (value == nil) return;<br/>  [encoder encodeObject:value forKey:property.name];</font></code></pre><h2>NSObject+MJProperty.h</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这个类保存的属性的一些配置。大致可分为：</span></div><ul><li>1.遍历属性</li><li>2.新值配置</li><li>3.key配置</li><li>4.array model class配置</li></ul><h3>遍历属性</h3><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">+ (void)mj_enumerateProperties:(MJPropertiesEnumeration)enumeration遍历所有属性的入口。这个方法在很多地方都存在过。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">属性会从缓存中取，NSArray *cachedProperties = [self properties];。[self properties]是缓存属性的部分。然后就直接遍历所有的属性。</span></div><pre><code><font color="#0433ff">+ (void)mj_enumerateProperties:(MJPropertiesEnumeration)enumeration<br/>{<br/>    获得成员变量<br/>    从类的继承树遍历每一个类，从类中获得属性<br/>    NSArray *cachedProperties = [self properties];<br/><br/>    遍历成员变量<br/>    BOOL stop = NO;<br/>    for (MJProperty *property in cachedProperties) {<br/>        enumeration(property, &amp;stop);<br/>        if (stop) break;<br/>    }<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这里遍历用了block,外部传递block进来遍历。typedef void (^MJPropertiesEnumeration)(MJProperty *property, BOOL *stop);这个库很多地方都用到了类似的遍历方式。</span></div><h3>新值配置</h3><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">新值配置是什么意思？：就是改变特定的属性的原有值，这样更加灵活。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">同样有两种方式Block和类方法。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">存取方法如下：</span></div><pre><code><font color="#0433ff">+ (void)<span>mj_setupNewValueFromOldValue:(MJNewValueFromOldValue)newValueFormOldValue</span>;<br/>+ (id)<span>mj_getNewValueFromObject:(__unsafe_unretained id)object oldValue:(__unsafe_unretained id)oldValue property:(__unsafe_unretained MJProperty *)property</span>;</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这里的typedef id (^MJNewValueFromOldValue)(id object, id oldValue, MJProperty *property);其实和下面方法参数形式是一样的。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">看了一下这个方法，一次只支持一个属性新值配置。</span></div><pre><code><font color="#0433ff">+ (void)<span>mj_setupNewValueFromOldValue:<span>(MJNewValueFromOldValue)newValueFormOldValue<br/>{<br/>    objc_setAssociatedObject(self, &amp;MJNewValueFromOldValueKey, newValueFormOldValue, OBJC_ASSOCIATION_COPY_NONATOMIC)</span></span>;<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">如何获取新？肯定需要兼容两种设置方式，一种Block,一种通过方法设置。</span></div><pre><code><font color="#0433ff">+ (id)mj_getNewValueFromObject:(__unsafe_unretained id)object oldValue:(__unsafe_unretained id)oldValue property:(MJProperty *__unsafe_unretained)property{<br/>    如果有实现方法<br/>    if ([object respondsToSelector:@selector(mj_newValueFromOldValue:property:)]) {<br/>        return [object mj_newValueFromOldValue:oldValue property:property];<br/>    }<br/>    兼容旧版本<br/>    if ([self respondsToSelector:@selector(newValueFromOldValue:property:)]) {<br/>        return [self performSelector:@selector(newValueFromOldValue:property:)  withObject:oldValue  withObject:property];<br/>    }</font><br/><br/>   <font color="#0433ff"> 查看静态设置<br/>    __block id newValue = oldValue;<br/>    [self mj_enumerateAllClasses:^(__unsafe_unretained Class c, BOOL *stop) {<br/>        MJNewValueFromOldValue block = objc_getAssociatedObject(c, &amp;MJNewValueFromOldValueKey);<br/>        if (block) {<br/>            newValue = block(object, oldValue, property);<br/>            *stop = YES;<br/>        }<br/>    }];<br/>    return newValue;<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">思路和上面分析白名单，黑名单设置的方式一样。</span></div><h3>key配置</h3><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">key配置是解决属性名成需要重新定义的情况。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这个配置统一通过Block设置。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这里注意到为什么在动态添加了属性之后需要将cachedPropertiesDict_字典里面的清空一次。如下：</span></div><pre><code><font color="#0433ff">+ (void)mj_setupReplacedKeyFromPropertyName:(MJReplacedKeyFromPropertyName)replacedKeyFromPropertyName<br/>{<br/>    [self mj_setupBlockReturnValue:replacedKeyFromPropertyName key:&amp;MJReplacedKeyFromPropertyNameKey];<br/><br/>    [[self dictForKey:&amp;MJCachedPropertiesKey] removeAllObjects];<br/>}<br/><br/>+ (void)mj_setupReplacedKeyFromPropertyName121:(MJReplacedKeyFromPropertyName121)replacedKeyFromPropertyName121<br/>{<br/>    objc_setAssociatedObject(self, &amp;MJReplacedKeyFromPropertyName121Key, replacedKeyFromPropertyName121, OBJC_ASSOCIATION_COPY_NONATOMIC);<br/><br/>    [[self dictForKey:&amp;MJCachedPropertiesKey] removeAllObjects];<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这样做的目的是为了保证缓存数组中的数据是最新的。因为我们替换了属性的key，所以要用最新的。在获取所有属性中。有这么一段：</span></div><pre><code><font color="#0433ff"> NSMutableArray *cachedProperties = [self dictForKey:&amp;MJCachedPropertiesKey][NSStringFromClass(self)];<br/><br/>    if (cachedProperties == nil) {<br/>        cachedProperties = [NSMutableArray array];<br/>         遍历类继承树，一直遍历到fondation框架。也就是到NSObject就停止遍历。因为我们模型都是从NSObject开始继承的<br/>        [self mj_enumerateClasses:^(__unsafe_unretained Class c, BOOL *stop) {<br/>         1.获得所有的成员变量<br/><br/>        ......<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">可以看到只有属性为空才会遍历类，获取最新属性。</span></div><h3>array model class配置</h3><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这个方法是处理模型中包含一另一个模型数组。</span><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">在实际运用比较多。</span></div><pre><code><font color="#0433ff">+ (void)<span>mj_setupObjectClassInArray:(MJObjectClassInArray)objectClassInArray<br/>{<br/>    [self mj_setupBlockReturnValue:objectClassInArray key:&amp;MJObjectClassInArrayKey]</span>;<br/><br/>    [[self dictForKey:&amp;MJCachedPropertiesKey] removeAllObjects];<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">和上面的方式一样，会将最终会作为类的一个属性将模型数组字典保存下来。方便后面使用。</span></div><pre><code><font color="#0433ff">static const char MJReplacedKeyFromPropertyNameKey = '\0';<br/>static const char MJReplacedKeyFromPropertyName121Key = '\0';<br/>static const char MJNewValueFromOldValueKey = '\0';<br/>static const char MJObjectClassInArrayKey = '\0';<br/><br/>static const char MJCachedPropertiesKey = '\0';</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这是NSObject+MJProperty.h动态添加的所有属性。通过名字可以知道它的用途。</span></div><h2>NSObject+MJKeyValue.h</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">这个类的内容有点多</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这个类中有一个很重要的协议MJKeyValue。</span></div><pre><code><font color="#0433ff">+ <span>(NSArray *)mj_allowedPropertyNames;<br/>+ (NSArray *)</span>mj_ignoredPropertyNames;<br/>+ <span>(NSDictionary *)mj_replacedKeyFromPropertyName;<br/>+ (id)mj_replacedKeyFromPropertyName121:(NSString *)</span>propertyName;<br/>+ <span>(NSDictionary *)mj_objectClassInArray;<br/>- (id)mj_newValueFromOldValue:(id)oldValue property:(MJProperty *)</span>property;<br/>- <span>(void)</span>mj_keyValuesDidFinishConvertingToObject;<br/>- <span>(void)</span>mj_objectDidFinishConvertingToKeyValues;</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这里的协议规定了白名单、黑名单。之前分析过通过block的形式同样能够实现黑、白名单。我猜测这个文件是很久之前就有了为了兼容性，所以这种设置白、黑名单的方式一致保留着。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold;">这也是我们分析的最后一个类，可能也是最复杂的一个类</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">分别是：</span></div><ul><li>类方法</li><ul><li>错误定义</li><li>转换字典replace设置</li><li>模型转字典</li><ul><li>转所有属性</li><li>制定部分属性转</li><li>忽略部分属性转</li><li>模型数组转字典数组</li></ul><li>字典转模型</li><ul><li>字典转为模型（可以是NSDictionary、NSData、NSString）</li><li>字典转为模型（可以是NSDictionary、NSData、NSString）<span style="font-weight: bold;">CoreData支持</span></li></ul><li>字典数组转模型数组</li><ul><li>字典数组来创建一个模型数组（可以是NSDictionary、NSData、NSString）</li><li>字典数组来创建一个模型数组（可以是NSDictionary、NSData、NSString）<span style="font-weight: bold;">CoreData支持</span></li><li>plist来创建一个模型数组</li><ul><li>仅限于mainBundle中的文件</li><li>文件全路径</li></ul></ul><li>模型转json、字典、数组</li><ul><li>转换为JSON Data</li><li>转换为字典或者数组</li><li>转换为JSON 字符串</li></ul></ul><li>对象方法</li><ul><li>字典转模型</li><ul><li>字典转为模型（可以是NSDictionary、NSData、NSString）</li><li>字典转为模型（可以是NSDictionary、NSData、NSString）<span style="font-weight: bold;">CoreData支持</span></li></ul></ul></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">上面所列的内容就是这个框架提供给使用者的所有功能了。这个部分就是把之前分析的内容串在一起。实现这些功能。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">我们从最常用的+ (instancetype)mj_objectWithKeyValues:(id)keyValues;方法入手。从头到尾走一遍这个流程。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">直接看最核心部分。入口就是- (instancetype)mj_setKeyValues:(id)keyValues context:(NSManagedObjectContext *)context这个方法。我们把外部的字典，json传入，最终把字典的key映射到对应的属性上，value成为这个属性的值。</span></div><h3>参数过滤</h3><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">第一步肯定是对参数合法性进行校验。</span></div><pre><code> keyValues = [keyValues mj_JSONObject];<br/><br/>    MJExtensionAssertError([keyValues isKindOfClass:[NSDictionary class]], self, [self class], @&quot;keyValues参数不是一个字典&quot;);</code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">经过转换后还不是字典类型就直接抛出异常。</span></div><h3>黑名单，白名单过滤</h3><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">接下来如果使用者配置了属性的白名单或者黑名单，则会对取出黑白名单。在遍历类的属性的时候过滤掉。</span></div><pre><code><font color="#0433ff"> NSArray *allowedPropertyNames = [clazz mj_totalAllowedPropertyNames];<br/> NSArray *ignoredPropertyNames = [clazz mj_totalIgnoredPropertyNames];</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">因为属性列表是在类对象上，所以自然去NSObject+MJClass.h调用。这个类主要功能就是提供了黑白名单的存储。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">NSObject+MJClass.h中存储的黑白名单</span></div><pre><code><font color="#0433ff">static const char MJAllowedPropertyNamesKey = '\0'; 白名单<br/>static const char MJIgnoredPropertyNamesKey = '\0'; 黑名单<br/>static const char MJAllowedCodingPropertyNamesKey = '\0'; 归档白名单<br/>static const char MJIgnoredCodingPropertyNamesKey = '\0'; 归档黑名单</font></code></pre><h3>遍历类的所有属性</h3><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">接下来就是对类的每个属性处理，比如替换，忽略等。涉及到属性的是在NSObject+MJProperty.h类中完成的。比如遍历就是。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">通过传入block,在遍历的同时对属性就行处理。形式就像通过enumerateObjectsUsingBlock:遍历。</span></div><pre><code><font color="#0433ff">[someArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {<br/><br/>    }]</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">遍历属性</span></div><pre><code><span><font color="#0433ff">[clazz mj_enumerateProperties:^<span>(MJProperty *property, BOOL *stop)</span> {<br/>......<br/>}];</font></span></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">如果属性在白名单或者黑名单中出现在则直接跳出这次循环。</span></div><pre><code><font color="#0433ff"> if <span>(allowedPropertyNames.count &amp;&amp; ![allowedPropertyNames containsObject:property.name])</span> return;<br/> if <span>([ignoredPropertyNames containsObject:property.name])</span> return;</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">取出属性对应的值，当然这里增加了对值得过滤，比如设置了新值替换旧的值。如果最终取出的结果中没有值，则直接返回。</span></div><pre><code><font color="#0433ff"> id value;<br/><br/>NSArray *propertyKeyses = [property propertyKeysForClass:clazz];<br/>for (NSArray *propertyKeys in propertyKeyses) {<br/>    value = keyValues;<br/>    for (MJPropertyKey *propertyKey in propertyKeys) {<br/>        value = [propertyKey valueInObject:value];<br/>    }<br/>    if (value) break;<br/>}</font><br/><br/><font color="#0433ff">值的过滤<br/>id newValue = [clazz mj_getNewValueFromObject:self oldValue:value property:property];<br/>if (newValue != value) {  有过滤后的新值<br/>    [property setValue:newValue forObject:self];<br/>    return;<br/>}<br/></font><br/><font color="#0433ff">如果没有值，就直接返回<br/>if (!value || value == [NSNull null]) return;</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">接下里就是最终处理部分了。这时候属性的key和value都是合法的了。</span></div><ul><li>1.剩下的就是处理属性。比如讲不可变数组转为可变数组。</li><li>2.如果不是Foundation框架的类，也就是继承至自定义模型的需要递归遍历。</li><li>3.对模型数组的处理</li><li>4.如果是Foundation框架中的。这个部分就可以直接给value赋值了。</li><li>5.最终KVC给属性赋值。[property setValue:value forObject:self];</li></ul><div><br/></div><div style="font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%; font-weight: bold;">笔记整理：Edison</span></div><div style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em; border-width: 100%; font-weight: bold; color: rgb(79, 129, 189); unicode-bidi: embed;">联系方式：QQ：277593 （笔记意见建议可加此Q，专人更新此笔记）；</span></div><div style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em; border-width: 100%; color: rgb(79, 129, 189); unicode-bidi: embed;"> </span></div><div style="font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%; font-weight: bold;">注：小道途径获取到的笔记，无法自动更新，请谅解！(笔记平均每月更新一次，祝各位都能拿到心仪的offer)</span><span style="direction: ltr; font-family: Menlo; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%;"> </span></div><div><br/></div></span>
</div></body></html> 