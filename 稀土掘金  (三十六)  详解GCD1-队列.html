<html>
<head>
  <title>稀土掘金  (三十六) : 详解GCD&lt;1&gt;-队列</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <meta name="application-data:corenote-hostUUID" content="C8940BC2-A53C-4B55-B59C-4779464BC778"/>
  <meta name="application-data:corenote-localUUID" content="8E774E66-6867-41BD-9DC6-E847B3AB403D"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="840"/>
<h1>稀土掘金  (三十六) : 详解GCD&lt;1&gt;-队列</h1>

<div><span><div><b>GCD有三种queue</b><br/></div><div><br/></div><div><b>main queue</b>: 主线程队列。是一个串行队列。一般用来更新UI。</div><div><b>global queue</b>: 全局队列，是一个并行队列。使用方法相信大家都知道。</div><div><br/></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image.png" type="image/png" data-filename="Image.png" width="408"/></div><div><br/></div><div>上面的意思就是开启一个异步线程，在全局队列中执行。</div><div><br/></div><div><b>custom queue</b>:自定义队列。有两种自定义队列。”</div><div><br/></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [1].png" type="image/png" data-filename="Image.png" width="375"/></div><div><br/></div><div><b>serial_queue</b>即是我自定义的一个串行队列。上面提到的主线程队列也是一个串行队列。</div><div>concurrent_queue是我自定义的一个并行队列。上面提到的global queue就是一个并行队列。</div><div>现在我们来讨论2个问题。</div><div><br/></div><div><b>1.dispatch_async里使用串行队列和并行队列的效果。</b></div><div><b>2.dispatch_sync里使用串行队列和并行队列的效果。</b></div><div><br/></div><div>串行队列和并行队列的创建如下。</div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [2].png" type="image/png" data-filename="Image.png" width="419"/></div><div><br/></div><div><font style="font-size: 24px;"><b>讨论的问题：</b></font></div><div><font style="font-size: 14px;"><b>“在dispatch_async使用串行队列”</b></font></div><div><font style="font-size: 14px;"><b><br/></b></font></div><div>代码如下：</div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [3].png" type="image/png" data-filename="Image.png" width="538"/></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [4].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="533"/></div><div><br/></div><div><br/></div><div><b>然后在viewDidLoad()方法里打印，打印结果如下。</b></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [5].png" type="image/png" data-filename="Image.png" width="482"/></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [6].png" type="image/png" data-filename="Image.png" width="480"/></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [7].png" type="image/png" data-filename="Image.png" width="484"/><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [8].png" type="image/png" data-filename="Image.png" width="482"/></div><div>打印结果的几个特征。</div><div><br/></div><div>在dispatch_async使用的所有Thread均为同一个Thread。因为他们的指针地址完全相同。</div><div>输出结果是按顺序输出，符合我们对串行队列的期待。即FIFO。先进先出原则。</div><div>Running on main Thread这句话并没有在最后执行，而是会出现在随机的位置，这也符合我们对dispatch_async的期待，因为他会开辟一个新的线程执行，不会阻塞主线程。 ok，让我们测试下一个。</div><div><br/></div><div>在dispatch_async中使用并行队列</div><div><br/></div><div>看代码：</div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [9].png" type="image/png" data-filename="Image.png" width="473"/></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [10].png" type="image/png" data-filename="Image.png" width="474"/></div><div><br/></div><div>打印结果如下：</div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [11].png" type="image/png" data-filename="Image.png" width="471"/></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [12].png" type="image/png" data-filename="Image.png" width="470"/></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [13].png" type="image/png" data-filename="Image.png" width="469"/></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [14].png" type="image/png" data-filename="Image.png" width="469"/></div><div><br/></div><div><b>打印结果的特征如下：</b></div><div><br/></div><div>输出的结果是乱序的，说明我们的输出语句是并发的，由多个线程共同执行的。</div><div>Running on main Thread这句话依然没有被阻塞，直接输出了。</div><div>每次打印语句的Thread均不相同。</div><div>仔细比对两次打印结果的异同点。提出问题。</div><div><br/></div><div>串行队列如何保证在异步线程中遵守先进先出原则（从Demo里看，也就是顺序打印我们的结果）？</div><div>很简单，它会保证每次dispatch_async开辟线程执行串行队列中的任务时，总是使用同一个异步线程。这也是为什么我们的第一次打印结果中，NSThread总是同一个。</div><div>在dispatch_async中放入并行队列并执行的时候，为什么执行顺序总是乱序的？</div><div>因为在并行对列中，每执行一次任务的时候，dispatch_async总会为我们开辟一个新的线程（当然，开辟线程的[…]”</div><div><br/></div><div><b><font style="font-size: 18px;">在dispatch_sync使用串行队列：</font></b></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [15].png" type="image/png" data-filename="Image.png" style="font-weight: bold; font-size: 18px;" width="474"/></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [16].png" type="image/png" data-filename="Image.png" width="474"/></div><div><br/></div><div><br/></div><div><b>打印结果如下：</b></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [17].png" type="image/png" data-filename="Image.png" style="font-weight: bold;" width="473"/></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [18].png" type="image/png" data-filename="Image.png" width="472"/></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [19].png" type="image/png" data-filename="Image.png" width="472"/></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [20].png" type="image/png" data-filename="Image.png" width="473"/></div><div><br/></div><div><br/></div><div>1.dispatch_sync并没有开辟一个新的线程，直接在当前线程中执行代码（即main线程）。所以会阻塞当前线程。</div><div>2.Running on main Thread在最后输出。</div><div>也就是说，当使用dispatch_sync执行串行队列的任务时，不会开辟新的线程，会直接使用当前线程执行队列中的任务。</div><div><br/></div><div><font style="font-size: 18px;"><b>在dispatch_sync中使用并行队列</b></font></div><div><font style="font-size: 18px;"><b><br/></b></font></div><div><font style="font-size: 14px;">代码如下：</font></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [21].png" type="image/png" data-filename="Image.png" width="473"/></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [22].png" type="image/png" data-filename="Image.png" style="font-weight: bold; font-size: 18px;" width="472"/></div><div><br/></div><div>打印结果如下：</div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [23].png" type="image/png" data-filename="Image.png" width="472"/></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [24].png" type="image/png" data-filename="Image.png" width="473"/></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [25].png" type="image/png" data-filename="Image.png" width="472"/></div><div><img src="稀土掘金  (三十六)  详解GCD1-队列_files/Image [26].png" type="image/png" data-filename="Image.png" width="472"/></div><div><b><br/></b></div><div><b>总结：</b></div><div><b>结果很奇怪，和在串行队列执行的效果一模一样。按我们的思考，并行队列里执行任务不应该是多个线程同时跑么？其实是由于dispatch_sync并不会开辟新的线程执行任务，所以导致了执行并行队列任务的线程总会是一个线程，自然，结果是一样的。</b></div><div><br/></div><div><br/></div></span>
</div></body></html> 