<html>
<head>
  <title>稀土掘金  (三) : GCD源码分析</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <meta name="application-data:corenote-hostUUID" content="C8940BC2-A53C-4B55-B59C-4779464BC778"/>
  <meta name="application-data:corenote-localUUID" content="B893D387-4DF7-47B8-9980-4B029F1ED593"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1575"/>
<h1>稀土掘金  (三) : GCD源码分析</h1>

<div>
<span><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">Dispatch Queue</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">Dispatch Queue 对于我们开发者来说应该是非常熟悉了，运用的场景非常之多，但是他的内部是如何实现的呢？</span></div><ul><li>用于管理追加的Block的C语言层实现的FIFO队列</li><li>Atomic函数中实现的用于排他控制的轻量级信号</li><li>用于管理线程的C语言层实现的一些容器</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">不难想象，GCD的实现需要使用以上这些工具，但是如果仅用这些内容便可实现，那么就不需要内核级实现了。(实际上在一般的Linux内核中可能使用面向Linux操作系统而移植的GCD)。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">甚至有人会想，只要努力编写线程管理的代码，就根本用不到GCD，是这样的吗？</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">我们先来回顾一下苹果的官方说明:</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; font-weight: bold; font-size: 12px;">通常，应用程序中编写的线程管理用的代码要在系统级实现。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">实际上正如这句话所说，在系统级即iOS和OS X的核心XNU内核级上实现，因此无论编程人员如何努力编写管理线程的代码，在性能方面也不可能胜过XNU内核级所实现的GCD。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">使用GCD要比使用pthreads和NSThread这些一般的多线程编程API更好。并且，如果用GCD就不必编写为操作线程反复出现的类似的源代码（这里被称为固定源代码片段），而可以在线程中集中实现处理内容，真的是好处多多。我们尽量多使用GCD或者使用了Cocoa框架GCD的NSOperationQueue类等API。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">编程人员所使用GCD的API全部包含在libdispatch库的C语言函数。Dispatch Queue通过结构体和链表，被实现为FIFO队列。FIFO队列主要是负责管理通过dispatch_async等函数所追加的一系列Blocks。所以我们可以理解为一旦我们在程序中由上到下追加了一组Blocks，那么排除掉dispatch_after，其内部的追加过程是一个先进先出原则。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">但是Block本身并不是直接加入到这个FIFO队列中，而是先加入Dispatch Continuation这一dispatch_continuation_t类型结构体中，然后再进入FIFO队列。该结构体用于记忆Block所属的Dispatch Group和其他一些信息，相当于一般常说的执行上下文(execution context)。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">Dispatch Queue可通过dipatch_set_target_queue函数设定，可以设定执行该Dispatch Queue处理的Dispatch Queue为目标。该目标可像串珠子一样，设定多个连接在一起的Dispatch Queue，但是在连接串的最后必须设定为Main Dispatch Queue，或各种优先级的Global Dispatch Queue，或是准备用于Serial Dispatch Queue的各种优先级的Global Dispatch Queue。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">Main Dispatch Queue 在RunLoop中执行Block。这并不是令人耳目一新的新技术。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">Global Dispatch Queue有如下8种:</span></div><div>Global Dispatch Queue (High priority)</div><div>Global Dispatch Queue (Default priority)</div><div>Global Dispatch Queue (Low priority)</div><div>Global Dispatch Queue (Background priority)</div><div>Global Dispatch Queue (High overcommit priority)</div><div>Global Dispatch Queue (Default overcommit priority)</div><div>Global Dispatch Queue (Low overcommit priority)</div><div>Global Dispatch Queue (Background overcommit priority)</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">注意前面四种 和后面四种不同优先级的Queue有一词之差:Overcommit。其区别就在于Overcommit Queue不管系统状态如何都会强制生成线程队列。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这8种Global Dispatch Queue 各使用一个pthread_workqueue。GCD初始化时，使用pthread_workqueue_create_np函数生成pthread_wrokqueue。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">pthread_wrokqueue包含在Libc提供的pthreads API中。它通过系统的bsdthread_register和workq_open函数调用，在初始化XNU内核的workqueue之后获取其信息。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">XNU内核有4种workqueue:</span></div><div>WORKQUEUE_HIGH_PRIOQUEUE</div><div>WORKQUEUE_DEFAULT_PRIOQUEUE</div><div>WORKQUEUE_LOW_PRIOQUEUE</div><div>WORKQUEUE_BG_PRIOQUEUE</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"> </span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">以上为4种执行优先级的workqueue。该执行优先级与Global Dispatch Queue的4种执行优先级相同。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">下面看一下Dispatch Queue中执行Block的过程。当在Global Dispatch Queue 中执行Block时，libdispatch 从Global Dispatch Queue自身的FIFO队列取出Dispatch Continuation，调用pthread_workqueue_additem_np函数。将该Global Dispatch Queue 本身、符合其优先级的workqueue信息以及执行Dispatch Continuation的回调函数等传递给参数。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><img src="稀土掘金  (三)  GCD源码分析_files/Image.png" type="image/png" data-filename="Image.png"/><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">pthread_workqueue_additem_np函数使用workq_kernreturn系统调用，通知workqueue增加应当执行的项目。根据该通知，XNU内核基于系统状态判断是否要生成线程。如果是Overcommit优先级的Global Dispatch Queue ，workqueue则始终生成线程。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">该线程虽然与iOS和OS X中通常使用的线程大致相同，但是有一部分pthread API不能使用。详细信息可以参考苹果的官方文档《并发编程指南》的“Compatibility with POSIX Threads“这一章节。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">另外，因为workqueue生成的线程在实现用于workqueue的线程计划表中运行，他的上下文切换(shift context)与普通的线程有很大的不同。这也是我们使用GCD的原因。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">workqueue的线程执行pthread_workqueue函数，该函数调用libdispatch的回调函数。在该回调函数中执行加入到Global Dispatch Queue中的下一个Block。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">以上就是Dispatch Queue执行的大概过程。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">由此可知，在编程人员自己编写的线程管理代码中想发挥出原生GCD的性能是不可能的。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%; font-weight: bold;">笔记整理：Edison</span></div><div style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em; border-width: 100%; font-weight: bold; color: rgb(79, 129, 189); unicode-bidi: embed;">联系方式：QQ：277593 （笔记意见建议可加此Q，专人更新此笔记）；</span></div><div style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em; border-width: 100%; color: rgb(79, 129, 189); unicode-bidi: embed;"> </span></div><div style="font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%; font-weight: bold;">注：小道途径获取到的笔记，无法自动更新，请谅解！(笔记平均每月更新一次，祝各位都能拿到心仪的offer)</span><span style="direction: ltr; font-family: Menlo; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%;"> </span></div><div><br/></div></span>
</div></body></html> 