<html>
<head>
  <title>稀土掘金  (二) : AFN3.1.0源码分析</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <meta name="application-data:corenote-hostUUID" content="C8940BC2-A53C-4B55-B59C-4779464BC778"/>
  <meta name="application-data:corenote-localUUID" content="F44F1F82-9676-4456-AAB5-C74AE4B8B2DA"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1577"/>
<h1>稀土掘金  (二) : AFN3.1.0源码分析</h1>

<div>
<span><div>AFNetworking基本是iOS开发中的网络第三方库标配,本文基于<a href="https://github.com/AFNetworking/AFNetworking/tree/3.1.0">AFNetworking3.1.0</a>版本。废话不多说，这篇文章主要从使用的角度来介绍AFNetworking的发起Get请求的过程，偏重于解读过程，解读当你使用AFNetworking发起一个Get请求的时候，AFNetworking内部的处理过程。而不是对AFNetworking源代码的各个类的代码进行深入解析，在源码深度解析方面，网络上已经有很多不错的文章，在文章的末尾我会给出参考链接。</div><div><br/></div><div>Get请求流程图</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这是AFNetworking发起一个Get请求的流程图，大概可以分为这几个步骤，我会逐个解读这个流程。</span></div><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image.png" type="image/png" data-filename="Image.png"/><br/></div><div>Get请求流程图</div><h2>AFHTTPSessionManager发起Get请求</h2><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image [1].png" type="image/png" data-filename="Image.png"/><br/></div><div>发起Get请求</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">这个方法是AFN的Get请求的起点，其他Get请求的方法也都是直接或者间接调用这个方法来发起Get请求。这个方法的代码量很少也很直观，就是调用其他方法生成NSURLSessionDataTask对象的实例,然后调用NSURLSessionDataTask的resume方法发起请求。</span></div><h2>创建NSURLSessionDataTask</h2><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image [2].png" type="image/png" data-filename="Image.png"/><br/></div><div>创建NSURLSessionDataTask</div><div><br/></div><div>这个方法是创建NSURLSessionDataTask对象实例并返回这个实例。首先创建一个NSMutableURLRequest对象的实例，然后配置。之后是使用NSMutableURLRequest对象的实例创建NSURLSessionDataTask对象实例，然后配置，可以选择性地传入各类Block回调，用于监听网络请求的进度比如上传进度，下载进度，请求成功，请求失败。</div><h3>配置NSMutableURLRequest对象</h3><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image [3].png" type="image/png" data-filename="Image.png"/><br/></div><div>配置NSMutableURLRequest对象</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">在这个方法中先使用了url创建了一个NSMutableURLRequest对象的实例,并且设置了HTTPMethod为Get方法（如果是Post方法，那么这里就是设置Post方法，以此类推）然后使用KVC的方法设置了NSMutableURLRequest的一些属性。</span></div><pre><code>设置NSMutableURLRequest的属性<br/><font color="#0433ff"> static NSArray * AFHTTPRequestSerializerObservedKeyPaths() {<br/>    static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil;<br/>    static dispatch_once_t onceToken;<br/>    dispatch_once(&amp;onceToken, ^{<br/>        allowsCellularAccess 允许使用数据流量<br/>        cachePolicy 缓存策略<br/>        HTTPShouldHandleCookies 处理Cookie<br/>        HTTPShouldUsePipelining 批量请求<br/>        networkServiceType 网络状态<br/>        timeoutInterval 超时<br/>        _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)), NSStringFromSelector(@selector(cachePolicy)), NSStringFromSelector(@selector(HTTPShouldHandleCookies)), NSStringFromSelector(@selector(HTTPShouldUsePipelining)), NSStringFromSelector(@selector(networkServiceType)), NSStringFromSelector(@selector(timeoutInterval))];<br/>    });<br/><br/>    return _AFHTTPRequestSerializerObservedKeyPaths;<br/>}</font></code></pre><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image [4].png" type="image/png" data-filename="Image.png"/><br/></div><div>配置NSMutableURLRequest对象</div><div><br/></div><div>先设置HTTP header，之后格式化请求参数，设置参数的编码类型。这个是这个方法的基本操作流程。对于Get操作来说，参数是直接拼接在请求地址后面。</div><h3>配置NSURLSessionDataTask对象</h3><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image [5].png" type="image/png" data-filename="Image.png"/><br/></div><div>配置NSURLSessionDataTask对象</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">之后配置NSMutableURLRequest对象就需要配置NSURLSessionDataTask对象了。主要分为2个步骤，第一个步骤是创建NSURLSessionDataTask对象实例，第二个步骤是给NSURLSessionDataTask对象实例设置Delegate。用于实时了解网络请求的过程。</span></div><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image [6].png" type="image/png" data-filename="Image.png"/><br/></div><div>给NSURLSessionDataTask对象实例设置Delegate</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">AFN的代理统一使用AFURLSessionManagerTaskDelegate对象来管理，使用AFURLSessionManagerTaskDelegate对象来接管NSURLSessionTask网络请求过程中的回调，然后再传入AFN内部进行管理。</span></div><pre><code><span>@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;</span></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">如代码所示AFURLSessionManagerTaskDelegate接管了NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate的各种回调，然后做内部处理。这也是第三方网络请求框架的重点，让网络请求更加易用，好用。</span></div><pre><code>通过task的标识符管理代理<br/><font color="#0433ff">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate<br/>            forTask:(NSURLSessionTask *)task<br/>{<br/>    NSParameterAssert(task);<br/>    NSParameterAssert(delegate);<br/><br/>    [self.lock lock];<br/>    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;<br/>    [delegate setupProgressForTask:task];<br/>    [self addNotificationObserverForTask:task];<br/>    [self.lock unlock];<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">通过NSURLSessionTask的taskIdentifier标识符对delegate进行管理，只要是用于识别该NSURLSessionTask的代理，</span></div><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image [7].png" type="image/png" data-filename="Image.png"/><br/></div><div>NSURLSessionTask设置进度回调</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">设置各类回调Block,给NSURLSessionTask使用KVO进行各种过程进度监听。</span></div><pre><code><font color="#0433ff">给task添加暂停和恢复的通知<br/>- (void)addNotificationObserverForTask:(NSURLSessionTask *)task {<br/>    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:task];<br/>    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:task];<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">监听NSURLSessionTask被挂起和恢复的通知</span></div><h2>网络请求开始</h2><pre><code><font color="#0433ff">- (NSURLSessionDataTask *)GET:(NSString *)URLString<br/>                   parameters:(id)parameters<br/>                     progress:(void (^)(NSProgress * _Nonnull))downloadProgress<br/>                      success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success<br/>                      failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure<br/>{<br/><br/>    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;GET&quot;<br/>                                                        URLString:URLString<br/>                                                       parameters:parameters<br/>                                                   uploadProgress:nil<br/>                                                 downloadProgress:downloadProgress<br/>                                                          success:success<br/>                                                          failure:failure];<br/><br/>    [dataTask resume];<br/><br/>    return dataTask;<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">当NSURLSessionTask创建和配置完毕之后，它并不会主动执行，而是需要我们主动调用resume方法，NSURLSessionTask才会开始执行。</span></div><h2>网络请求回调</h2><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image [8].png" type="image/png" data-filename="Image.png"/><br/></div><div>NSURLSessionDelegate方法</div><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image [9].png" type="image/png" data-filename="Image.png"/><br/></div><div>NSURLSessionTaskDelegate方法</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">AFN里面有关NSURLSessionDelegate的回调方法非常的多，这里我们只调和NSURLSessionTask相关的部分方法和KVO处理来进行说明，其他的大家可以参考源码细看。</span></div><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image [10].png" type="image/png" data-filename="Image.png"/><br/></div><div>KVO监听请求过程</div><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image [11].png" type="image/png" data-filename="Image.png"/><br/></div><div>收到响应数据</div><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image [12].png" type="image/png" data-filename="Image.png"/><br/></div><div>请求完成</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">对于我们的Get请求来说，我们最关注的莫过于关注请求过程进度，收到响应数据和请求完成这2个回调。</span></div><pre><code><font color="#0433ff">KVO监听的属性值发生变化<br/>- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context {<br/>    if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) {<br/>        if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) {<br/>            NSLog(@&quot;countOfBytesReceived&quot;);<br/>这个是在Get请求下，网络响应过程中已经收到的数据量<br/>            self.downloadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; 已经收到<br/>        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) {<br/>              NSLog(@&quot;countOfBytesExpectedToReceive&quot;);<br/>这个是在Get请求下，网络响应过程中期待收到的数据量<br/>            self.downloadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; 期待收到<br/>        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) {<br/>             NSLog(@&quot;countOfBytesSent&quot;);<br/>            self.uploadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; 已经发送<br/>        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) {<br/>              NSLog(@&quot;countOfBytesExpectedToSend&quot;);<br/>            self.uploadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue]; 期待发送<br/>        }<br/>    }<br/>    else if ([object isEqual:self.downloadProgress]) {<br/>         下载进度变化<br/>        if (self.downloadProgressBlock) {<br/>            self.downloadProgressBlock(object);<br/>        }<br/>    }<br/>    else if ([object isEqual:self.uploadProgress]) {<br/>         上传进度变化<br/>        if (self.uploadProgressBlock) {<br/>            self.uploadProgressBlock(object);<br/>        }<br/>    }<br/>}</font></code></pre><pre><code><font color="#0433ff">收到请求响应<br/>- (void)URLSession:(NSURLSession *)session<br/>          dataTask:(NSURLSessionDataTask *)dataTask<br/>didReceiveResponse:(NSURLResponse *)response<br/> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler<br/>{<br/>    NSLog(@&quot;收到请求响应&quot;);<br/>    NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow; 允许继续加载<br/><br/> 是否有收到请求响应的回调Block<br/>    if (self.dataTaskDidReceiveResponse) {<br/> 若有调用该Block<br/>        disposition = self.dataTaskDidReceiveResponse(session, dataTask, response);<br/>    }<br/> 是否有请求响应完成的回调Block<br/>    if (completionHandler) {<br/> 若有调用该Block<br/>        completionHandler(disposition);<br/>    }<br/>}</font></code></pre><pre><code><font color="#0433ff">请求完成<br/>- (void)URLSession:(NSURLSession *)session<br/>              task:(NSURLSessionTask *)task<br/>didCompleteWithError:(NSError *)error<br/>{<br/>    NSLog(@&quot;请求完成&quot;);<br/>取出该NSURLSessionTask的代理对象<br/>    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];<br/><br/>    if (delegate) {<br/>若是该代理对象存在，那么将对应数据转给该代理对象处理<br/>        [delegate URLSession:session task:task didCompleteWithError:error];<br/>NSURLSessionTask任务完成之后，移除该NSURLSessionTask的代理对象<br/>        [self removeDelegateForTask:task];<br/>    }<br/>是否有请求完成的回调Block<br/>    if (self.taskDidComplete) {<br/>若有调用改Block<br/>        self.taskDidComplete(session, task, error);<br/>    }<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; color: rgb(4, 51, 255);">因为在配置NSURLSessionDataTask对象的时候我们有给NSURLSessionTask做了一系列配置，那么当NSURLSessionDataTask任务完成之后，我们需要将该NSURLSessionDataTask的一系列配置全部清理掉。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; color: rgb(4, 51, 255);">这个是我们的配置过程</span></div><pre><code><font color="#0433ff">通过task的标识符管理代理<br/>- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate<br/>            forTask:(NSURLSessionTask *)task<br/>{<br/>    NSParameterAssert(task);<br/>    NSParameterAssert(delegate);<br/><br/>    [self.lock lock];<br/>    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;<br/>    [delegate setupProgressForTask:task];<br/>    [self addNotificationObserverForTask:task];<br/>    [self.lock unlock];<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em; color: rgb(4, 51, 255);">那么对应的清理过程是这样的，就是设置过程中做了什么，在清理过程中就需要去掉什么。</span></div><pre><code><font color="#0433ff">给task移除delegate<br/>- (void)removeDelegateForTask:(NSURLSessionTask *)task {<br/>    NSParameterAssert(task);<br/><br/>    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];<br/>    [self.lock lock];<br/>    [delegate cleanUpProgressForTask:task];<br/>    [self removeNotificationObserverForTask:task];<br/>    [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];<br/>    [self.lock unlock];<br/>}</font></code></pre><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image [13].png" type="image/png" data-filename="Image.png"/><br/></div><div>cleanUpProgressForTask</div><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image [14].png" type="image/png" data-filename="Image.png"/><br/></div><div>removeNotificationObserverForTask</div><h2>关于Post请求</h2><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image [15].png" type="image/png" data-filename="Image.png"/><br/></div><div>请求序列化方法</div><pre><code><font color="#0433ff">#pragma mark - AFURLRequestSerialization<br/>设置Header和请求参数<br/>- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request<br/>                               withParameters:(id)parameters<br/>                                        error:(NSError *__autoreleasing *)error<br/>{<br/>    NSParameterAssert(request);<br/><br/>    NSMutableURLRequest *mutableRequest = [request mutableCopy];<br/>    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) {<br/>        判断header的field是否存在,如果不存在则设置，存在则跳过<br/>        if (![request valueForHTTPHeaderField:field]) {<br/>            设置 header<br/>            [mutableRequest setValue:value forHTTPHeaderField:field];<br/>        }<br/>    }];<br/><br/>    NSString *query = nil;<br/>    if (parameters) {<br/>        用传进来的自定义block格式化请求参数<br/>        if (self.queryStringSerialization) {<br/>            NSError *serializationError;<br/>            query = self.queryStringSerialization(request, parameters, &amp;serializationError);<br/>            if (serializationError) {<br/>                if (error) {<br/>                    *error = serializationError;<br/>                }<br/>                return nil;<br/>            }<br/>        } else {<br/>            switch (self.queryStringSerializationStyle) {<br/>                case AFHTTPRequestQueryStringDefaultStyle:<br/>                    默认的格式化方式<br/>                    query = AFQueryStringFromParameters(parameters);<br/>                    break;<br/>            }<br/>        }<br/>    }<br/>    判断是否是GET/HEAD/DELETE方法， 对于GET/HEAD/DELETE方法，把参数加到URL后面<br/>    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) {<br/>       判断是否有参数<br/>        if (query &amp;&amp; query.length &gt; 0) {<br/>            拼接请求参数<br/>            NSLog(@&quot;query--&gt;%@&quot;,query);<br/>            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];<br/>        }<br/>    } else {<br/>         #2864: an empty string is a valid x-www-form-urlencoded payload<br/>        if (!query) {<br/>            query = @&quot;&quot;;<br/>        }<br/>        参数带在body上，大多是POST PUT<br/>        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) {<br/>            设置Content-Type HTTP头，告诉服务端body的参数编码类型<br/>            [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];<br/>        }<br/>        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];<br/>    }<br/><br/>    return mutableRequest;<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">如果是Post请求，那么请求参数是没有拼接在URL上面，而是放在body上，这个是Post和Get请求的最大区别了，其他过程和Get请求并没有太多区别。</span></div><h2>关于HTTPS请求</h2><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image [16].png" type="image/png" data-filename="Image.png"/><br/></div><div>HTTPS认证1</div><div><img src="稀土掘金  (二)  AFN3.1.0源码分析_files/Image [17].png" type="image/png" data-filename="Image.png"/><br/></div><div>HTTPS认证2</div><pre><code><font color="#0433ff">Http认证处理<br/>认证处理<br/>/*<br/> *http://www.<a href="http://cnblogs.com/polobymulberry/p/5140806.html">cnblogs.com/polobymulberry/p/5140806.html</a><br/> *web服务器接收到客户端请求时，有时候需要先验证客户端是否为正常用户，再决定是够返回真实数据。<br/> *这种情况称之为服务端要求客户端接收挑战（NSURLAuthenticationChallenge *challenge）。<br/> *接收到挑战后，<br/> *客户端要根据服务端传来的challenge来生成completionHandler所需的NSURLSessionAuthChallengeDisposition disposition和NSURLCredential *credential<br/> *（disposition指定应对这个挑战的方法，而credential是客户端生成的挑战证书，注意只有challenge中认证方法为NSURLAuthenticationMethodServerTrust的时候，才需要生成挑战证书）。<br/> *最后调用completionHandler回应服务器端的挑战。<br/> */<br/>- (void)URLSession:(NSURLSession *)session<br/>didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge<br/> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler<br/>{<br/>    NSURLAuthenticationChallenge 挑战处理类型为 默认<br/>    /*<br/>     *NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理<br/>     *NSURLSessionAuthChallengeUseCredential：使用指定的证书<br/>     *NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战<br/>     */<br/>    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;<br/>    __block NSURLCredential *credential = nil;<br/>    自定义方法，用来如何应对服务器端的认证挑战<br/>    if (self.sessionDidReceiveAuthenticationChallenge) {<br/>        disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);<br/>    } else {<br/>        服务端要求客户端提供证书<br/>        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {<br/>            客户端评估服务端的安全性<br/>            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {<br/>                客户端产生证书<br/>                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];<br/>                if (credential) {<br/>                    使用指定的证书<br/>                    disposition = NSURLSessionAuthChallengeUseCredential;<br/>                } else {<br/>                    默认处理<br/>                    disposition = NSURLSessionAuthChallengePerformDefaultHandling;<br/>                }<br/>            } else {<br/>                不处理服务端的认证要求<br/>                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;<br/>            }<br/>        } else {<br/>            disposition = NSURLSessionAuthChallengePerformDefaultHandling;<br/>        }<br/>    }<br/><br/>    if (completionHandler) {<br/>        completionHandler(disposition, credential);<br/>    }<br/>}</font></code></pre><pre><code><font color="#0433ff">如果没有实现方法<br/>/*<br/> *- (void)URLSession:(NSURLSession *)session<br/> *didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge<br/> *completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler<br/> */<br/>那么URLSession会调用下面的方法进入认证处理<br/>- (void)URLSession:(NSURLSession *)session<br/>              task:(NSURLSessionTask *)task<br/>didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge<br/> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler<br/>{<br/>    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;<br/>    __block NSURLCredential *credential = nil;<br/><br/>    if (self.taskDidReceiveAuthenticationChallenge) {<br/>        disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);<br/>    } else {<br/>        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {<br/>            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {<br/>                disposition = NSURLSessionAuthChallengeUseCredential;<br/>                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];<br/>            } else {<br/>                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;<br/>            }<br/>        } else {<br/>            disposition = NSURLSessionAuthChallengePerformDefaultHandling;<br/>        }<br/>    }<br/><br/>    if (completionHandler) {<br/>        completionHandler(disposition, credential);<br/>    }<br/>}</font></code></pre><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;">如果是HTTPS请求的话，那么会先走上面的2个代理方法进行HTTPS认证，之后继续其他操作。</span></div><h2>总结</h2><div>AFN发起Get请求主要分为以下步骤：</div><div>1.创建NSURLSessionDataTask</div><div>2.配置NSURLSessionDataTask</div><div>3.设置NSURLSessionDataTask的Delegate</div><div>4.调用NSURLSessionDataTask的resume方法开始请求</div><div>5.在Delegate的方法里面处理网络请求的各个过程</div><div>6.清理NSURLSessionDataTask的配置</div><div>其实也就是使用NSURLSessionDataTask的步骤，AFN在这几个步骤加了一些封装，让整个请求过程更加好用，易用。</div><div><br/></div><div style="font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%; font-weight: bold;">笔记整理：Edison</span></div><div style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em; border-width: 100%; font-weight: bold; color: rgb(79, 129, 189); unicode-bidi: embed;">联系方式：QQ：277593 （笔记意见建议可加此Q，专人更新此笔记）；</span></div><div style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em; border-width: 100%; color: rgb(79, 129, 189); unicode-bidi: embed;"> </span></div><div style="font-family: Menlo; font-size: 10.5pt; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="direction: ltr; font-family: Menlo; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%; font-weight: bold;">注：小道途径获取到的笔记，无法自动更新，请谅解！(笔记平均每月更新一次，祝各位都能拿到心仪的offer)</span><span style="direction: ltr; font-family: Menlo; color: rgb(79, 129, 189); margin-top: 1em; margin-bottom: 1em; unicode-bidi: embed; font-size: 10.5pt; -en-paragraph: true; border-width: 100%;"> </span></div><div><br/></div></span>
</div></body></html> 