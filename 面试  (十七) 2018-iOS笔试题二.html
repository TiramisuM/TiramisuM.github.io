<html>
<head>
  <title>面试  (十七) :2018-iOS笔试题&lt;二&gt;</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="392"/>
<h1>面试  (十七) :2018-iOS笔试题&lt;二&gt;</h1>

<div><span><h2>数组、字典等相关</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">1· 以下哪一段代码不会抛出异常（） </span><span style="-en-paragraph: true; font-weight: bold;">C</span></div><div>A NSArray *array=@[1，2，3];NSNumber * number=array[3];</div><div><br/></div><div>B NSDictionary *dict=@{@&quot;key&quot;:nil};</div><div><br/></div><div>C NSString *str=nil;NSString *str2=[str substringFromIndex:3];</div><div><br/></div><div>D NSString *str=@&quot;hi&quot;;NSString *str2=[str substringFromIndex:3];</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释：</span></div><div>A 数组越界</div><div>B 字典的Key不能为nil</div><div>D 数组下标越界</div><hr/><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">2· 关于下列程序，输出是</span></div><div>NSMutableArray* ary = [[NSMutableArray array] retain];</div><div>NSString *str = [NSString stringWithFormat:@&quot;test&quot;];</div><div>[str retain];</div><div>[ary addObject:str];</div><div>NSLog(@&quot;%@%d&quot;,str,[str retainCount]);</div><div>[str retain];</div><div>[str release];</div><div>[str release];</div><div>NSLog(@&quot;%@%d&quot;,str,[str retainCount]);</div><div>[aryremoveAllObjects];</div><div>NSLog(@&quot;%@%d&quot;,str,[str retainCount]);</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: D</span></div><div>A 2，3，1</div><div>B 3，2，1</div><div>C 1，2，3</div><div>D -1，-1，-1</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释：</span></div><div>objective-C: NSString应该用initWithFormat? 还是 stringWithFormat?</div><div><br/></div><div>今天在看书上的一段代码时，发现NSString实例化时，有时用的是initWithFormat方法，有时用的是stringWithFormat，到底应该如何选择呢？</div><div><br/></div><div>区别：</div><div><br/></div><div>1、initWithFormat是实例方法</div><div><br/></div><div>只能通过 NSString* str = [[NSString alloc] initWithFormat:@&quot;%@&quot;,@&quot;Hello World&quot;] 调用，但是必须手动release来释放内存资源</div><div><br/></div><div>2、stringWithFormat是类方法</div><div><br/></div><div>可以直接用 NSString* str = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;Hello World&quot;] 调用，内存管理上是autorelease的，不用手动显式release。</div><div><br/></div><h2>网络相关</h2><div>1· NSURLConnectionDelegate协议中的方法有哪些？</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: A B D</span></div><div>A connection:didReceiveData:</div><div>B connection:didFailWithError:</div><div>C initWithRequest:delegate:</div><div>D connectionDidFinishLoading:</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释：</span></div><div>单 看 NSURLConnectionDelegate ，答案只有 B ，而 A 和 D 属于 NSURLConnectionDataDelegate 。</div><div>仔 细 看 NSURLConnectionDataDelegate 的声明：</div><div>@protocol NSURLConnectionDataDelegate &lt;NSURLConnectionDelegate&gt;</div><div><br/></div><div>C是方法，不是代理</div><hr/><div>2· NSURLConnection类的同步请求方法是？</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: A</span></div><div>A + sendSynchronousRequest:returningResponse:error:</div><div>B – initWithRequest:delegate:</div><div>C – initWithRequest:delegate:startImmediately:</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释：B和C都是异步方法，需要设置delegate属性。</span></div><div>3· NSURL的构造函数有？</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: C D</span></div><div>+ requestWithURL:</div><div>– initWithURL:</div><div>+ URLWithString:</div><div>– initWithString:</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释：</span></div><div>[NSURL URLWithString:@&quot;<a href="http://a.com">http://a.com</a>&quot;]; </div><div><br/></div><div>[[NSURL alloc] initWithString:@&quot;<a href="http://a.com">http://a.com</a>&quot;];</div><h2>数据持久化相关</h2><div>1· iOS中持久化方式有哪些？</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: A B C D</span></div><div>A 属性列表文件</div><div>B 对象归档</div><div>C SQLite数据库</div><div>D CoreData</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释：</span></div><div>A ：属性列表文件   //NSUserDefaults 的存储，实际是本地生成一个 plist 文件，将所需属性存储在 plist 文件中</div><div>B ：对象归档     // 本地创建文件并写入数据，文件类型不限</div><div>C ： SQLite 数据库 // 本地创建数据库文件，进行数据处理</div><div>D ： CoreData    // 同数据库处理思想相同，但实现方式不同</div><div>某些情况下，B生成的文件也可以是数据库文件，但是对数据的处理方式肯定是不同的</div><div>所以，ABCD都属于本地持久化的方式</div><hr/><div>2· 以下适合在客户端做数据持久化存储的数据的有</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: B D</span></div><div>A redis</div><div>B localStorage</div><div>C sessionStorage</div><div>D userData</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释：</span></div><div>redis是一个开源使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。所以A选项中redis数据就是一个干扰项，直接排除。</div><div><br/></div><div>localStorage和sessionStorage一样都是用来存储客户端临时信息的对象。</div><div><br/></div><div>不同：localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。</div><div><br/></div><div>sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了。</div><div><br/></div><div>所以选B不选C</div><div><br/></div><div>D选项用户数据当然适合做持久化存储，免登陆就是获取之前存储的用户数据来实现的。</div><h2>指针相关</h2><div>1· 关于浅复制和深复制的说法，下列说法正确的是</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: A B D</span></div><div>A 浅层复制：只复制指向对象的指针，而不复制引用对象本身。</div><div>B 深层复制：复制引用对象本身。</div><div>C 如果是浅复制，若类中存在成员变量指针，修改一个对象一定会影响另外一个对象</div><div>D 如果是深拷贝，修改一个对象不会影响到另外一个对象</div><div>解释：</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">我认为浅拷贝是一个不喜欢思考的懒汉，而深拷贝则是一个思维严谨，喜欢思考的人。对于懒汉来说，虽然给了他任务，但是他总是想尽量的少做一些事情，所以很多时候做出来的东西就是只看到了表面，不会去思考对不对。</span></div><div>structX{intx;inty;};</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">对于懒汉来说，他很直白的看到了x，看到了y，然后就拷贝x和y，然后就不管了，反正我完成我的拷贝了，至于对不对，我不管。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">而一旦有了引用或者指针，事情就不一样了</span></div><div>structX{intx;inty;int*p;};</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">懒汉依然只是直接表面级别的拷贝，于是拷贝x, y , p，但是他没有思考接下来的事情对不对。对于指针或者引用来说，若是只是拷贝表面，那么拷贝后的物体的指针也和原来的指针指向的是同一个对象，所以虽然目的想完成一个完美的克隆体，但是却发现克隆体和原来的物体中间还有一根线连着，没有完美的分离。</span></div><div>int*p=newint(47);int*q=p;</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">如q与p都是指向一个物体一样。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">那么如果原来的物体销毁了，但是现在拷贝的物体还在，那么这时候你拷贝后的物体的成员指针就是一个悬挂指针，指向了不再存在的物体，那么你访问的话，那就不知道会发生什么了。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">而对于深拷贝，这一个勤奋的人，他不会只做表面，他会把每一个细节都照顾好。于是，当他遇到指针的时候，他会知道new出来一块新的内存，然后把原来指针指向的值拿过来，这样才是真正的完成了克隆体和原来的物体的完美分离，如果物体比作人的话，那么原来的人的每一根毛细血管都被完美的拷贝了过来，而绝非只是表面。所以，这样的代价会比浅拷贝耗费的精力更大，付出的努力更多，但是是值得的。当原来的物体销毁后，克隆体也可以活的很好。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">然而事实上是这个世界上大多都是懒汉，包括编程的人，编译器等，所以默认的行为都是浅拷贝，于是有时候你需要做一个勤奋的人，让事情做正确，自己去完成深拷贝所需要的事情。</span></div><h2>delegate、protocol相关</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">1· 使用protocol时，声明一组可选择实现与否的函数，需要在声明的前一行加上：</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: B</span></div><div>A @required</div><div>B @optional</div><div>C @interface</div><div>D @protocol</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释： 默认是</span><span style="-en-paragraph: true;">@required</span><span style="-en-paragraph: true;">,可以选择实现与否就是</span><span style="-en-paragraph: true;">@optional</span></div><h2>内省相关</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">内省（Introspection）是面向对象语言和环境的一个强大特性，Objective-C和Cocoa在这个方面尤其的丰富。内省是对象揭示自己作为一个运行时对象的详细信息的一种能力。这些详细信息包括对象在继承树上的位置，对象是否遵循特定的协议，以及是否可以响应特定的消息。NSObject协议和类定义了很多内省方法，用于查询运行时信息，以便根据对象的特征进行识别。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">明智地使用内省可以使面向对象的程序更加高效和强壮。它有助于避免错误地进行消息派发、错误地假设对象相等、以及类似的问题。</span></div><hr/><div>1· 下面哪个方法不属于NSObject的内省(Introspection)方法</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: C</span></div><div>A isMemberOfClass</div><div>B responseToSelector</div><div>C init</div><div>D isKindOfClass</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释:</span></div><div>内省是指能够揭示自己作为一个运行时对象所具有的信息的能力。对于NSObject对象来说，内省能力有，揭示对象的继承关系(isMemberOfClass,isKindOfClass)，是否遵守某个协议(confirmsToProtocol)，是否实现某个方法(respondsToSelector)</div><h2>main函数相关</h2><div>1· ios 应用程序中， main 函数在最大程度上被使用，应用程序运行的一小部分工作由 AppMain 函数来处理，是否正确？</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: B</span></div><div>A 对</div><div>B 错</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释：</span></div><div>在iOS应用程序，main函数的作用是很少的。它的主要工作是控制UIKit framework。</div><div><br/></div><div>在iPhone的应用程序中,main函数仅在最小程度上被使用,应用程序运行所需的大多数实际工作由UIApplicationMain函数来处理。</div><div><br/></div><div>main例程只做三件事:</div><div>1.创建一一个自动释放池,</div><div>2.调用UIApplicationMain函数, </div><div>3.释放自动释放池。</div><h2>测试相关</h2><div>1· iOS单元测试框架有哪些？</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: A B C</span></div><div>A OCUnit</div><div>B GHUnit</div><div>C OCMock</div><div>D 0NSXML</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释：</span></div><div>OCUnit和XCTest都是官方的测试框架，OCUnit已经过时被XCTest所取代。</div><div><br/></div><div>GHUnit和OCMock都是第三方的测试框架，其官方地址分别为：<a href="https://github.com/gh-unit/gh-unit">https://github.com/gh-unit/gh-unit</a></div><div><a href="https://github.com/erikdoe/ocmock">https://github.com/erikdoe/ocmock</a></div><h2>正则表达式相关</h2><div>1· 下列正则表达式不能匹配”<a href="https://link.jianshu.com?t=http://www.innotechx.com">www.innotechx.com</a>”的是：</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: A D</span></div><div>A ^w+.w+.w+$</div><div>B [w]{0,3}.[a-z]*.[a-z]+</div><div>C ^w.*com$</div><div>D [w]{3}.[a-z]{11}.[a-z]</div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释：</span></div><div>首先来看A选项，^表示匹配字符串的开始，而 w 和 . 是没有特殊意义的，千万不要看错成是“\w（匹配字母或数字或下划线或汉字）”了，+ 表示重复一次或者多次，$是匹配字符串的结束。所以该选项会匹配 <a href="http://www.www.www">www.www.www</a>（其中w可重复一次以上）。</div><div><br/></div><div>B选项，[w]{0,3}限定符，表示将w重复0到3次，  “ . ”无特殊意义，* 表示重复任意次，包括零次，[a-z]表示匹配a到z的字母，所以就是匹配a到z中的某一字母任意次重复。后面这个相同意思，就是+号是重复一次以上。连起来看，是可以匹配选项的。</div><div><br/></div><div>C选项，与上述选项相同，^先匹配字符串开始，然后包含一个 w ，和 &quot; . &quot;重复任意次，最后以com结尾。这个正则会匹配包含了 “wcom”的字符串，但是w要是开头，com要是结尾，所以可以匹配选项，大家可以自己试试看。</div><div><br/></div><div>D选项，重复三次w，然后一个&quot; . &quot;,但是后面这里要重复11次a到z中的某一字母，数了下题目中选项只有9个字母，后面就不要看啦，已经错啦~</div><h2>图片相关</h2><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">1· 使用imageNamed方法创建UIImage对象时，与普通的init方法有什么区别？</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">正确答案: C</span></div><div>A 没有区别，只是为了方便</div><div>B imageNamed方法只是创建了一个指针，没有分配其他内存</div><div>C imageNamed方法将图片加载到内存中后不再释放</div><div>D imageNamed方法将使用完图片后立即释放 </div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph: true;">解释：</span></div><div>imageNamed是会把读取到的image存在某个缓存里面，第二次读取相同图片的话系统就会直接从那个缓存中获取，从某种意义上好像一种优化，但是imageNamed读取到的那个图片似乎不会因为Memory Warning而释放，所以用这个会导致在 内存不足 的时候闪退。简单的说imageNamed采用了缓存机制，如果缓存中已加载了图片，直接从缓存读就行了，每次就不用再去读文件了，效率会更高。 </div></span>
</div></body></html> 