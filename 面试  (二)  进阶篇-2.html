<html>
<head>
  <title>面试  (二) : 进阶篇-2</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <meta name="application-data:corenote-hostUUID" content="C8940BC2-A53C-4B55-B59C-4779464BC778"/>
  <meta name="application-data:corenote-localUUID" content="5C839C29-B169-44EB-ADD9-09FCC6585C2D"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="956"/>
<h1>面试  (二) : 进阶篇-2</h1>

<div><span><div style="direction: ltr; font-size: 12pt; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">UITableViewCell上有个UILabel，显示NSTimer实现的秒表时间，手指滚动cell过程中，label是否刷新，为什么？</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">这是否刷新取决于timer加入到Run Loop中的Mode是什么。Mode主要是用来指定事件在运行循环中的优先级的，分为：</span></div><ul style="list-style-type: disc;"><li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态</li><li>UITrackingRunLoopMode：ScrollView滑动时会切换到该Mode</li><li>UIInitializationRunLoopMode：run loop启动时，会切换到该mode</li><li>NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">苹果公开提供的Mode有两个：</span></div><ul style="list-style-type: disc;"><li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</li><li>NSRunLoopCommonModes（kCFRunLoopCommonModes）</li><li>在编程中：如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。当我们滚动的时候，也希望不调度，那就应该使用默认模式。但是，如果希望在滚动时，定时器也要回调，那就应该使用common mode。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">对于单元格重用的理解</span></div><ul style="list-style-type: disc;"><li>当屏幕上滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元从屏幕外滑入屏幕内时，从重用队列中找看有没有可以重用的单元格，若有，就直接用，没有就重新创建一个。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">解决cell重用的问题</span></div><ul style="list-style-type: disc;"><li>UITableView通过重用单元格来达到节省内存的目的，通过为每个单元格指定一个重用标示（reuseidentifier），即指定了单元格的种类，以及当单元格滚出屏幕时，允许恢复单元格以便复用。对于不同种类的单元格使用不同的ID，对于简单的表格，一个标示符就够了。</li><li>如一个TableView中有10个单元格，但屏幕最多显示4个，实际上iPhone只为其分配4个单元格的内存，没有分配10个，当滚动单元格时，屏幕内显示的单元格重复使用这4个内存。实际上分配的cell的个数为屏幕最大显示数，当有新的cell进入屏幕时，会随机调用已经滚出屏幕的Cell所占的内存，这就是Cell的重用。</li><li>对于多变的自定义Cell，这种重用机制会导致内容出错，为解决这种出错的方法，把原来的</li></ul><table border="0"><colgroup><col></col><col></col></colgroup><tbody><tr><td><div>1</div><div>2</div></td><td><div>UITableViewCell *cell = [tableview dequeueReusableCellWithIdentifier:defineString]</div><div>修改为：UITableViewCell *cell = [tableview cellForRowAtIndexPath:indexPath];</div></td></tr></tbody></table><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">这样就解决掉cell重用机制导致的问题。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">有a、b、c、d 4个异步请求，如何判断a、b、c、d都完成执行？如果需要a、b、c、d顺序执行，该如何实现？</span></div><ul style="list-style-type: disc;"><li>对于这四个异步请求，要判断都执行完成最简单的方式就是通过GCD的group来实现：</li></ul><table border="0"><colgroup><col></col><col></col></colgroup><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div><div>7</div><div>8</div><div>9</div></td><td><div>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div>dispatch_group_t group = dispatch_group_create();</div><div>dispatch_group_async(group, queue, ^{ /*任务a */ });</div><div>dispatch_group_async(group, queue, ^{ /*任务b */ });</div><div>dispatch_group_async(group, queue, ^{ /*任务c */ }); </div><div>dispatch_group_async(group, queue, ^{ /*任务d */ }); </div><div>dispatch_group_notify(group,dispatch_get_main_queue(), ^{</div><div> // 在a、b、c、d异步执行完成后，会回调这里</div><div>});</div></td></tr></tbody></table><ul style="list-style-type: disc;"><li>当然，我们还可以使用非常老套的方法来处理，通过四个变量来标识a、b、c、d四个任务是否完成，然后在runloop中让其等待，当完成时才退出runloop。但是这样做会让后面的代码得不到执行，直到Run loop执行完毕。</li><li>解释：要求顺序执行，那么可以将任务放到串行队列中，自然就是按顺序来异步执行了。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">使用block有什么好处？使用NSTimer写出一个使用block显示（在UILabel上）秒表的代码。</span></div><ul style="list-style-type: disc;"><li>代码紧凑，传值、回调都很方便，省去了写代理的很多代码。</li><li>NSTimer封装成的block。</li><li>实现方法：</li></ul><table border="0"><colgroup><col></col><col></col></colgroup><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div><div>5</div><div>6</div></td><td><div>NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0</div><div>                              repeats:YES</div><div>                             callback:^() {</div><div>  weakSelf.secondsLabel.text = ...</div><div>}</div><div>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div></td></tr></tbody></table><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">一个view已经初始化完毕，view上面添加了n个button，除用view的tag之外，还可以采用什么办法来找到自己想要的button来修改button的值。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">有2种方法解决：</span></div><ul style="list-style-type: disc;"><li>第一种：如果是点击某个按钮后，才会刷新它的值，其它不用修改，那么不用引用任何按钮，直接在回调时，就已经将接收响应的按钮给传过来了，直接通过它修改即可。</li><li>第二种：点击某个按钮后，所有与之同类型的按钮都要修改值，那么可以通过在创建按钮时将按钮存入到数组中，在需要的时候遍历查找。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">线程与进程的区别和联系?</span></div><ul style="list-style-type: disc;"><li>一个程序至少要有进城,一个进程至少要有一个线程。</li><li>进程:资源分配的最小独立单元,进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。</li><li>线程:进程下的一个分支,是进程的实体,是CPU调度和分派的基本单元,它是比进程更小的能独立运行的基本单位,线程自己基本不拥有系统资源,只拥有一点在运行中必不可少的资源(程序计数器、一组寄存器、栈)，但是它可与同属一个进程的其他线程共享进程所拥有的全部资源。</li><li>进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。</li><li>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</li><li>但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">多线程编程</span></div><ul style="list-style-type: disc;"><li>NSThread:当需要进行一些耗时操作时会把耗时的操作放到线程中。线程同步：多个线程同时访问一个数据会出问题，NSlock、线程同步块、@synchronized(self){}。</li><li>NSOperationQueue操作队列（不需考虑线程同步问题）。编程的重点都放在main里面，NSInvocationOperation、BSBlockOperation、自定义Operation。创建一个操作绑定相应的方法，当把操作添加到操作队列中时，操作绑定的方法就会自动执行了，当把操作添加到操作队列中时，默认会调用main方法。</li><li>GCD（`Grand Central Dispatch）宏大的中央调度，串行队列、并发队列、主线程队列；</li><li>同步和异步：同步指第一个任务不执行完，不会开始第二个，异步是不管第一个有没有执行完，都开始第二个。</li><li>串行和并行：串行是多个任务按一定顺序执行，并行是多个任务同时执行；</li><li>代码是在分线程执行，在主线程嘟列中刷新UI。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC'; font-weight: bold;">多线程编程是防止主线程堵塞、增加运行效率的最佳方法。</span></div><ul style="list-style-type: disc;"><li>Apple提供了NSOperation这个类，提供了一个优秀的多线程编程方法；</li><li>一个NSOperationQueue操作队列，相当于一个线程管理器，而非一个线程，因为你可以设置这个线程管理器内可以并行运行的线程数量等。</li><li>多线程是一个比较轻量级的方法来实现单个应用程序内多个代码执行路径。</li><li>iPhoneOS下的主线程的堆栈大小是1M。第二个线程开始就是512KB，并且该值不能通过编译器开关或线程API函数来更改，只有主线程有直接修改UI的能力。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">定时器与线程的区别</span></div><ul style="list-style-type: disc;"><li>定时器;可以执行多次，默认在主线程中。</li><li>线程：只能执行一次。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">Apple设备尺寸和编程尺寸</span></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><div><img src="面试  (二)  进阶篇-2_files/Image.png" type="image/png" data-filename="Image.png"/><br/></div></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">iPhone设备</span></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><div><img src="面试  (二)  进阶篇-2_files/Image [1].png" type="image/png" data-filename="Image.png"/><br/></div></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">iPod设备</span></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><div><img src="面试  (二)  进阶篇-2_files/Image [2].png" type="image/png" data-filename="Image.png"/><br/></div></div><div style="text-align: center; -en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">iPad设备</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">TCP和UDP的区别于联系</span></div><ul style="list-style-type: disc;"><li>TCP为传输控制层协议，为面向连接、可靠的、点到点的通信；</li><li>UDP为用户数据报协议，非连接的不可靠的点到多点的通信；</li><li>TCP侧重可靠传输，UDP侧重快速传输。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">TCP连接的三次握手</span></div><ul style="list-style-type: disc;"><li>第一次握手：客户端发送syn包（syn=j）到服务器，并进入SYN_SEND状态，等待服务器确认；</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN+RECV状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次状态。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">Scoket连接和HTTP连接的区别</span></div><ul style="list-style-type: disc;"><li>HTTP协议是基于TCP连接的，是应用层协议，主要解决如何包装数据。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</li><li>HTTP连接：短连接，客户端向服务器发送一次请求，服务器响应后连接断开，节省资源。服务器不能主动给客户端响应（除非采用HTTP长连接技术），iPhone主要使用类NSURLConnection。</li><li>Socket连接：长连接，客户端跟服务器端直接使用Socket进行连接，没有规定连接后断开，因此客户端和服务器段保持连接通道，双方可以主动发送数据，一般多用于游戏.Socket默认连接超时时间是30秒，默认大小是8K（理解为一个数据包大小）。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">HTTP协议的特点，关于HTTP请求GET和POST的区别</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 0, 0); font-family: 'PingFang SC'; font-weight: bold;">GET和POST的区别：</span></div><ul style="list-style-type: disc;"><li>HTTP超文本传输协议，是短连接，是客户端主动发送请求，服务器做出响应，服务器响应之后，链接断开。HTTP是一个属于应用层面向对象的协议，HTTP有两类报文：请求报文和响应报文。</li><li>HTTP请求报文：一个HTTP请求报文由请求行、请求头部、空行和请求数据4部分组成。</li><li>HTTP响应报文：由三部分组成：状态行、消息报头、响应正文。</li><li>GET请求：参数在地址后拼接，没有请求数据，不安全（因为所有参数都拼接在地址后面），不适合传输大量数据（长度有限制，为1024个字节）。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(149, 55, 52); font-family: 'PingFang SC';">GET提交、请求的数据会附在URL之后，即把数据放置在HTTP协议头中。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(149, 55, 52); font-family: 'PingFang SC';">以？分割URL和传输数据，多个参数用&amp;连接。如果数据是英文字母或数字，原样发送，</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(149, 55, 52); font-family: 'PingFang SC';">如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密。</span></div><ul style="list-style-type: disc;"><li>POST请求：参数在请求数据区放着，相对GET请求更安全，并且数据大小没有限制。把提交的数据放置在HTTP包的包体中.</li><li>GET提交的数据会在地址栏显示出来，而POST提交，地址栏不会改变。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC'; font-weight: bold;">传输数据的大小：</span></div><ul style="list-style-type: disc;"><li>GET提交时，传输数据就会受到URL长度限制，POST由于不是通过URL传值，理论上书不受限。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC'; font-weight: bold;">安全性：</span></div><ul style="list-style-type: disc;"><li>POST的安全性要比GET的安全性高；</li><li>通过GET提交数据，用户名和密码将明文出现在URL上，比如登陆界面有可能被浏览器缓存。</li><li>HTTPS：安全超文本传输协议（Secure Hypertext Transfer Protocol），它是一个安全通信通道，基于HTTP开发，用于客户计算机和服务器之间交换信息，使用安全套结字层（SSI）进行信息交换，即HTTP的安全版。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">ASIHttpRequest、AFNetWorking之间的区别</span></div><ul style="list-style-type: disc;"><li>ASIHttpRequest功能强大，主要是在MRC下实现的，是对系统CFNetwork API进行了封装，支持HTTP协议的CFHTTP，配置比较复杂，并且ASIHttpRequest框架默认不会帮你监听网络改变，如果需要让ASIHttpRequest帮你监听网络状态改变，并且手动开始这个功能。</li><li>AFNetWorking构建于NSURLConnection、NSOperation以及其他熟悉的Foundation技术之上。拥有良好的架构，丰富的API及模块构建方式，使用起来非常轻松。它基于NSOperation封装的，AFURLConnectionOperation子类。</li><li>ASIHttpRequest是直接操作对象ASIHttpRequest是一个实现了NSCoding协议的NSOperation子类；AFNetWorking直接操作对象的AFHttpClient，是一个实现NSCoding和NSCopying协议的NSObject子类。</li><li>同步请求：ASIHttpRequest直接通过调用一个startSynchronous方法；AFNetWorking默认没有封装同步请求，如果开发者需要使用同步请求，则需要重写getPath:paraments:success:failures方法，对于AFHttpRequestOperation进行同步处理。</li><li>性能对比：AFNetworking请求优于ASIHttpRequest；</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">XML数据解析方式各有什么不同，JSON解析有哪些框架？</span></div><ul style="list-style-type: disc;"><li>XML数据解析的两种解析方式：DOM解析和SAX解析；</li><li>DOM解析必须完成DOM树的构造，在处理规模较大的XML文档时就很耗内存，占用资源较多，读入整个XML文档并构建一个驻留内存的树结构（节点树），通过遍历树结构可以检索任意XML节点，读取它的属性和值，通常情况下，可以借助XPath查询XML节点；</li><li>SAX与DOM不同，它是事件驱动模型，解析XML文档时每遇到一个开始或者结束标签、属性或者一条指令时，程序就产生一个事件进行相应的处理，一边读取XML文档一边处理，不必等整个文档加载完才采取措施，当在读取解析过程中遇到需要处理的对象，会发出通知进行处理。因此，SAX相对于DOM来说更适合操作大的XML文档。</li><li>JSON解析：性能比较好的主要是第三方的JSONKIT和iOS自带的JSON解析类，其中自带的JSON解析性能最高，但只能用于iOS5之后。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">如何进行真机调试？</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">1.首先需要用钥匙串创建一个钥匙（key）；</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">2.将钥匙串上传到官网，获取iOS Development证书；</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">3.创建App ID即我们应用程序中的Boundle ID；</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">4.添加Device ID即UDID；</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">5.通过勾选前面所创建的证书：App ID、Device ID；</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">6.生成mobileprovision文件；</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">7.先决条件：申请开发者账号 99美刀</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">SVN的使用</span></div><ul style="list-style-type: disc;"><li>SVN=版本控制+备份服务器，可以把SVN当成备份服务器，并且可以帮助你记住每次上服务器的档案内容，并自动赋予每次变更的版本；</li><li>SVN的版本控制：所有上传版本都会帮您记录下来，也有版本分支及合并等功能。SVN可以让不同的开发者存取同样的档案，并且利用SVN Server作为档案同步的机制，即您有档案更新时，无需将档案寄送给您的开发成员。SVN的存放档案方式是采用差异备份的方式，即会备份到不同的地方，节省硬盘空间，也可以对非文字文件进行差异备份。</li><li>SVN的重要性：备份工作档案的重要性、版本控管的重要性、伙伴间的数据同步的重要性、备份不同版本是很耗费硬盘空间的；</li><li>防止冲突：</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">1.防止代码冲突：不要多人同时修改同一文件，例如：A、B都修改同一个文件，先让A修改，然后提交到服务器，然后B更新下来，再进行修改；</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">2.服务器上的项目文件Xcodeproj，仅让一个人管理提交，其他人只更新，防止文件发生冲突。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; color: rgb(0, 176, 80); font-family: 'PingFang SC'; font-weight: bold;">如何进行网络消息推送</span></div><ul style="list-style-type: disc;"><li>一种是Apple自己提供的通知服务（APNS服务器）、一种是用第三方推送机制。</li><li>首先应用发送通知，系统弹出提示框询问用户是否允许，当用户允许后向苹果服务器(APNS)请求deviceToken，并由苹果服务器发送给自己的应用，自己的应用将DeviceToken发送自己的服务器，自己服务器想要发送网络推送时将deviceToken以及想要推送的信息发送给苹果服务器，苹果服务器将信息发送给应用。</li><li>推送信息内容，总容量不超过256个字节；</li><li>iOS SDK本身提供的APNS服务器推送，它可以直接推送给目标用户并根据您的方式弹出提示。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">优点：不论应用是否开启，都会发送到手机端；</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">缺点：消息推送机制是苹果服务端控制，个别时候可能会有延迟，因为苹果服务器也有队列来处理所有的消息请求；</span></div><ul style="list-style-type: disc;"><li>第三方推送机制，普遍使用Socket机制来实现，几乎可以达到即时的发送到目标用户手机端，适用于即时通讯类应用。</li></ul><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">优点：实时的，取决于心跳包的节奏；</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 16px; font-family: 'PingFang SC';">缺点：iOS系统的限制，应用不能长时间的后台运行，所以应用关闭的情况下这种推送机制不可用。</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><br/></div></span>
</div></body></html> 