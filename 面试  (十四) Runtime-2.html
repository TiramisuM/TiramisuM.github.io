<html>
<head>
  <title>面试  (十四) :Runtime-2</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="383"/>
<h1>面试  (十四) :Runtime-2</h1>

<div><span><div><span style="font-size: 18px; font-weight: bold;">前言：先自己尝试去回答，回答不了再看参考答案，你才能学的更多！</span></div><div><br/></div><div><span style="font-size: 18px; font-weight: bold;">1. runtime怎么添加属性、方法？</span></div><div><span style="font-size: 18px;">* ivar表示成员变量</span></div><div><span style="font-size: 18px;">* class_addIvar</span></div><div><span style="font-size: 18px;">* class_addMethod</span></div><div><span style="font-size: 18px;">* class_addProperty</span></div><div><span style="font-size: 18px;">* class_addProtocol</span></div><div><span style="font-size: 18px;">* class_replaceProperty</span></div><div><br/></div><div><span style="font-size: 18px; font-weight: bold;">2. runtime 如何实现 weak 属性？</span></div><div><span style="font-size: 18px;">weak策略表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似;然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">那么runtime如何实现weak变量的自动置nil？</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">runtime对注册的类，会进行布局，会将 weak 对象放入一个 hash 表中。用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会调用对象的 dealloc 方法，假设 weak 指向的对象内存地址是a，那么就会以a为key，在这个 weak hash表中搜索，找到所有以a为key的 weak 对象，从而设置为 nil。</span></div><div><span style="font-size: 18px;">weak属性需要在dealloc中置nil么</span></div><div><span style="font-size: 18px;">在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理</span></div><div><span style="font-size: 18px;">即便是编译器不帮我们做这些，weak也不需要在dealloc中置nil</span></div><div><span style="font-size: 18px;">在属性所指的对象遭到摧毁时，属性值也会清空！</span></div><div><br/></div><div><br/></div><div><span style="font-size: 18px; font-weight: bold;">3. runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</span></div><div><span style="font-size: 18px;">1.每一个类对象中都一个对象方法列表（对象方法缓存）</span></div><div><span style="font-size: 18px;">2.类方法列表是存放在类对象中isa指针指向的元类对象中（类方法缓存）</span></div><div><span style="font-size: 18px;">3.方法列表中每个方法结构体中记录着方法的名称,方法实现,以及参数类型，其实selector本质就是4.方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</span></div><div><span style="font-size: 18px;">5.当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类对象方法列表里查找</span></div><div><span style="font-size: 18px;">6.当我们发送一个消息给一个类时，这条消息会在类的Meta Class对象的方法列表里查找</span></div><div><br/></div><div><span style="font-size: 18px; font-weight: bold;">4. 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</span></div><blockquote><div><span style="font-size: 18px;">无论在MRC下还是ARC下均不需要被关联的对象在生命周期内要比对象本身释放的晚很多，它们会在被 NSObject -dealloc 调用的object_dispose()方法中释放</span></div><div style="-en-paragraph: true; margin-top: 1em; margin-bottom: 1em;"><span style="font-size: 18px;">补充：对象的内存销毁时间表，分四个步骤</span></div><div><span style="font-size: 18px;">1、调用 -release ：引用计数变为零</span></div><div><span style="font-size: 18px;">* 对象正在被销毁，生命周期即将结束. </span></div><div><span style="font-size: 18px;">* 不能再有新的 __weak 弱引用，否则将指向 nil.</span></div><div><span style="font-size: 18px;">* 调用 [self dealloc]</span></div><div><br style="font-size: 18px;"/></div><div><span style="font-size: 18px;">2、 父类调用 -dealloc </span></div><div><span style="font-size: 18px;">* 继承关系中最直接继承的父类再调用 -dealloc </span></div><div><span style="font-size: 18px;">* 如果是 MRC 代码 则会手动释放实例变量们（iVars）</span></div><div><span style="font-size: 18px;">* 继承关系中每一层的父类 都再调用 -dealloc</span></div><div><br style="font-size: 18px;"/></div><div><span style="font-size: 18px;">3、NSObject 调 -dealloc </span></div><div><span style="font-size: 18px;">* 只做一件事：调用 Objective-C runtime 中object_dispose() 方法</span></div><div><br style="font-size: 18px;"/></div><div><span style="font-size: 18px;">4. 调用 object_dispose()</span></div><div><span style="font-size: 18px;">* 为 C++ 的实例变量们（iVars）调用 destructors</span></div><div><span style="font-size: 18px;">* 为 ARC 状态下的 实例变量们（iVars） 调用 -release </span></div><div><span style="font-size: 18px;">* 解除所有使用 runtime Associate方法关联的对象 </span></div><div><span style="font-size: 18px;">* 解除所有 __weak 引用 </span></div><div><span style="font-size: 18px;">* 调用 free()</span></div><div><br/></div></blockquote><div><span style="font-size: 18px; font-weight: bold;">5. _objc_msgForward函数是做什么的？直接调用它将会发生什么？</span></div><div><span style="font-size: 18px;">_objc_msgForward是IMP类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发</span></div><div><span style="font-size: 18px;">直接调用_objc_msgForward是非常危险</span></div><div><span style="font-size: 18px;">的事，这是把双刃刀，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事</span></div><div><br/></div><div><span style="font-size: 18px; font-weight: bold;">6. 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</span></div><div><span style="font-size: 18px;">不能向编译后得到的类中增加实例变量；</span></div><div><span style="font-size: 18px;">能向运行时创建的类中添加实例变量；</span></div><div><span style="font-size: 18px;"> 分析如下：</span></div><div><span style="font-size: 18px;">1.因为编译后的类已经注册在runtime中，类结构体中的objc_ivar_list 实例变量的链表和instance_size实例变量的内存大小已经确定，同时runtime 会调用class_setIvarLayout 或 class_setWeakIvarLayout来处理strong weak引用，所以不能向存在的类中添加实例变量</span></div><div><span style="font-size: 18px;"> 2.运行时创建的类是可以添加实例变量，调用 class_addIvar函数，但是得在调用objc_allocateClassPair之后，objc_registerClassPair之前，原因同上。</span></div><div><br/></div><div><span style="font-size: 18px; font-weight: bold;">7. 简述下Objective-C中调用方法的过程（runtime）</span></div><div><span style="font-size: 18px; font-weight: bold;">    </span><span style="font-size: 18px;">Objective-C是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)，整个过程介绍如下：</span></div><div><br/></div><div><span style="font-size: 18px;">    1.objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类</span></div><div><span style="font-size: 18px;">    2.然后在该类中的方法列表以及其父类方法列表中寻找方法运行</span></div><div><span style="font-size: 18px;">    3.如果，在最顶层的父类（一般也就NSObject）中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX</span></div><div><span style="font-size: 18px;">     但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会，这三次拯救程序奔溃的说明见问题《什么时候会报unrecognized selector的异常》中的说明</span></div><div><br/></div><div><span style="font-size: 18px;">     补充说明：Runtime 铸就了Objective-C 是动态语言的特性，使得C语言具备了面向对象的特性，在程序运行期创建，检查，修改类、对象及其对应的方法，这些操作都可以使用runtime中的对应方法实现。</span></div><div><br/></div><div><span style="font-size: 18px; font-weight: bold;">8. 什么是method swizzling（俗称黑魔法）</span></div><blockquote><ul><li>简单说就是进行方法交换</li><li>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的</li><li>每个类都有一个方法列表，存放着方法的名字和方法实现的映射关系，selector的本质其实就是方法名，IMP有点类似函数指针，指向具体的Method实现，通过selector就可以找到对应的IMP</li></ul><div><img src="面试  (十四) Runtime-2_files/Image.png" type="image/png" data-filename="Image.png" style="font-weight: bold; font-size: 18px;"/><br/></div><div><br/></div><ul><li>交换方法的几种实现方式</li><ul><li>利用 method_exchangeImplementations 交换两个方法的实现</li><li>利用 class_replaceMethod 替换方法的实现</li><li>利用 method_setImplementation 来直接设置某个方法的IMP<br/><img src="面试  (十四) Runtime-2_files/Image [1].png" type="image/png" data-filename="Image.png"/><br/><br/></li></ul></ul></blockquote><div><br/></div><div><br/></div></span>
</div></body></html> 